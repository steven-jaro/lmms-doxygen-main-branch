<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LMMS: asio::buffer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LMMS
   </div>
   <div id="projectbrief">Linux MultiMedia Studio - Complete Codebase</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__buffer.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">asio::buffer </div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="namespaceasio.html#aab2e5a8bd2a00b088a5644c64ef73e2a" title="Create a new modifiable buffer from an existing buffer.">asio::buffer</a> function is used to create a buffer object to represent raw memory, an array of POD elements, a vector of POD elements, or a std::string.  
</p>
<p>The <a class="el" href="namespaceasio.html#aab2e5a8bd2a00b088a5644c64ef73e2a" title="Create a new modifiable buffer from an existing buffer.">asio::buffer</a> function is used to create a buffer object to represent raw memory, an array of POD elements, a vector of POD elements, or a std::string. </p>
<p>A buffer object represents a contiguous region of memory as a 2-tuple consisting of a pointer and size in bytes. A tuple of the form <span class="tt">{void*,
size_t}</span> specifies a mutable (modifiable) region of memory. Similarly, a tuple of the form <span class="tt">{<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> void*, size_t}</span> specifies a const (non-modifiable) region of memory. These two forms correspond to the classes <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> and <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a>, respectively. To mirror C++'s conversion rules, a <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> is implicitly convertible to a <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a>, and the opposite conversion is not permitted.</p>
<p>The simplest use case involves reading or writing a single buffer of a specified size:</p>
<div class="fragment"><div class="line">sock.send(<a class="code hl_function" href="namespaceasio.html#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, size)); </div>
<div class="ttc" id="ajpeglib_8h_html_aa379dc8ae39e55ae0c431a61a7d2f2bc"><div class="ttname"><a href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a></div><div class="ttdeci">JSAMPIMAGE data</div><div class="ttdef"><b>Definition</b> jpeglib.h:945</div></div>
<div class="ttc" id="anamespaceasio_html_aab2e5a8bd2a00b088a5644c64ef73e2a"><div class="ttname"><a href="namespaceasio.html#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a></div><div class="ttdeci">ASIO_MUTABLE_BUFFER buffer(const mutable_buffer &amp;b) ASIO_NOEXCEPT</div><div class="ttdoc">Create a new modifiable buffer from an existing buffer.</div><div class="ttdef"><b>Definition</b> buffer.hpp:907</div></div>
</div><!-- fragment --><p>In the above example, the return value of <a class="el" href="namespaceasio.html#aab2e5a8bd2a00b088a5644c64ef73e2a" title="Create a new modifiable buffer from an existing buffer.">asio::buffer</a> meets the requirements of the ConstBufferSequence concept so that it may be directly passed to the socket's write function. A buffer created for modifiable memory also meets the requirements of the MutableBufferSequence concept.</p>
<p>An individual buffer may be created from a builtin array, std::vector, std::array or <a class="el" href="classboost_1_1array.html">boost::array</a> of POD elements. This helps prevent buffer overruns by automatically determining the size of the buffer:</p>
<div class="fragment"><div class="line"> <span class="keywordtype">char</span> d1[128];</div>
<div class="line"><span class="keywordtype">size_t</span> bytes_transferred = sock.receive(<a class="code hl_function" href="namespaceasio.html#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(d1));</div>
<div class="line"> </div>
<div class="line">std::vector&lt;char&gt; d2(128);</div>
<div class="line">bytes_transferred = sock.receive(<a class="code hl_function" href="namespaceasio.html#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(d2));</div>
<div class="line"> </div>
<div class="line">std::array&lt;char, 128&gt; d3;</div>
<div class="line">bytes_transferred = sock.receive(<a class="code hl_function" href="namespaceasio.html#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(d3));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classboost_1_1array.html">boost::array&lt;char, 128&gt;</a> d4;</div>
<div class="line">bytes_transferred = sock.receive(<a class="code hl_function" href="namespaceasio.html#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(d4)); </div>
<div class="ttc" id="aclassboost_1_1array_html"><div class="ttname"><a href="classboost_1_1array.html">boost::array</a></div><div class="ttdef"><b>Definition</b> array_fwd.hpp:23</div></div>
</div><!-- fragment --><p>In all three cases above, the buffers created are exactly 128 bytes long. Note that a vector is <em>never</em> automatically resized when creating or using a buffer. The buffer size is determined using the vector's <span class="tt">size()</span> member function, and not its capacity.</p>
<dl class="section user"><dt>Accessing Buffer Contents</dt><dd></dd></dl>
<p>The contents of a buffer may be accessed using the <code><a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data()</a></code> and <code>size()</code> member functions:</p>
<div class="fragment"><div class="line"> <a class="code hl_class" href="classasio_1_1mutable__buffer.html">asio::mutable_buffer</a> b1 = ...;</div>
<div class="line">std::size_t s1 = b1.size();</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* p1 = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(b1.data());</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classasio_1_1const__buffer.html">asio::const_buffer</a> b2 = ...;</div>
<div class="line">std::size_t s2 = b2.size();</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">void</span>* p2 = b2.data(); </div>
<div class="ttc" id="aclassasio_1_1const__buffer_html"><div class="ttname"><a href="classasio_1_1const__buffer.html">asio::const_buffer</a></div><div class="ttdoc">Holds a buffer that cannot be modified.</div><div class="ttdef"><b>Definition</b> buffer.hpp:225</div></div>
<div class="ttc" id="aclassasio_1_1mutable__buffer_html"><div class="ttname"><a href="classasio_1_1mutable__buffer.html">asio::mutable_buffer</a></div><div class="ttdoc">Holds a buffer that can be modified.</div><div class="ttdef"><b>Definition</b> buffer.hpp:91</div></div>
</div><!-- fragment --><p>The <code><a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data()</a></code> member function permits violations of type safety, so uses of it in application code should be carefully considered.</p>
<p>For convenience, a <a class="el" href="namespaceasio.html#ac72f80e47f237b42d777bd7eb2653798">buffer_size</a> function is provided that works with both buffers and buffer sequences (that is, types meeting the ConstBufferSequence or MutableBufferSequence type requirements). In this case, the function returns the total size of all buffers in the sequence.</p>
<dl class="section user"><dt>Buffer Copying</dt><dd></dd></dl>
<p>The <a class="el" href="group__buffer__copy.html">asio::buffer_copy</a> function may be used to copy raw bytes between individual buffers and buffer sequences.</p>
<p>In particular, when used with the <a class="el" href="namespaceasio.html#ac72f80e47f237b42d777bd7eb2653798">buffer_size</a> function, the <a class="el" href="group__buffer__copy.html">asio::buffer_copy</a> function can be used to linearise a sequence of buffers. For example:</p>
<div class="fragment"><div class="line"> <a class="code hl_class" href="classvector.html">vector&lt;const_buffer&gt;</a> <a class="code hl_variable" href="namespaceasio.html#a54dede45c3175148a77fe6635222c47d">buffers</a> = ...;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classvector.html">vector&lt;unsigned char&gt;</a> <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>(<a class="code hl_function" href="namespaceasio.html#ac72f80e47f237b42d777bd7eb2653798">asio::buffer_size</a>(<a class="code hl_variable" href="namespaceasio.html#a54dede45c3175148a77fe6635222c47d">buffers</a>));</div>
<div class="line"><a class="code hl_function" href="namespaceasio.html#a160d0c4badd630c133c213c66b095fc1">asio::buffer_copy</a>(<a class="code hl_function" href="namespaceasio.html#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>), <a class="code hl_variable" href="namespaceasio.html#a54dede45c3175148a77fe6635222c47d">buffers</a>); </div>
<div class="ttc" id="aclassvector_html"><div class="ttname"><a href="classvector.html">vector</a></div></div>
<div class="ttc" id="anamespaceasio_html_a160d0c4badd630c133c213c66b095fc1"><div class="ttname"><a href="namespaceasio.html#a160d0c4badd630c133c213c66b095fc1">asio::buffer_copy</a></div><div class="ttdeci">std::size_t buffer_copy(const MutableBufferSequence &amp;target, const ConstBufferSequence &amp;source) ASIO_NOEXCEPT</div><div class="ttdoc">Copies bytes from a source buffer sequence to a target buffer sequence.</div><div class="ttdef"><b>Definition</b> buffer.hpp:2361</div></div>
<div class="ttc" id="anamespaceasio_html_a54dede45c3175148a77fe6635222c47d"><div class="ttname"><a href="namespaceasio.html#a54dede45c3175148a77fe6635222c47d">asio::buffers</a></div><div class="ttdeci">const MutableBufferSequence &amp; buffers</div><div class="ttdef"><b>Definition</b> read.hpp:522</div></div>
<div class="ttc" id="anamespaceasio_html_ac72f80e47f237b42d777bd7eb2653798"><div class="ttname"><a href="namespaceasio.html#ac72f80e47f237b42d777bd7eb2653798">asio::buffer_size</a></div><div class="ttdeci">std::size_t buffer_size(const BufferSequence &amp;b) ASIO_NOEXCEPT</div><div class="ttdoc">Get the total number of bytes in a buffer sequence.</div><div class="ttdef"><b>Definition</b> buffer.hpp:593</div></div>
</div><!-- fragment --><p>Note that <a class="el" href="group__buffer__copy.html">asio::buffer_copy</a> is implemented in terms of <code>memcpy</code>, and consequently it cannot be used to copy between overlapping memory regions.</p>
<dl class="section user"><dt>Buffer Invalidation</dt><dd></dd></dl>
<p>A buffer object does not have any ownership of the memory it refers to. It is the responsibility of the application to ensure the memory region remains valid until it is no longer required for an I/O operation. When the memory is no longer available, the buffer is said to have been invalidated.</p>
<p>For the <a class="el" href="namespaceasio.html#aab2e5a8bd2a00b088a5644c64ef73e2a" title="Create a new modifiable buffer from an existing buffer.">asio::buffer</a> overloads that accept an argument of type std::vector, the buffer objects returned are invalidated by any vector operation that also invalidates all references, pointers and iterators referring to the elements in the sequence (C++ Std, 23.2.4)</p>
<p>For the <a class="el" href="namespaceasio.html#aab2e5a8bd2a00b088a5644c64ef73e2a" title="Create a new modifiable buffer from an existing buffer.">asio::buffer</a> overloads that accept an argument of type std::basic_string, the buffer objects returned are invalidated according to the rules defined for invalidation of references, pointers and iterators referring to elements of the sequence (C++ Std, 21.3).</p>
<dl class="section user"><dt>Buffer Arithmetic</dt><dd></dd></dl>
<p>Buffer objects may be manipulated using simple arithmetic in a safe way which helps prevent buffer overruns. Consider an array initialised as follows:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classboost_1_1array.html">boost::array&lt;char, 6&gt;</a> <a class="code hl_variable" href="Spc__Cpu_8h.html#a4b87847040966f886849e0c36d6ed53b">a</a> = { <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span> }; </div>
<div class="ttc" id="aSpc__Cpu_8h_html_a4b87847040966f886849e0c36d6ed53b"><div class="ttname"><a href="Spc__Cpu_8h.html#a4b87847040966f886849e0c36d6ed53b">a</a></div><div class="ttdeci">uint8_t a</div><div class="ttdef"><b>Definition</b> Spc_Cpu.h:141</div></div>
</div><!-- fragment --><p>A buffer object <code>b1</code> created using:</p>
<div class="fragment"><div class="line">b1 = <a class="code hl_function" href="namespaceasio.html#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(<a class="code hl_variable" href="Spc__Cpu_8h.html#a4b87847040966f886849e0c36d6ed53b">a</a>); </div>
</div><!-- fragment --><p>represents the entire array, <span class="tt">{ '<a class="el" href="Spc__Cpu_8h.html#a4b87847040966f886849e0c36d6ed53b">a</a>', '<a class="el" href="namespaceasio.html#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>', '<a class="el" href="Spc__Cpu_8h.html#a4e1e0e72dd773439e333c84dd762a9c3">c</a>', 'd', 'e' }</span>. An optional second argument to the <a class="el" href="namespaceasio.html#aab2e5a8bd2a00b088a5644c64ef73e2a" title="Create a new modifiable buffer from an existing buffer.">asio::buffer</a> function may be used to limit the size, in bytes, of the buffer:</p>
<div class="fragment"><div class="line">b2 = <a class="code hl_function" href="namespaceasio.html#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(<a class="code hl_variable" href="Spc__Cpu_8h.html#a4b87847040966f886849e0c36d6ed53b">a</a>, 3); </div>
</div><!-- fragment --><p>such that <code>b2</code> represents the data <span class="tt">{ '<a class="el" href="Spc__Cpu_8h.html#a4b87847040966f886849e0c36d6ed53b">a</a>', '<a class="el" href="namespaceasio.html#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>', '<a class="el" href="Spc__Cpu_8h.html#a4e1e0e72dd773439e333c84dd762a9c3">c</a>' }</span>. Even if the size argument exceeds the actual size of the array, the size of the buffer object created will be limited to the array size.</p>
<p>An offset may be applied to an existing buffer to create a new one:</p>
<div class="fragment"><div class="line">b3 = b1 + 2; </div>
</div><!-- fragment --><p>where <code>b3</code> will set to represent <span class="tt">{ '<a class="el" href="Spc__Cpu_8h.html#a4e1e0e72dd773439e333c84dd762a9c3">c</a>', 'd', 'e' }</span>. If the offset exceeds the size of the existing buffer, the newly created buffer will be empty.</p>
<p>Both an offset and size may be specified to create a buffer that corresponds to a specific range of bytes within an existing buffer:</p>
<div class="fragment"><div class="line">b4 = <a class="code hl_function" href="namespaceasio.html#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(b1 + 1, 3); </div>
</div><!-- fragment --><p>so that <code>b4</code> will refer to the bytes <span class="tt">{ '<a class="el" href="namespaceasio.html#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>', '<a class="el" href="Spc__Cpu_8h.html#a4e1e0e72dd773439e333c84dd762a9c3">c</a>', 'd' }</span>.</p>
<dl class="section user"><dt>Buffers and Scatter-Gather I/O</dt><dd></dd></dl>
<p>To read or write using multiple buffers (i.e. scatter-gather I/O), multiple buffer objects may be assigned into a container that supports the MutableBufferSequence (for read) or ConstBufferSequence (for write) concepts:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> d1[128];</div>
<div class="line">std::vector&lt;char&gt; d2(128);</div>
<div class="line"><a class="code hl_class" href="classboost_1_1array.html">boost::array&lt;char, 128&gt;</a> d3;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classboost_1_1array.html">boost::array&lt;mutable_buffer, 3&gt;</a> bufs1 = {</div>
<div class="line">  <a class="code hl_function" href="namespaceasio.html#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(d1),</div>
<div class="line">  <a class="code hl_function" href="namespaceasio.html#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(d2),</div>
<div class="line">  <a class="code hl_function" href="namespaceasio.html#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(d3) };</div>
<div class="line">bytes_transferred = sock.receive(bufs1);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;const_buffer&gt; bufs2;</div>
<div class="line">bufs2.push_back(<a class="code hl_function" href="namespaceasio.html#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(d1));</div>
<div class="line">bufs2.push_back(<a class="code hl_function" href="namespaceasio.html#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(d2));</div>
<div class="line">bufs2.push_back(<a class="code hl_function" href="namespaceasio.html#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(d3));</div>
<div class="line">bytes_transferred = sock.send(bufs2); </div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
