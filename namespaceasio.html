<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LMMS: asio Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LMMS
   </div>
   <div id="projectbrief">Linux MultiMedia Studio - Complete Codebase</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespaceasio.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">asio Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:detail" id="r_detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1detail.html">detail</a></td></tr>
<tr class="memitem:chrono" id="r_chrono"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1chrono.html">chrono</a></td></tr>
<tr class="memitem:error" id="r_error"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1error.html">error</a></td></tr>
<tr class="memitem:stream_5Ferrc" id="r_stream_5Ferrc"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1stream__errc.html">stream_errc</a></td></tr>
<tr class="memitem:socket_5Ferrc" id="r_socket_5Ferrc"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1socket__errc.html">socket_errc</a></td></tr>
<tr class="memitem:resolver_5Ferrc" id="r_resolver_5Ferrc"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1resolver__errc.html">resolver_errc</a></td></tr>
<tr class="memitem:generic" id="r_generic"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1generic.html">generic</a></td></tr>
<tr class="memitem:ip" id="r_ip"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1ip.html">ip</a></td></tr>
<tr class="memitem:placeholders" id="r_placeholders"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1placeholders.html">placeholders</a></td></tr>
<tr class="memitem:ssl" id="r_ssl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1ssl.html">ssl</a></td></tr>
<tr class="memitem:this_5Fcoro" id="r_this_5Fcoro"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1this__coro.html">this_coro</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:associated_5Fallocator" id="r_associated_5Fallocator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator.html">associated_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits type used to obtain the allocator associated with an object.  <a href="structasio_1_1associated__allocator.html#details">More...</a><br /></td></tr>
<tr class="memitem:associated_5Fexecutor" id="r_associated_5Fexecutor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor.html">associated_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits type used to obtain the executor associated with an object.  <a href="structasio_1_1associated__executor.html#details">More...</a><br /></td></tr>
<tr class="memitem:async_5Fresult" id="r_async_5Fresult"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result.html">async_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface for customising the behaviour of an initiating function.  <a href="classasio_1_1async__result.html#details">More...</a><br /></td></tr>
<tr class="memitem:async_5Fcompletion" id="r_async_5Fcompletion"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__completion.html">async_completion</a></td></tr>
<tr class="memitem:basic_5Fdatagram_5Fsocket" id="r_basic_5Fdatagram_5Fsocket"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__datagram__socket.html">basic_datagram_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides datagram-oriented socket functionality.  <a href="classasio_1_1basic__datagram__socket.html#details">More...</a><br /></td></tr>
<tr class="memitem:basic_5Fio_5Fobject" id="r_basic_5Fio_5Fobject"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__io__object.html">basic_io_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all I/O objects.  <a href="classasio_1_1basic__io__object.html#details">More...</a><br /></td></tr>
<tr class="memitem:basic_5Fraw_5Fsocket" id="r_basic_5Fraw_5Fsocket"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__raw__socket.html">basic_raw_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides raw-oriented socket functionality.  <a href="classasio_1_1basic__raw__socket.html#details">More...</a><br /></td></tr>
<tr class="memitem:basic_5Fseq_5Fpacket_5Fsocket" id="r_basic_5Fseq_5Fpacket_5Fsocket"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__seq__packet__socket.html">basic_seq_packet_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides sequenced packet socket functionality.  <a href="classasio_1_1basic__seq__packet__socket.html#details">More...</a><br /></td></tr>
<tr class="memitem:basic_5Fsignal_5Fset" id="r_basic_5Fsignal_5Fset"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__signal__set.html">basic_signal_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides signal functionality.  <a href="classasio_1_1basic__signal__set.html#details">More...</a><br /></td></tr>
<tr class="memitem:basic_5Fsocket" id="r_basic_5Fsocket"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides socket functionality.  <a href="classasio_1_1basic__socket.html#details">More...</a><br /></td></tr>
<tr class="memitem:basic_5Fsocket_5Facceptor" id="r_basic_5Fsocket_5Facceptor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html">basic_socket_acceptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the ability to accept new connections.  <a href="classasio_1_1basic__socket__acceptor.html#details">More...</a><br /></td></tr>
<tr class="memitem:basic_5Fsocket_5Fiostream" id="r_basic_5Fsocket_5Fiostream"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__iostream.html">basic_socket_iostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iostream interface for a socket.  <a href="classasio_1_1basic__socket__iostream.html#details">More...</a><br /></td></tr>
<tr class="memitem:basic_5Fsocket_5Fstreambuf" id="r_basic_5Fsocket_5Fstreambuf"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__streambuf.html">basic_socket_streambuf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iostream streambuf for a socket.  <a href="classasio_1_1basic__socket__streambuf.html#details">More...</a><br /></td></tr>
<tr class="memitem:basic_5Fstream_5Fsocket" id="r_basic_5Fstream_5Fsocket"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__stream__socket.html">basic_stream_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides stream-oriented socket functionality.  <a href="classasio_1_1basic__stream__socket.html#details">More...</a><br /></td></tr>
<tr class="memitem:basic_5Fstreambuf" id="r_basic_5Fstreambuf"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically resizable buffer class based on std::streambuf.  <a href="classasio_1_1basic__streambuf.html#details">More...</a><br /></td></tr>
<tr class="memitem:basic_5Fstreambuf_5Fref" id="r_basic_5Fstreambuf_5Fref"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapts <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> to the dynamic buffer sequence type requirements.  <a href="classasio_1_1basic__streambuf__ref.html#details">More...</a><br /></td></tr>
<tr class="memitem:basic_5Fwaitable_5Ftimer" id="r_basic_5Fwaitable_5Ftimer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides waitable timer functionality.  <a href="classasio_1_1basic__waitable__timer.html#details">More...</a><br /></td></tr>
<tr class="memitem:executor_5Fbinder" id="r_executor_5Fbinder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1executor__binder.html">executor_binder</a></td></tr>
<tr class="memitem:uses_5Fexecutor_3C_20executor_5Fbinder_3C_20T_2C_20Executor_20_3E_2C_20Executor_20_3E" id="r_uses_5Fexecutor_3C_20executor_5Fbinder_3C_20T_2C_20Executor_20_3E_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1uses__executor_3_01executor__binder_3_01T_00_01Executor_01_4_00_01Executor_01_4.html">uses_executor&lt; executor_binder&lt; T, Executor &gt;, Executor &gt;</a></td></tr>
<tr class="memitem:async_5Fresult_3C_20executor_5Fbinder_3C_20T_2C_20Executor_20_3E_2C_20Signature_20_3E" id="r_async_5Fresult_3C_20executor_5Fbinder_3C_20T_2C_20Executor_20_3E_2C_20Signature_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01executor__binder_3_01T_00_01Executor_01_4_00_01Signature_01_4.html">async_result&lt; executor_binder&lt; T, Executor &gt;, Signature &gt;</a></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20executor_5Fbinder_3C_20T_2C_20Executor_20_3E_2C_20Allocator_20_3E" id="r_associated_5Fallocator_3C_20executor_5Fbinder_3C_20T_2C_20Executor_20_3E_2C_20Allocator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01executor__binder_3_01T_00_01Executor_01_4_00_01Allocator_01_4.html">associated_allocator&lt; executor_binder&lt; T, Executor &gt;, Allocator &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20executor_5Fbinder_3C_20T_2C_20Executor_20_3E_2C_20Executor1_20_3E" id="r_associated_5Fexecutor_3C_20executor_5Fbinder_3C_20T_2C_20Executor_20_3E_2C_20Executor1_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01executor__binder_3_01T_00_01Executor_01_4_00_01Executor1_01_4.html">associated_executor&lt; executor_binder&lt; T, Executor &gt;, Executor1 &gt;</a></td></tr>
<tr class="memitem:mutable_5Fbuffer" id="r_mutable_5Fbuffer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a buffer that can be modified.  <a href="classasio_1_1mutable__buffer.html#details">More...</a><br /></td></tr>
<tr class="memitem:mutable_5Fbuffers_5F1" id="r_mutable_5Fbuffers_5F1"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a></td></tr>
<tr class="memitem:const_5Fbuffer" id="r_const_5Fbuffer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a buffer that cannot be modified.  <a href="classasio_1_1const__buffer.html#details">More...</a><br /></td></tr>
<tr class="memitem:const_5Fbuffers_5F1" id="r_const_5Fbuffers_5F1"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a></td></tr>
<tr class="memitem:null_5Fbuffers" id="r_null_5Fbuffers"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1null__buffers.html">null_buffers</a></td></tr>
<tr class="memitem:dynamic_5Fstring_5Fbuffer" id="r_dynamic_5Fstring_5Fbuffer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1dynamic__string__buffer.html">dynamic_string_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapt a basic_string to the DynamicBuffer requirements.  <a href="classasio_1_1dynamic__string__buffer.html#details">More...</a><br /></td></tr>
<tr class="memitem:dynamic_5Fvector_5Fbuffer" id="r_dynamic_5Fvector_5Fbuffer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1dynamic__vector__buffer.html">dynamic_vector_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapt a vector to the DynamicBuffer requirements.  <a href="classasio_1_1dynamic__vector__buffer.html#details">More...</a><br /></td></tr>
<tr class="memitem:is_5Fmutable_5Fbuffer_5Fsequence" id="r_is_5Fmutable_5Fbuffer_5Fsequence"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a></td></tr>
<tr class="memitem:is_5Fconst_5Fbuffer_5Fsequence" id="r_is_5Fconst_5Fbuffer_5Fsequence"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a></td></tr>
<tr class="memitem:is_5Fdynamic_5Fbuffer_5Fv1" id="r_is_5Fdynamic_5Fbuffer_5Fv1"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a></td></tr>
<tr class="memitem:is_5Fdynamic_5Fbuffer_5Fv2" id="r_is_5Fdynamic_5Fbuffer_5Fv2"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a></td></tr>
<tr class="memitem:is_5Fdynamic_5Fbuffer" id="r_is_5Fdynamic_5Fbuffer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__dynamic__buffer.html">is_dynamic_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to determine whether a type satisfies the DynamicBuffer requirements.  <a href="structasio_1_1is__dynamic__buffer.html#details">More...</a><br /></td></tr>
<tr class="memitem:buffered_5Fread_5Fstream" id="r_buffered_5Fread_5Fstream"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1buffered__read__stream.html">buffered_read_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds buffering to the read-related operations of a stream.  <a href="classasio_1_1buffered__read__stream.html#details">More...</a><br /></td></tr>
<tr class="memitem:buffered_5Fstream" id="r_buffered_5Fstream"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1buffered__stream.html">buffered_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds buffering to the read- and write-related operations of a stream.  <a href="classasio_1_1buffered__stream.html#details">More...</a><br /></td></tr>
<tr class="memitem:buffered_5Fwrite_5Fstream" id="r_buffered_5Fwrite_5Fstream"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1buffered__write__stream.html">buffered_write_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds buffering to the write-related operations of a stream.  <a href="classasio_1_1buffered__write__stream.html#details">More...</a><br /></td></tr>
<tr class="memitem:buffers_5Fiterator" id="r_buffers_5Fiterator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1buffers__iterator.html">buffers_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random access iterator over the bytes in a buffer sequence.  <a href="classasio_1_1buffers__iterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:is_5Fendpoint_5Fsequence" id="r_is_5Fendpoint_5Fsequence"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a></td></tr>
<tr class="memitem:coroutine" id="r_coroutine"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1coroutine.html">coroutine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides support for implementing stackless coroutines.  <a href="classasio_1_1coroutine.html#details">More...</a><br /></td></tr>
<tr class="memitem:detached_5Ft" id="r_detached_5Ft"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1detached__t.html">detached_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classClass.html">Class</a> used to specify that an asynchronous operation is detached.  <a href="classasio_1_1detached__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20detail_3A_3Abinder1_3C_20Handler_2C_20Arg1_20_3E_2C_20Allocator_20_3E" id="r_associated_5Fallocator_3C_20detail_3A_3Abinder1_3C_20Handler_2C_20Arg1_20_3E_2C_20Allocator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01detail_1_1binder1_3_01Handler_00_01Arg1_01_4_00_01Allocator_01_4.html">associated_allocator&lt; detail::binder1&lt; Handler, Arg1 &gt;, Allocator &gt;</a></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20detail_3A_3Abinder2_3C_20Handler_2C_20Arg1_2C_20Arg2_20_3E_2C_20Allocator_20_3E" id="r_associated_5Fallocator_3C_20detail_3A_3Abinder2_3C_20Handler_2C_20Arg1_2C_20Arg2_20_3E_2C_20Allocator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01detail_1_1binder2_3_01Handler_00_01Arg1_00_01Arg2_01_4_00_01Allocator_01_4.html">associated_allocator&lt; detail::binder2&lt; Handler, Arg1, Arg2 &gt;, Allocator &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20detail_3A_3Abinder1_3C_20Handler_2C_20Arg1_20_3E_2C_20Executor_20_3E" id="r_associated_5Fexecutor_3C_20detail_3A_3Abinder1_3C_20Handler_2C_20Arg1_20_3E_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01detail_1_1binder1_3_01Handler_00_01Arg1_01_4_00_01Executor_01_4.html">associated_executor&lt; detail::binder1&lt; Handler, Arg1 &gt;, Executor &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20detail_3A_3Abinder2_3C_20Handler_2C_20Arg1_2C_20Arg2_20_3E_2C_20Executor_20_3E" id="r_associated_5Fexecutor_3C_20detail_3A_3Abinder2_3C_20Handler_2C_20Arg1_2C_20Arg2_20_3E_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01detail_1_1binder2_3_01Handler_00_01Arg1_00_01Arg2_01_4_00_01Executor_01_4.html">associated_executor&lt; detail::binder2&lt; Handler, Arg1, Arg2 &gt;, Executor &gt;</a></td></tr>
<tr class="memitem:nullptr_5Ft" id="r_nullptr_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1nullptr__t.html">nullptr_t</a></td></tr>
<tr class="memitem:allocator_5Farg_5Ft" id="r_allocator_5Farg_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1allocator__arg__t.html">allocator_arg_t</a></td></tr>
<tr class="memitem:enable_5Fif" id="r_enable_5Fif"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1enable__if.html">enable_if</a></td></tr>
<tr class="memitem:error_5Fcategory" id="r_error_5Fcategory"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1error__category.html">error_category</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all error categories.  <a href="classasio_1_1error__category.html#details">More...</a><br /></td></tr>
<tr class="memitem:error_5Fcode" id="r_error_5Fcode"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1error__code.html">error_code</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classClass.html">Class</a> to represent an error code value.  <a href="classasio_1_1error__code.html#details">More...</a><br /></td></tr>
<tr class="memitem:execution_5Fcontext" id="r_execution_5Fcontext"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1execution__context.html">execution_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A context for function object execution.  <a href="classasio_1_1execution__context.html#details">More...</a><br /></td></tr>
<tr class="memitem:service_5Falready_5Fexists" id="r_service_5Falready_5Fexists"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1service__already__exists.html">service_already_exists</a></td></tr>
<tr class="memitem:invalid_5Fservice_5Fowner" id="r_invalid_5Fservice_5Fowner"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1invalid__service__owner.html">invalid_service_owner</a></td></tr>
<tr class="memitem:bad_5Fexecutor" id="r_bad_5Fexecutor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1bad__executor.html">bad_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when trying to access an empty polymorphic executor.  <a href="classasio_1_1bad__executor.html#details">More...</a><br /></td></tr>
<tr class="memitem:executor" id="r_executor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1executor.html">executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic wrapper for executors.  <a href="classasio_1_1executor.html#details">More...</a><br /></td></tr>
<tr class="memitem:executor_5Fwork_5Fguard" id="r_executor_5Fwork_5Fguard"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20detail_3A_3Abuffered_5Ffill_5Fhandler_3C_20ReadHandler_20_3E_2C_20Allocator_20_3E" id="r_associated_5Fallocator_3C_20detail_3A_3Abuffered_5Ffill_5Fhandler_3C_20ReadHandler_20_3E_2C_20Allocator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01detail_1_1buffered__fill__handler_3_01ReadHandler_01_4_00_01Allocator_01_4.html">associated_allocator&lt; detail::buffered_fill_handler&lt; ReadHandler &gt;, Allocator &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20detail_3A_3Abuffered_5Ffill_5Fhandler_3C_20ReadHandler_20_3E_2C_20Executor_20_3E" id="r_associated_5Fexecutor_3C_20detail_3A_3Abuffered_5Ffill_5Fhandler_3C_20ReadHandler_20_3E_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01detail_1_1buffered__fill__handler_3_01ReadHandler_01_4_00_01Executor_01_4.html">associated_executor&lt; detail::buffered_fill_handler&lt; ReadHandler &gt;, Executor &gt;</a></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20detail_3A_3Abuffered_5Fread_5Fsome_5Fhandler_3C_20MutableBufferSequence_2C_20ReadHandler_20_3E_2C_20Allocator_20_3E" id="r_associated_5Fallocator_3C_20detail_3A_3Abuffered_5Fread_5Fsome_5Fhandler_3C_20MutableBufferSequence_2C_20ReadHandler_20_3E_2C_20Allocator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01detail_1_1buffered__read__some__handler_3_01MutableBuffe6ba0d3cea90957e104c71c4fe0196e3c.html">associated_allocator&lt; detail::buffered_read_some_handler&lt; MutableBufferSequence, ReadHandler &gt;, Allocator &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20detail_3A_3Abuffered_5Fread_5Fsome_5Fhandler_3C_20MutableBufferSequence_2C_20ReadHandler_20_3E_2C_20Executor_20_3E" id="r_associated_5Fexecutor_3C_20detail_3A_3Abuffered_5Fread_5Fsome_5Fhandler_3C_20MutableBufferSequence_2C_20ReadHandler_20_3E_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01detail_1_1buffered__read__some__handler_3_01MutableBuffer4307fd5299f388129719cd15d6bfdcfb.html">associated_executor&lt; detail::buffered_read_some_handler&lt; MutableBufferSequence, ReadHandler &gt;, Executor &gt;</a></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20detail_3A_3Abuffered_5Fflush_5Fhandler_3C_20WriteHandler_20_3E_2C_20Allocator_20_3E" id="r_associated_5Fallocator_3C_20detail_3A_3Abuffered_5Fflush_5Fhandler_3C_20WriteHandler_20_3E_2C_20Allocator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01detail_1_1buffered__flush__handler_3_01WriteHandler_01_4_00_01Allocator_01_4.html">associated_allocator&lt; detail::buffered_flush_handler&lt; WriteHandler &gt;, Allocator &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20detail_3A_3Abuffered_5Fflush_5Fhandler_3C_20WriteHandler_20_3E_2C_20Executor_20_3E" id="r_associated_5Fexecutor_3C_20detail_3A_3Abuffered_5Fflush_5Fhandler_3C_20WriteHandler_20_3E_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01detail_1_1buffered__flush__handler_3_01WriteHandler_01_4_00_01Executor_01_4.html">associated_executor&lt; detail::buffered_flush_handler&lt; WriteHandler &gt;, Executor &gt;</a></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20detail_3A_3Abuffered_5Fwrite_5Fsome_5Fhandler_3C_20ConstBufferSequence_2C_20WriteHandler_20_3E_2C_20Allocator_20_3E" id="r_associated_5Fallocator_3C_20detail_3A_3Abuffered_5Fwrite_5Fsome_5Fhandler_3C_20ConstBufferSequence_2C_20WriteHandler_20_3E_2C_20Allocator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01detail_1_1buffered__write__some__handler_3_01ConstBuffer13dad3745c02becc768de7e109001f95.html">associated_allocator&lt; detail::buffered_write_some_handler&lt; ConstBufferSequence, WriteHandler &gt;, Allocator &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20detail_3A_3Abuffered_5Fwrite_5Fsome_5Fhandler_3C_20ConstBufferSequence_2C_20WriteHandler_20_3E_2C_20Executor_20_3E" id="r_associated_5Fexecutor_3C_20detail_3A_3Abuffered_5Fwrite_5Fsome_5Fhandler_3C_20ConstBufferSequence_2C_20WriteHandler_20_3E_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01detail_1_1buffered__write__some__handler_3_01ConstBufferSb63b83f5ab33373820a941a4a82aa060.html">associated_executor&lt; detail::buffered_write_some_handler&lt; ConstBufferSequence, WriteHandler &gt;, Executor &gt;</a></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20detail_3A_3Arange_5Fconnect_5Fop_3C_20Protocol_2C_20Executor_2C_20EndpointSequence_2C_20ConnectCondition_2C_20RangeConnectHandler_20_3E_2C_20Allocator_20_3E" id="r_associated_5Fallocator_3C_20detail_3A_3Arange_5Fconnect_5Fop_3C_20Protocol_2C_20Executor_2C_20EndpointSequence_2C_20ConnectCondition_2C_20RangeConnectHandler_20_3E_2C_20Allocator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01detail_1_1range__connect__op_3_01Protocol_00_01Executor_a904cb524d431d528b96380ec1f8a2bb.html">associated_allocator&lt; detail::range_connect_op&lt; Protocol, Executor, EndpointSequence, ConnectCondition, RangeConnectHandler &gt;, Allocator &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20detail_3A_3Arange_5Fconnect_5Fop_3C_20Protocol_2C_20Executor_2C_20EndpointSequence_2C_20ConnectCondition_2C_20RangeConnectHandler_20_3E_2C_20Executor1_20_3E" id="r_associated_5Fexecutor_3C_20detail_3A_3Arange_5Fconnect_5Fop_3C_20Protocol_2C_20Executor_2C_20EndpointSequence_2C_20ConnectCondition_2C_20RangeConnectHandler_20_3E_2C_20Executor1_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01detail_1_1range__connect__op_3_01Protocol_00_01Executor_0c3b479cb2d42a0371e29ecdd026900b0.html">associated_executor&lt; detail::range_connect_op&lt; Protocol, Executor, EndpointSequence, ConnectCondition, RangeConnectHandler &gt;, Executor1 &gt;</a></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20detail_3A_3Aiterator_5Fconnect_5Fop_3C_20Protocol_2C_20Executor_2C_20Iterator_2C_20ConnectCondition_2C_20IteratorConnectHandler_20_3E_2C_20Allocator_20_3E" id="r_associated_5Fallocator_3C_20detail_3A_3Aiterator_5Fconnect_5Fop_3C_20Protocol_2C_20Executor_2C_20Iterator_2C_20ConnectCondition_2C_20IteratorConnectHandler_20_3E_2C_20Allocator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01detail_1_1iterator__connect__op_3_01Protocol_00_01Execut3a7cd07a0102c016832ee1cd31f1ff3c.html">associated_allocator&lt; detail::iterator_connect_op&lt; Protocol, Executor, Iterator, ConnectCondition, IteratorConnectHandler &gt;, Allocator &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20detail_3A_3Aiterator_5Fconnect_5Fop_3C_20Protocol_2C_20Executor_2C_20Iterator_2C_20ConnectCondition_2C_20IteratorConnectHandler_20_3E_2C_20Executor1_20_3E" id="r_associated_5Fexecutor_3C_20detail_3A_3Aiterator_5Fconnect_5Fop_3C_20Protocol_2C_20Executor_2C_20Iterator_2C_20ConnectCondition_2C_20IteratorConnectHandler_20_3E_2C_20Executor1_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01detail_1_1iterator__connect__op_3_01Protocol_00_01Executoc61dc05f7e994d76bba94a0558eb7197.html">associated_executor&lt; detail::iterator_connect_op&lt; Protocol, Executor, Iterator, ConnectCondition, IteratorConnectHandler &gt;, Executor1 &gt;</a></td></tr>
<tr class="memitem:async_5Fresult_3C_20detached_5Ft_2C_20Signature_20_3E" id="r_async_5Fresult_3C_20detached_5Ft_2C_20Signature_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01detached__t_00_01Signature_01_4.html">async_result&lt; detached_t, Signature &gt;</a></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20detail_3A_3Aread_5Fop_3C_20AsyncReadStream_2C_20MutableBufferSequence_2C_20MutableBufferIterator_2C_20CompletionCondition_2C_20ReadHandler_20_3E_2C_20Allocator_20_3E" id="r_associated_5Fallocator_3C_20detail_3A_3Aread_5Fop_3C_20AsyncReadStream_2C_20MutableBufferSequence_2C_20MutableBufferIterator_2C_20CompletionCondition_2C_20ReadHandler_20_3E_2C_20Allocator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01detail_1_1read__op_3_01AsyncReadStream_00_01MutableBuffe781aab531ddbe70b9bb3a0bf07bb7b8b.html">associated_allocator&lt; detail::read_op&lt; AsyncReadStream, MutableBufferSequence, MutableBufferIterator, CompletionCondition, ReadHandler &gt;, Allocator &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20detail_3A_3Aread_5Fop_3C_20AsyncReadStream_2C_20MutableBufferSequence_2C_20MutableBufferIterator_2C_20CompletionCondition_2C_20ReadHandler_20_3E_2C_20Executor_20_3E" id="r_associated_5Fexecutor_3C_20detail_3A_3Aread_5Fop_3C_20AsyncReadStream_2C_20MutableBufferSequence_2C_20MutableBufferIterator_2C_20CompletionCondition_2C_20ReadHandler_20_3E_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01detail_1_1read__op_3_01AsyncReadStream_00_01MutableBuffer5a9f61a92d1cd1d73fe7ec92393a575a.html">associated_executor&lt; detail::read_op&lt; AsyncReadStream, MutableBufferSequence, MutableBufferIterator, CompletionCondition, ReadHandler &gt;, Executor &gt;</a></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20detail_3A_3Aread_5Fdynbuf_5Fv1_5Fop_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv1_2C_20CompletionCondition_2C_20ReadHandler_20_3E_2C_20Allocator_20_3E" id="r_associated_5Fallocator_3C_20detail_3A_3Aread_5Fdynbuf_5Fv1_5Fop_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv1_2C_20CompletionCondition_2C_20ReadHandler_20_3E_2C_20Allocator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01detail_1_1read__dynbuf__v1__op_3_01AsyncReadStream_00_01cf97b78a5fa49598bf0a3d39dcef9cb4.html">associated_allocator&lt; detail::read_dynbuf_v1_op&lt; AsyncReadStream, DynamicBuffer_v1, CompletionCondition, ReadHandler &gt;, Allocator &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20detail_3A_3Aread_5Fdynbuf_5Fv1_5Fop_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv1_2C_20CompletionCondition_2C_20ReadHandler_20_3E_2C_20Executor_20_3E" id="r_associated_5Fexecutor_3C_20detail_3A_3Aread_5Fdynbuf_5Fv1_5Fop_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv1_2C_20CompletionCondition_2C_20ReadHandler_20_3E_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01detail_1_1read__dynbuf__v1__op_3_01AsyncReadStream_00_01D9e030d72f1b8852b24e9cdbbdbd359ad.html">associated_executor&lt; detail::read_dynbuf_v1_op&lt; AsyncReadStream, DynamicBuffer_v1, CompletionCondition, ReadHandler &gt;, Executor &gt;</a></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20detail_3A_3Aread_5Fdynbuf_5Fv2_5Fop_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv2_2C_20CompletionCondition_2C_20ReadHandler_20_3E_2C_20Allocator_20_3E" id="r_associated_5Fallocator_3C_20detail_3A_3Aread_5Fdynbuf_5Fv2_5Fop_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv2_2C_20CompletionCondition_2C_20ReadHandler_20_3E_2C_20Allocator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01detail_1_1read__dynbuf__v2__op_3_01AsyncReadStream_00_015b774dbc0cd2fc3afc3b50ccd41c19ce.html">associated_allocator&lt; detail::read_dynbuf_v2_op&lt; AsyncReadStream, DynamicBuffer_v2, CompletionCondition, ReadHandler &gt;, Allocator &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20detail_3A_3Aread_5Fdynbuf_5Fv2_5Fop_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv2_2C_20CompletionCondition_2C_20ReadHandler_20_3E_2C_20Executor_20_3E" id="r_associated_5Fexecutor_3C_20detail_3A_3Aread_5Fdynbuf_5Fv2_5Fop_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv2_2C_20CompletionCondition_2C_20ReadHandler_20_3E_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01detail_1_1read__dynbuf__v2__op_3_01AsyncReadStream_00_01Dff98a9e34dd9bdc960d5063c3c5eca41.html">associated_executor&lt; detail::read_dynbuf_v2_op&lt; AsyncReadStream, DynamicBuffer_v2, CompletionCondition, ReadHandler &gt;, Executor &gt;</a></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20detail_3A_3Aread_5Fat_5Fop_3C_20AsyncRandomAccessReadDevice_2C_20MutableBufferSequence_2C_20MutableBufferIterator_2C_20CompletionCondition_2C_20ReadHandler_20_3E_2C_20Allocator_20_3E" id="r_associated_5Fallocator_3C_20detail_3A_3Aread_5Fat_5Fop_3C_20AsyncRandomAccessReadDevice_2C_20MutableBufferSequence_2C_20MutableBufferIterator_2C_20CompletionCondition_2C_20ReadHandler_20_3E_2C_20Allocator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01detail_1_1read__at__op_3_01AsyncRandomAccessReadDevice_015df343974f2aaab46ea7f7eb2c97189.html">associated_allocator&lt; detail::read_at_op&lt; AsyncRandomAccessReadDevice, MutableBufferSequence, MutableBufferIterator, CompletionCondition, ReadHandler &gt;, Allocator &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20detail_3A_3Aread_5Fat_5Fop_3C_20AsyncRandomAccessReadDevice_2C_20MutableBufferSequence_2C_20MutableBufferIterator_2C_20CompletionCondition_2C_20ReadHandler_20_3E_2C_20Executor_20_3E" id="r_associated_5Fexecutor_3C_20detail_3A_3Aread_5Fat_5Fop_3C_20AsyncRandomAccessReadDevice_2C_20MutableBufferSequence_2C_20MutableBufferIterator_2C_20CompletionCondition_2C_20ReadHandler_20_3E_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01detail_1_1read__at__op_3_01AsyncRandomAccessReadDevice_002e7fdcdf0be8839667dde1816ddb3014.html">associated_executor&lt; detail::read_at_op&lt; AsyncRandomAccessReadDevice, MutableBufferSequence, MutableBufferIterator, CompletionCondition, ReadHandler &gt;, Executor &gt;</a></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20detail_3A_3Aread_5Fat_5Fstreambuf_5Fop_3C_20AsyncRandomAccessReadDevice_2C_20Allocator_2C_20CompletionCondition_2C_20ReadHandler_20_3E_2C_20Allocator1_20_3E" id="r_associated_5Fallocator_3C_20detail_3A_3Aread_5Fat_5Fstreambuf_5Fop_3C_20AsyncRandomAccessReadDevice_2C_20Allocator_2C_20CompletionCondition_2C_20ReadHandler_20_3E_2C_20Allocator1_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01detail_1_1read__at__streambuf__op_3_01AsyncRandomAccessR2259bd26a0ea378a04695df3d5e33d94.html">associated_allocator&lt; detail::read_at_streambuf_op&lt; AsyncRandomAccessReadDevice, Allocator, CompletionCondition, ReadHandler &gt;, Allocator1 &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20detail_3A_3Aread_5Fat_5Fstreambuf_5Fop_3C_20AsyncRandomAccessReadDevice_2C_20Executor_2C_20CompletionCondition_2C_20ReadHandler_20_3E_2C_20Executor1_20_3E" id="r_associated_5Fexecutor_3C_20detail_3A_3Aread_5Fat_5Fstreambuf_5Fop_3C_20AsyncRandomAccessReadDevice_2C_20Executor_2C_20CompletionCondition_2C_20ReadHandler_20_3E_2C_20Executor1_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01detail_1_1read__at__streambuf__op_3_01AsyncRandomAccessRebb64de6d3a5852e6ee74ad08eff3a713.html">associated_executor&lt; detail::read_at_streambuf_op&lt; AsyncRandomAccessReadDevice, Executor, CompletionCondition, ReadHandler &gt;, Executor1 &gt;</a></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20detail_3A_3Aread_5Funtil_5Fdelim_5Fop_5Fv1_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv1_2C_20ReadHandler_20_3E_2C_20Allocator_20_3E" id="r_associated_5Fallocator_3C_20detail_3A_3Aread_5Funtil_5Fdelim_5Fop_5Fv1_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv1_2C_20ReadHandler_20_3E_2C_20Allocator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01detail_1_1read__until__delim__op__v1_3_01AsyncReadStream7d7826bfada6e20a1035ea7459189c80.html">associated_allocator&lt; detail::read_until_delim_op_v1&lt; AsyncReadStream, DynamicBuffer_v1, ReadHandler &gt;, Allocator &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20detail_3A_3Aread_5Funtil_5Fdelim_5Fop_5Fv1_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv1_2C_20ReadHandler_20_3E_2C_20Executor_20_3E" id="r_associated_5Fexecutor_3C_20detail_3A_3Aread_5Funtil_5Fdelim_5Fop_5Fv1_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv1_2C_20ReadHandler_20_3E_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01detail_1_1read__until__delim__op__v1_3_01AsyncReadStream_28839cac5463a0ee810114e3b265fb8e.html">associated_executor&lt; detail::read_until_delim_op_v1&lt; AsyncReadStream, DynamicBuffer_v1, ReadHandler &gt;, Executor &gt;</a></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20detail_3A_3Aread_5Funtil_5Fdelim_5Fstring_5Fop_5Fv1_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv1_2C_20ReadHandler_20_3E_2C_20Allocator_20_3E" id="r_associated_5Fallocator_3C_20detail_3A_3Aread_5Funtil_5Fdelim_5Fstring_5Fop_5Fv1_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv1_2C_20ReadHandler_20_3E_2C_20Allocator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01detail_1_1read__until__delim__string__op__v1_3_01AsyncReef8971ac48b6cd75652972d1f20cafdf.html">associated_allocator&lt; detail::read_until_delim_string_op_v1&lt; AsyncReadStream, DynamicBuffer_v1, ReadHandler &gt;, Allocator &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20detail_3A_3Aread_5Funtil_5Fdelim_5Fstring_5Fop_5Fv1_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv1_2C_20ReadHandler_20_3E_2C_20Executor_20_3E" id="r_associated_5Fexecutor_3C_20detail_3A_3Aread_5Funtil_5Fdelim_5Fstring_5Fop_5Fv1_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv1_2C_20ReadHandler_20_3E_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01detail_1_1read__until__delim__string__op__v1_3_01AsyncReaf83d715bab383c0aa40993472fc738cf.html">associated_executor&lt; detail::read_until_delim_string_op_v1&lt; AsyncReadStream, DynamicBuffer_v1, ReadHandler &gt;, Executor &gt;</a></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20detail_3A_3Aread_5Funtil_5Fmatch_5Fop_5Fv1_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv1_2C_20MatchCondition_2C_20ReadHandler_20_3E_2C_20Allocator_20_3E" id="r_associated_5Fallocator_3C_20detail_3A_3Aread_5Funtil_5Fmatch_5Fop_5Fv1_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv1_2C_20MatchCondition_2C_20ReadHandler_20_3E_2C_20Allocator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01detail_1_1read__until__match__op__v1_3_01AsyncReadStream8941257687150b99794bdb83a0f57e77.html">associated_allocator&lt; detail::read_until_match_op_v1&lt; AsyncReadStream, DynamicBuffer_v1, MatchCondition, ReadHandler &gt;, Allocator &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20detail_3A_3Aread_5Funtil_5Fmatch_5Fop_5Fv1_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv1_2C_20MatchCondition_2C_20ReadHandler_20_3E_2C_20Executor_20_3E" id="r_associated_5Fexecutor_3C_20detail_3A_3Aread_5Funtil_5Fmatch_5Fop_5Fv1_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv1_2C_20MatchCondition_2C_20ReadHandler_20_3E_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01detail_1_1read__until__match__op__v1_3_01AsyncReadStream_a14410ce51abc813fa93e43a0afd3364.html">associated_executor&lt; detail::read_until_match_op_v1&lt; AsyncReadStream, DynamicBuffer_v1, MatchCondition, ReadHandler &gt;, Executor &gt;</a></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20detail_3A_3Aread_5Funtil_5Fdelim_5Fop_5Fv2_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv2_2C_20ReadHandler_20_3E_2C_20Allocator_20_3E" id="r_associated_5Fallocator_3C_20detail_3A_3Aread_5Funtil_5Fdelim_5Fop_5Fv2_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv2_2C_20ReadHandler_20_3E_2C_20Allocator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01detail_1_1read__until__delim__op__v2_3_01AsyncReadStreamf4481f34e2d92d3af755c63f5976f1ac.html">associated_allocator&lt; detail::read_until_delim_op_v2&lt; AsyncReadStream, DynamicBuffer_v2, ReadHandler &gt;, Allocator &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20detail_3A_3Aread_5Funtil_5Fdelim_5Fop_5Fv2_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv2_2C_20ReadHandler_20_3E_2C_20Executor_20_3E" id="r_associated_5Fexecutor_3C_20detail_3A_3Aread_5Funtil_5Fdelim_5Fop_5Fv2_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv2_2C_20ReadHandler_20_3E_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01detail_1_1read__until__delim__op__v2_3_01AsyncReadStream_8ddc0fb0cb369237fdf79207122e6f12.html">associated_executor&lt; detail::read_until_delim_op_v2&lt; AsyncReadStream, DynamicBuffer_v2, ReadHandler &gt;, Executor &gt;</a></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20detail_3A_3Aread_5Funtil_5Fdelim_5Fstring_5Fop_5Fv2_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv2_2C_20ReadHandler_20_3E_2C_20Allocator_20_3E" id="r_associated_5Fallocator_3C_20detail_3A_3Aread_5Funtil_5Fdelim_5Fstring_5Fop_5Fv2_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv2_2C_20ReadHandler_20_3E_2C_20Allocator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01detail_1_1read__until__delim__string__op__v2_3_01AsyncRe83787e1b7ac48cec69cc062af674aca6.html">associated_allocator&lt; detail::read_until_delim_string_op_v2&lt; AsyncReadStream, DynamicBuffer_v2, ReadHandler &gt;, Allocator &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20detail_3A_3Aread_5Funtil_5Fdelim_5Fstring_5Fop_5Fv2_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv2_2C_20ReadHandler_20_3E_2C_20Executor_20_3E" id="r_associated_5Fexecutor_3C_20detail_3A_3Aread_5Funtil_5Fdelim_5Fstring_5Fop_5Fv2_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv2_2C_20ReadHandler_20_3E_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01detail_1_1read__until__delim__string__op__v2_3_01AsyncRea56c2b2c7023075686f44f8331c05e934.html">associated_executor&lt; detail::read_until_delim_string_op_v2&lt; AsyncReadStream, DynamicBuffer_v2, ReadHandler &gt;, Executor &gt;</a></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20detail_3A_3Aread_5Funtil_5Fmatch_5Fop_5Fv2_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv2_2C_20MatchCondition_2C_20ReadHandler_20_3E_2C_20Allocator_20_3E" id="r_associated_5Fallocator_3C_20detail_3A_3Aread_5Funtil_5Fmatch_5Fop_5Fv2_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv2_2C_20MatchCondition_2C_20ReadHandler_20_3E_2C_20Allocator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01detail_1_1read__until__match__op__v2_3_01AsyncReadStream66b3314c92c8a7b28531f6601fbc57cd.html">associated_allocator&lt; detail::read_until_match_op_v2&lt; AsyncReadStream, DynamicBuffer_v2, MatchCondition, ReadHandler &gt;, Allocator &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20detail_3A_3Aread_5Funtil_5Fmatch_5Fop_5Fv2_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv2_2C_20MatchCondition_2C_20ReadHandler_20_3E_2C_20Executor_20_3E" id="r_associated_5Fexecutor_3C_20detail_3A_3Aread_5Funtil_5Fmatch_5Fop_5Fv2_3C_20AsyncReadStream_2C_20DynamicBuffer_5Fv2_2C_20MatchCondition_2C_20ReadHandler_20_3E_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01detail_1_1read__until__match__op__v2_3_01AsyncReadStream_f191a5b906e736519383cca156080663.html">associated_executor&lt; detail::read_until_match_op_v2&lt; AsyncReadStream, DynamicBuffer_v2, MatchCondition, ReadHandler &gt;, Executor &gt;</a></td></tr>
<tr class="memitem:async_5Fresult_3C_20redirect_5Ferror_5Ft_3C_20CompletionToken_20_3E_2C_20Signature_20_3E" id="r_async_5Fresult_3C_20redirect_5Ferror_5Ft_3C_20CompletionToken_20_3E_2C_20Signature_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__result_3_01redirect__error__t_3_01CompletionToken_01_4_00_01Signature_01_4.html">async_result&lt; redirect_error_t&lt; CompletionToken &gt;, Signature &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20detail_3A_3Aredirect_5Ferror_5Fhandler_3C_20Handler_20_3E_2C_20Executor_20_3E" id="r_associated_5Fexecutor_3C_20detail_3A_3Aredirect_5Ferror_5Fhandler_3C_20Handler_20_3E_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01detail_1_1redirect__error__handler_3_01Handler_01_4_00_01Executor_01_4.html">associated_executor&lt; detail::redirect_error_handler&lt; Handler &gt;, Executor &gt;</a></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20detail_3A_3Aredirect_5Ferror_5Fhandler_3C_20Handler_20_3E_2C_20Allocator_20_3E" id="r_associated_5Fallocator_3C_20detail_3A_3Aredirect_5Ferror_5Fhandler_3C_20Handler_20_3E_2C_20Allocator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01detail_1_1redirect__error__handler_3_01Handler_01_4_00_01Allocator_01_4.html">associated_allocator&lt; detail::redirect_error_handler&lt; Handler &gt;, Allocator &gt;</a></td></tr>
<tr class="memitem:async_5Fresult_3C_20basic_5Fyield_5Fcontext_3C_20Handler_20_3E_2C_20ReturnType_28Arg1_29_3E" id="r_async_5Fresult_3C_20basic_5Fyield_5Fcontext_3C_20Handler_20_3E_2C_20ReturnType_28Arg1_29_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01basic__yield__context_3_01Handler_01_4_00_01ReturnType_07Arg1_08_4.html">async_result&lt; basic_yield_context&lt; Handler &gt;, ReturnType(Arg1)&gt;</a></td></tr>
<tr class="memitem:async_5Fresult_3C_20basic_5Fyield_5Fcontext_3C_20Handler_20_3E_2C_20ReturnType_28asio_3A_3Aerror_5Fcode_29_3E" id="r_async_5Fresult_3C_20basic_5Fyield_5Fcontext_3C_20Handler_20_3E_2C_20ReturnType_28asio_3A_3Aerror_5Fcode_29_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01basic__yield__context_3_01Handler_01_4_00_01ReturnType_07asio_1_1error__code_08_4.html">async_result&lt; basic_yield_context&lt; Handler &gt;, ReturnType(asio::error_code)&gt;</a></td></tr>
<tr class="memitem:async_5Fresult_3C_20basic_5Fyield_5Fcontext_3C_20Handler_20_3E_2C_20ReturnType_28asio_3A_3Aerror_5Fcode_2C_20Arg2_29_3E" id="r_async_5Fresult_3C_20basic_5Fyield_5Fcontext_3C_20Handler_20_3E_2C_20ReturnType_28asio_3A_3Aerror_5Fcode_2C_20Arg2_29_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01basic__yield__context_3_01Handler_01_4_00_01ReturnType_07asio_1_1error__code_00_01Arg2_08_4.html">async_result&lt; basic_yield_context&lt; Handler &gt;, ReturnType(asio::error_code, Arg2)&gt;</a></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20detail_3A_3Acoro_5Fhandler_3C_20Handler_2C_20T_20_3E_2C_20Allocator_20_3E" id="r_associated_5Fallocator_3C_20detail_3A_3Acoro_5Fhandler_3C_20Handler_2C_20T_20_3E_2C_20Allocator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01detail_1_1coro__handler_3_01Handler_00_01T_01_4_00_01Allocator_01_4.html">associated_allocator&lt; detail::coro_handler&lt; Handler, T &gt;, Allocator &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20detail_3A_3Acoro_5Fhandler_3C_20Handler_2C_20T_20_3E_2C_20Executor_20_3E" id="r_associated_5Fexecutor_3C_20detail_3A_3Acoro_5Fhandler_3C_20Handler_2C_20T_20_3E_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01detail_1_1coro__handler_3_01Handler_00_01T_01_4_00_01Executor_01_4.html">associated_executor&lt; detail::coro_handler&lt; Handler, T &gt;, Executor &gt;</a></td></tr>
<tr class="memitem:async_5Fresult_3C_20use_5Fawaitable_5Ft_3C_20Executor_20_3E_2C_20R_28Args_2E_2E_2E_29_3E" id="r_async_5Fresult_3C_20use_5Fawaitable_5Ft_3C_20Executor_20_3E_2C_20R_28Args_2E_2E_2E_29_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01use__awaitable__t_3_01Executor_01_4_00_01R_07Args_8_8_8_08_4.html">async_result&lt; use_awaitable_t&lt; Executor &gt;, R(Args...)&gt;</a></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20detail_3A_3Awrite_5Fop_3C_20AsyncWriteStream_2C_20ConstBufferSequence_2C_20ConstBufferIterator_2C_20CompletionCondition_2C_20WriteHandler_20_3E_2C_20Allocator_20_3E" id="r_associated_5Fallocator_3C_20detail_3A_3Awrite_5Fop_3C_20AsyncWriteStream_2C_20ConstBufferSequence_2C_20ConstBufferIterator_2C_20CompletionCondition_2C_20WriteHandler_20_3E_2C_20Allocator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01detail_1_1write__op_3_01AsyncWriteStream_00_01ConstBuffe32ba1f5e4f668b65128bc98c54b7092c.html">associated_allocator&lt; detail::write_op&lt; AsyncWriteStream, ConstBufferSequence, ConstBufferIterator, CompletionCondition, WriteHandler &gt;, Allocator &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20detail_3A_3Awrite_5Fop_3C_20AsyncWriteStream_2C_20ConstBufferSequence_2C_20ConstBufferIterator_2C_20CompletionCondition_2C_20WriteHandler_20_3E_2C_20Executor_20_3E" id="r_associated_5Fexecutor_3C_20detail_3A_3Awrite_5Fop_3C_20AsyncWriteStream_2C_20ConstBufferSequence_2C_20ConstBufferIterator_2C_20CompletionCondition_2C_20WriteHandler_20_3E_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01detail_1_1write__op_3_01AsyncWriteStream_00_01ConstBuffer181c343d928be32e36e52b32e5e35d2b.html">associated_executor&lt; detail::write_op&lt; AsyncWriteStream, ConstBufferSequence, ConstBufferIterator, CompletionCondition, WriteHandler &gt;, Executor &gt;</a></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20detail_3A_3Awrite_5Fdynbuf_5Fv1_5Fop_3C_20AsyncWriteStream_2C_20DynamicBuffer_5Fv1_2C_20CompletionCondition_2C_20WriteHandler_20_3E_2C_20Allocator_20_3E" id="r_associated_5Fallocator_3C_20detail_3A_3Awrite_5Fdynbuf_5Fv1_5Fop_3C_20AsyncWriteStream_2C_20DynamicBuffer_5Fv1_2C_20CompletionCondition_2C_20WriteHandler_20_3E_2C_20Allocator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01detail_1_1write__dynbuf__v1__op_3_01AsyncWriteStream_00_7c63715ba0cdf08cace5106c445d016c.html">associated_allocator&lt; detail::write_dynbuf_v1_op&lt; AsyncWriteStream, DynamicBuffer_v1, CompletionCondition, WriteHandler &gt;, Allocator &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20detail_3A_3Awrite_5Fdynbuf_5Fv1_5Fop_3C_20AsyncWriteStream_2C_20DynamicBuffer_5Fv1_2C_20CompletionCondition_2C_20WriteHandler_20_3E_2C_20Executor_20_3E" id="r_associated_5Fexecutor_3C_20detail_3A_3Awrite_5Fdynbuf_5Fv1_5Fop_3C_20AsyncWriteStream_2C_20DynamicBuffer_5Fv1_2C_20CompletionCondition_2C_20WriteHandler_20_3E_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01detail_1_1write__dynbuf__v1__op_3_01AsyncWriteStream_00_0fb626afd2a71222d2c3e264d39c6cabf.html">associated_executor&lt; detail::write_dynbuf_v1_op&lt; AsyncWriteStream, DynamicBuffer_v1, CompletionCondition, WriteHandler &gt;, Executor &gt;</a></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20detail_3A_3Awrite_5Fdynbuf_5Fv2_5Fop_3C_20AsyncWriteStream_2C_20DynamicBuffer_5Fv2_2C_20CompletionCondition_2C_20WriteHandler_20_3E_2C_20Allocator_20_3E" id="r_associated_5Fallocator_3C_20detail_3A_3Awrite_5Fdynbuf_5Fv2_5Fop_3C_20AsyncWriteStream_2C_20DynamicBuffer_5Fv2_2C_20CompletionCondition_2C_20WriteHandler_20_3E_2C_20Allocator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01detail_1_1write__dynbuf__v2__op_3_01AsyncWriteStream_00_3db2425be3163b61cbf4328b383521c1.html">associated_allocator&lt; detail::write_dynbuf_v2_op&lt; AsyncWriteStream, DynamicBuffer_v2, CompletionCondition, WriteHandler &gt;, Allocator &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20detail_3A_3Awrite_5Fdynbuf_5Fv2_5Fop_3C_20AsyncWriteStream_2C_20DynamicBuffer_5Fv2_2C_20CompletionCondition_2C_20WriteHandler_20_3E_2C_20Executor_20_3E" id="r_associated_5Fexecutor_3C_20detail_3A_3Awrite_5Fdynbuf_5Fv2_5Fop_3C_20AsyncWriteStream_2C_20DynamicBuffer_5Fv2_2C_20CompletionCondition_2C_20WriteHandler_20_3E_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01detail_1_1write__dynbuf__v2__op_3_01AsyncWriteStream_00_055133e56b0032f764ff928b01e669aa0.html">associated_executor&lt; detail::write_dynbuf_v2_op&lt; AsyncWriteStream, DynamicBuffer_v2, CompletionCondition, WriteHandler &gt;, Executor &gt;</a></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20detail_3A_3Awrite_5Fat_5Fop_3C_20AsyncRandomAccessWriteDevice_2C_20ConstBufferSequence_2C_20ConstBufferIterator_2C_20CompletionCondition_2C_20WriteHandler_20_3E_2C_20Allocator_20_3E" id="r_associated_5Fallocator_3C_20detail_3A_3Awrite_5Fat_5Fop_3C_20AsyncRandomAccessWriteDevice_2C_20ConstBufferSequence_2C_20ConstBufferIterator_2C_20CompletionCondition_2C_20WriteHandler_20_3E_2C_20Allocator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01detail_1_1write__at__op_3_01AsyncRandomAccessWriteDevicea46091b79425b174903650625a6a69b3.html">associated_allocator&lt; detail::write_at_op&lt; AsyncRandomAccessWriteDevice, ConstBufferSequence, ConstBufferIterator, CompletionCondition, WriteHandler &gt;, Allocator &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20detail_3A_3Awrite_5Fat_5Fop_3C_20AsyncRandomAccessWriteDevice_2C_20ConstBufferSequence_2C_20ConstBufferIterator_2C_20CompletionCondition_2C_20WriteHandler_20_3E_2C_20Executor_20_3E" id="r_associated_5Fexecutor_3C_20detail_3A_3Awrite_5Fat_5Fop_3C_20AsyncRandomAccessWriteDevice_2C_20ConstBufferSequence_2C_20ConstBufferIterator_2C_20CompletionCondition_2C_20WriteHandler_20_3E_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01detail_1_1write__at__op_3_01AsyncRandomAccessWriteDevice_1849a2bfaa7131b93c0e035eccd3d91c.html">associated_executor&lt; detail::write_at_op&lt; AsyncRandomAccessWriteDevice, ConstBufferSequence, ConstBufferIterator, CompletionCondition, WriteHandler &gt;, Executor &gt;</a></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20detail_3A_3Awrite_5Fat_5Fstreambuf_5Fop_3C_20Allocator_2C_20WriteHandler_20_3E_2C_20Allocator1_20_3E" id="r_associated_5Fallocator_3C_20detail_3A_3Awrite_5Fat_5Fstreambuf_5Fop_3C_20Allocator_2C_20WriteHandler_20_3E_2C_20Allocator1_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01detail_1_1write__at__streambuf__op_3_01Allocator_00_01Wr95f24002a4a586d975c1aefd8f9e4435.html">associated_allocator&lt; detail::write_at_streambuf_op&lt; Allocator, WriteHandler &gt;, Allocator1 &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20detail_3A_3Awrite_5Fat_5Fstreambuf_5Fop_3C_20Executor_2C_20WriteHandler_20_3E_2C_20Executor1_20_3E" id="r_associated_5Fexecutor_3C_20detail_3A_3Awrite_5Fat_5Fstreambuf_5Fop_3C_20Executor_2C_20WriteHandler_20_3E_2C_20Executor1_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01detail_1_1write__at__streambuf__op_3_01Executor_00_01Writ2f1b444b150d3c8b9633dd18701a5855.html">associated_executor&lt; detail::write_at_streambuf_op&lt; Executor, WriteHandler &gt;, Executor1 &gt;</a></td></tr>
<tr class="memitem:io_5Fcontext" id="r_io_5Fcontext"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1io__context.html">io_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides core I/O functionality.  <a href="classasio_1_1io__context.html#details">More...</a><br /></td></tr>
<tr class="memitem:is_5Fexecutor" id="r_is_5Fexecutor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__executor.html">is_executor</a></td></tr>
<tr class="memitem:is_5Fread_5Fbuffered" id="r_is_5Fread_5Fbuffered"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1is__read__buffered.html">is_read_buffered</a></td></tr>
<tr class="memitem:is_5Fwrite_5Fbuffered" id="r_is_5Fwrite_5Fbuffered"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1is__write__buffered.html">is_write_buffered</a></td></tr>
<tr class="memitem:is_5Fmatch_5Fcondition" id="r_is_5Fmatch_5Fcondition"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></td></tr>
<tr class="memitem:redirect_5Ferror_5Ft" id="r_redirect_5Ferror_5Ft"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1redirect__error__t.html">redirect_error_t</a></td></tr>
<tr class="memitem:socket_5Fbase" id="r_socket_5Fbase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html">socket_base</a></td></tr>
<tr class="memitem:basic_5Fyield_5Fcontext" id="r_basic_5Fyield_5Fcontext"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context object the represents the currently executing coroutine.  <a href="classasio_1_1basic__yield__context.html#details">More...</a><br /></td></tr>
<tr class="memitem:associated_5Fallocator_3C_20ssl_3A_3Adetail_3A_3Aio_5Fop_3C_20Stream_2C_20Operation_2C_20Handler_20_3E_2C_20Allocator_20_3E" id="r_associated_5Fallocator_3C_20ssl_3A_3Adetail_3A_3Aio_5Fop_3C_20Stream_2C_20Operation_2C_20Handler_20_3E_2C_20Allocator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator_3_01ssl_1_1detail_1_1io__op_3_01Stream_00_01Operation_00_01Handler_01_4_00_01Allocator_01_4.html">associated_allocator&lt; ssl::detail::io_op&lt; Stream, Operation, Handler &gt;, Allocator &gt;</a></td></tr>
<tr class="memitem:associated_5Fexecutor_3C_20ssl_3A_3Adetail_3A_3Aio_5Fop_3C_20Stream_2C_20Operation_2C_20Handler_20_3E_2C_20Executor_20_3E" id="r_associated_5Fexecutor_3C_20ssl_3A_3Adetail_3A_3Aio_5Fop_3C_20Stream_2C_20Operation_2C_20Handler_20_3E_2C_20Executor_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor_3_01ssl_1_1detail_1_1io__op_3_01Stream_00_01Operation_00_01Handler_01_4_00_01Executor_01_4.html">associated_executor&lt; ssl::detail::io_op&lt; Stream, Operation, Handler &gt;, Executor &gt;</a></td></tr>
<tr class="memitem:strand" id="r_strand"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1strand.html">strand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides serialised function invocation for any executor type.  <a href="classasio_1_1strand.html#details">More...</a><br /></td></tr>
<tr class="memitem:system_5Fcontext" id="r_system_5Fcontext"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1system__context.html">system_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The executor context for the system executor.  <a href="classasio_1_1system__context.html#details">More...</a><br /></td></tr>
<tr class="memitem:system_5Ferror" id="r_system_5Ferror"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1system__error.html">system_error</a></td></tr>
<tr class="memitem:system_5Fexecutor" id="r_system_5Fexecutor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1system__executor.html">system_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An executor that uses arbitrary threads.  <a href="classasio_1_1system__executor.html#details">More...</a><br /></td></tr>
<tr class="memitem:thread" id="r_thread"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1thread.html">thread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple abstraction for starting threads.  <a href="classasio_1_1thread.html#details">More...</a><br /></td></tr>
<tr class="memitem:thread_5Fpool" id="r_thread_5Fpool"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1thread__pool.html">thread_pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple fixed-size thread pool.  <a href="classasio_1_1thread__pool.html#details">More...</a><br /></td></tr>
<tr class="memitem:wait_5Ftraits" id="r_wait_5Ftraits"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1wait__traits.html">wait_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait traits suitable for use with the <a class="el" href="classasio_1_1basic__waitable__timer.html" title="Provides waitable timer functionality.">basic_waitable_timer</a> class template.  <a href="structasio_1_1wait__traits.html#details">More...</a><br /></td></tr>
<tr class="memitem:executor_5Farg_5Ft" id="r_executor_5Farg_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1executor__arg__t.html">executor_arg_t</a></td></tr>
<tr class="memitem:uses_5Fexecutor" id="r_uses_5Fexecutor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1uses__executor.html">uses_executor</a></td></tr>
<tr class="memitem:noncopyable" id="r_noncopyable"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1noncopyable.html">noncopyable</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8904bd25ca421af4140ab7ac95b0b956" id="r_a8904bd25ca421af4140ab7ac95b0b956"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1io__context.html">io_context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8904bd25ca421af4140ab7ac95b0b956">io_service</a></td></tr>
<tr class="memdesc:a8904bd25ca421af4140ab7ac95b0b956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for backwards compatibility.  <br /></td></tr>
<tr class="memitem:a4f135fc124cc60e4e00dc2dbb309f354" id="r_a4f135fc124cc60e4e00dc2dbb309f354"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1basic__signal__set.html">basic_signal_set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f135fc124cc60e4e00dc2dbb309f354">signal_set</a></td></tr>
<tr class="memdesc:a4f135fc124cc60e4e00dc2dbb309f354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for the typical usage of a signal set.  <br /></td></tr>
<tr class="memitem:a9924bebddd5beaed619069edb81f09d7" id="r_a9924bebddd5beaed619069edb81f09d7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; <a class="el" href="classasio_1_1executor__binder.html">executor_binder</a>&lt; <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(*)(), <a class="el" href="classasio_1_1executor.html">executor</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9924bebddd5beaed619069edb81f09d7">yield_context</a></td></tr>
<tr class="memitem:a6a7ba348943527312eeace3492bf32ee" id="r_a6a7ba348943527312eeace3492bf32ee"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a7ba348943527312eeace3492bf32ee">streambuf</a></td></tr>
<tr class="memdesc:a6a7ba348943527312eeace3492bf32ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for the typical usage of <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a>.  <br /></td></tr>
<tr class="memitem:a29630b390f0e1aa1a8121ec3962ea9eb" id="r_a29630b390f0e1aa1a8121ec3962ea9eb"><td class="memItemLeft" align="right" valign="top">typedef Executor <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> Executor Iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a></td></tr>
<tr class="memitem:ab90565a6d8a05fc349e42527443ca30f" id="r_ab90565a6d8a05fc349e42527443ca30f"><td class="memItemLeft" align="right" valign="top">typedef Executor <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> Executor Iterator <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> Executor Iterator Iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab90565a6d8a05fc349e42527443ca30f">end</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae518b5450d78d530faa74e7e28aa2dac" id="r_ae518b5450d78d530faa74e7e28aa2dac"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>&gt; </td></tr>
<tr class="memitem:ae518b5450d78d530faa74e7e28aa2dac template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structasio_1_1associated__allocator.html">associated_allocator</a>&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae518b5450d78d530faa74e7e28aa2dac">get_associated_allocator</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &amp;t) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:ae518b5450d78d530faa74e7e28aa2dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated allocator.  <br /></td></tr>
<tr class="memitem:a579553334e8f23a3e929842807a7ab0f" id="r_a579553334e8f23a3e929842807a7ab0f"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>, typename Allocator&gt; </td></tr>
<tr class="memitem:a579553334e8f23a3e929842807a7ab0f template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structasio_1_1associated__allocator.html">associated_allocator</a>&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>, Allocator &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a579553334e8f23a3e929842807a7ab0f">get_associated_allocator</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &amp;t, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Allocator &amp;<a class="el" href="Spc__Cpu_8h.html#a4b87847040966f886849e0c36d6ed53b">a</a>) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:a579553334e8f23a3e929842807a7ab0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated allocator.  <br /></td></tr>
<tr class="memitem:aa843447a2d3c06acc107d484b4c6b0ca" id="r_aa843447a2d3c06acc107d484b4c6b0ca"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>&gt; </td></tr>
<tr class="memitem:aa843447a2d3c06acc107d484b4c6b0ca template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa843447a2d3c06acc107d484b4c6b0ca">get_associated_executor</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &amp;t) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa843447a2d3c06acc107d484b4c6b0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated executor.  <br /></td></tr>
<tr class="memitem:aa751038b47ae548eb967d30954b4ffb6" id="r_aa751038b47ae548eb967d30954b4ffb6"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>, typename Executor&gt; </td></tr>
<tr class="memitem:aa751038b47ae548eb967d30954b4ffb6 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>, Executor &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa751038b47ae548eb967d30954b4ffb6">get_associated_executor</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &amp;t, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Executor &amp;ex, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa751038b47ae548eb967d30954b4ffb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated executor.  <br /></td></tr>
<tr class="memitem:a8c5a1378977472c2b698186821b7759c" id="r_a8c5a1378977472c2b698186821b7759c"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>, typename ExecutionContext&gt; </td></tr>
<tr class="memitem:a8c5a1378977472c2b698186821b7759c template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>, typenameExecutionContext::executor_type &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c5a1378977472c2b698186821b7759c">get_associated_executor</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &amp;t, ExecutionContext &amp;ctx, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:a8c5a1378977472c2b698186821b7759c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated executor.  <br /></td></tr>
<tr class="memitem:aed2f96583612003958535ed0e116650c" id="r_aed2f96583612003958535ed0e116650c"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken, typename Signature, typename Initiation&gt; </td></tr>
<tr class="memitem:aed2f96583612003958535ed0e116650c template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1detail_1_1async__result__has__initiate__memfn.html">detail::async_result_has_initiate_memfn</a>&lt; CompletionToken, Signature &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a>, <a class="el" href="#aeafc22dcf4397b1b5f52ced939a55203">ASIO_INITFN_RESULT_TYPE</a>(CompletionToken, Signature)&gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed2f96583612003958535ed0e116650c">async_initiate</a> (<a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(Initiation) initiation, <a class="el" href="config_8hpp.html#abe8a635435f7cc0358f9b4134b6b424e">ASIO_NONDEDUCED_MOVE_ARG</a>(CompletionToken) <a class="el" href="#a6ef043a2bc0f0ec501dc3c51b31e2de8">token</a>)</td></tr>
<tr class="memitem:ab07c4636cfad1cd03404f9372cda419a" id="r_ab07c4636cfad1cd03404f9372cda419a"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken, typename Signature, typename Initiation&gt; </td></tr>
<tr class="memitem:ab07c4636cfad1cd03404f9372cda419a template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structasio_1_1detail_1_1async__result__has__initiate__memfn.html">detail::async_result_has_initiate_memfn</a>&lt; CompletionToken, Signature &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a>, <a class="el" href="#aeafc22dcf4397b1b5f52ced939a55203">ASIO_INITFN_RESULT_TYPE</a>(CompletionToken, Signature)&gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab07c4636cfad1cd03404f9372cda419a">async_initiate</a> (<a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(Initiation) initiation, <a class="el" href="config_8hpp.html#abe8a635435f7cc0358f9b4134b6b424e">ASIO_NONDEDUCED_MOVE_ARG</a>(CompletionToken) <a class="el" href="#a6ef043a2bc0f0ec501dc3c51b31e2de8">token</a>)</td></tr>
<tr class="memitem:a6eb37798be50fabce361ea541f359084" id="r_a6eb37798be50fabce361ea541f359084"><td class="memTemplParams" colspan="2">template&lt;typename Executor, typename <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>&gt; </td></tr>
<tr class="memitem:a6eb37798be50fabce361ea541f359084 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1executor__binder.html">executor_binder</a>&lt; typename decay&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a>, Executor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6eb37798be50fabce361ea541f359084">bind_executor</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Executor &amp;ex, <a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(<a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>) t, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:a6eb37798be50fabce361ea541f359084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate an object of type <code>T</code> with an executor of type <code>Executor</code>.  <br /></td></tr>
<tr class="memitem:af0bf8af34d9c5e59fd066a8502d3087b" id="r_af0bf8af34d9c5e59fd066a8502d3087b"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext, typename <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>&gt; </td></tr>
<tr class="memitem:af0bf8af34d9c5e59fd066a8502d3087b template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1executor__binder.html">executor_binder</a>&lt; typename decay&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a>, typename ExecutionContext::executor_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0bf8af34d9c5e59fd066a8502d3087b">bind_executor</a> (ExecutionContext &amp;ctx, <a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(<a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>) t, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:af0bf8af34d9c5e59fd066a8502d3087b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate an object of type <code>T</code> with an execution context's executor.  <br /></td></tr>
<tr class="memitem:a531e6aceb9629aa4c2b760b0d6b83562" id="r_a531e6aceb9629aa4c2b760b0d6b83562"><td class="memTemplParams" colspan="2">template&lt;typename MutableBuffer&gt; </td></tr>
<tr class="memitem:a531e6aceb9629aa4c2b760b0d6b83562 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a531e6aceb9629aa4c2b760b0d6b83562">buffer_sequence_begin</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBuffer &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; is_convertible&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBuffer *, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:a531e6aceb9629aa4c2b760b0d6b83562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first element in a buffer sequence.  <br /></td></tr>
<tr class="memitem:a63f3e98466965a1c184ae33b448d0948" id="r_a63f3e98466965a1c184ae33b448d0948"><td class="memTemplParams" colspan="2">template&lt;typename ConstBuffer&gt; </td></tr>
<tr class="memitem:a63f3e98466965a1c184ae33b448d0948 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63f3e98466965a1c184ae33b448d0948">buffer_sequence_begin</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBuffer &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; is_convertible&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBuffer *, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:a63f3e98466965a1c184ae33b448d0948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first element in a buffer sequence.  <br /></td></tr>
<tr class="memitem:a4cb86c7fe7314eb7f0cb8391ac94d4cd" id="r_a4cb86c7fe7314eb7f0cb8391ac94d4cd"><td class="memTemplParams" colspan="2">template&lt;typename C&gt; </td></tr>
<tr class="memitem:a4cb86c7fe7314eb7f0cb8391ac94d4cd template"><td class="memItemLeft" align="right" valign="top">C::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cb86c7fe7314eb7f0cb8391ac94d4cd">buffer_sequence_begin</a> (C &amp;<a class="el" href="Spc__Cpu_8h.html#a4e1e0e72dd773439e333c84dd762a9c3">c</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; !is_convertible&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> C *, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!is_convertible&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> C *, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memitem:adaf169b3f69489851a2ec786d389d297" id="r_adaf169b3f69489851a2ec786d389d297"><td class="memTemplParams" colspan="2">template&lt;typename C&gt; </td></tr>
<tr class="memitem:adaf169b3f69489851a2ec786d389d297 template"><td class="memItemLeft" align="right" valign="top">C::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adaf169b3f69489851a2ec786d389d297">buffer_sequence_begin</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> C &amp;<a class="el" href="Spc__Cpu_8h.html#a4e1e0e72dd773439e333c84dd762a9c3">c</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; !is_convertible&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> C *, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!is_convertible&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> C *, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memitem:a41da7709ea67abc77cedf607650c68c7" id="r_a41da7709ea67abc77cedf607650c68c7"><td class="memTemplParams" colspan="2">template&lt;typename MutableBuffer&gt; </td></tr>
<tr class="memitem:a41da7709ea67abc77cedf607650c68c7 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41da7709ea67abc77cedf607650c68c7">buffer_sequence_end</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBuffer &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; is_convertible&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBuffer *, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:a41da7709ea67abc77cedf607650c68c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to one past the end element in a buffer sequence.  <br /></td></tr>
<tr class="memitem:abb326f21bb60b07149a56f7e247956bb" id="r_abb326f21bb60b07149a56f7e247956bb"><td class="memTemplParams" colspan="2">template&lt;typename ConstBuffer&gt; </td></tr>
<tr class="memitem:abb326f21bb60b07149a56f7e247956bb template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb326f21bb60b07149a56f7e247956bb">buffer_sequence_end</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBuffer &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; is_convertible&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBuffer *, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:abb326f21bb60b07149a56f7e247956bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to one past the end element in a buffer sequence.  <br /></td></tr>
<tr class="memitem:a48c0cfb5e2c1894048db8cc679f99996" id="r_a48c0cfb5e2c1894048db8cc679f99996"><td class="memTemplParams" colspan="2">template&lt;typename C&gt; </td></tr>
<tr class="memitem:a48c0cfb5e2c1894048db8cc679f99996 template"><td class="memItemLeft" align="right" valign="top">C::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48c0cfb5e2c1894048db8cc679f99996">buffer_sequence_end</a> (C &amp;<a class="el" href="Spc__Cpu_8h.html#a4e1e0e72dd773439e333c84dd762a9c3">c</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; !is_convertible&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> C *, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!is_convertible&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> C *, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memitem:adc4b5c460b980a645c3c63fdd9a0b947" id="r_adc4b5c460b980a645c3c63fdd9a0b947"><td class="memTemplParams" colspan="2">template&lt;typename C&gt; </td></tr>
<tr class="memitem:adc4b5c460b980a645c3c63fdd9a0b947 template"><td class="memItemLeft" align="right" valign="top">C::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc4b5c460b980a645c3c63fdd9a0b947">buffer_sequence_end</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> C &amp;<a class="el" href="Spc__Cpu_8h.html#a4e1e0e72dd773439e333c84dd762a9c3">c</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; !is_convertible&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> C *, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!is_convertible&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> C *, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memitem:ac72f80e47f237b42d777bd7eb2653798" id="r_ac72f80e47f237b42d777bd7eb2653798"><td class="memTemplParams" colspan="2">template&lt;typename BufferSequence&gt; </td></tr>
<tr class="memitem:ac72f80e47f237b42d777bd7eb2653798 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac72f80e47f237b42d777bd7eb2653798">buffer_size</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> BufferSequence &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac72f80e47f237b42d777bd7eb2653798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of bytes in a buffer sequence.  <br /></td></tr>
<tr class="memitem:ad4f92bea5381ff9a3074af1157b267dd" id="r_ad4f92bea5381ff9a3074af1157b267dd"><td class="memTemplParams" colspan="2">template&lt;typename PointerToPodType&gt; </td></tr>
<tr class="memitem:ad4f92bea5381ff9a3074af1157b267dd template"><td class="memItemLeft" align="right" valign="top">PointerToPodType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4f92bea5381ff9a3074af1157b267dd">buffer_cast</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad4f92bea5381ff9a3074af1157b267dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a non-modifiable buffer to a specified pointer to POD type.  <br /></td></tr>
<tr class="memitem:adcf1d874ce546b0f5ef250e25952094f" id="r_adcf1d874ce546b0f5ef250e25952094f"><td class="memTemplParams" colspan="2">template&lt;typename PointerToPodType&gt; </td></tr>
<tr class="memitem:adcf1d874ce546b0f5ef250e25952094f template"><td class="memItemLeft" align="right" valign="top">PointerToPodType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcf1d874ce546b0f5ef250e25952094f">buffer_cast</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:adcf1d874ce546b0f5ef250e25952094f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a non-modifiable buffer to a specified pointer to POD type.  <br /></td></tr>
<tr class="memitem:aab2e5a8bd2a00b088a5644c64ef73e2a" id="r_aab2e5a8bd2a00b088a5644c64ef73e2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab2e5a8bd2a00b088a5644c64ef73e2a">buffer</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:aab2e5a8bd2a00b088a5644c64ef73e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer from an existing buffer.  <br /></td></tr>
<tr class="memitem:a09f2e959219011f793a85389e272d608" id="r_a09f2e959219011f793a85389e272d608"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09f2e959219011f793a85389e272d608">buffer</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, std::size_t max_size_in_bytes) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:a09f2e959219011f793a85389e272d608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer from an existing buffer.  <br /></td></tr>
<tr class="memitem:a49fedcbcde972dfb6078ff550a59e49c" id="r_a49fedcbcde972dfb6078ff550a59e49c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49fedcbcde972dfb6078ff550a59e49c">buffer</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:a49fedcbcde972dfb6078ff550a59e49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer from an existing buffer.  <br /></td></tr>
<tr class="memitem:af6d68320baa8d46472e6182c8980a881" id="r_af6d68320baa8d46472e6182c8980a881"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6d68320baa8d46472e6182c8980a881">buffer</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, std::size_t max_size_in_bytes) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:af6d68320baa8d46472e6182c8980a881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer from an existing buffer.  <br /></td></tr>
<tr class="memitem:a47e3d0ebd0117a592b5dfe84cb1d8ffa" id="r_a47e3d0ebd0117a592b5dfe84cb1d8ffa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47e3d0ebd0117a592b5dfe84cb1d8ffa">buffer</a> (<a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a> *<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, std::size_t size_in_bytes) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:a47e3d0ebd0117a592b5dfe84cb1d8ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given memory range.  <br /></td></tr>
<tr class="memitem:ad4316c04382a05008f8cf5a43b731e1c" id="r_ad4316c04382a05008f8cf5a43b731e1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4316c04382a05008f8cf5a43b731e1c">buffer</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a> *<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, std::size_t size_in_bytes) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad4316c04382a05008f8cf5a43b731e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given memory range.  <br /></td></tr>
<tr class="memitem:ad5e3fe0e83a1753131eee9363e36c4f1" id="r_ad5e3fe0e83a1753131eee9363e36c4f1"><td class="memTemplParams" colspan="2">template&lt;typename PodType, std::size_t N&gt; </td></tr>
<tr class="memitem:ad5e3fe0e83a1753131eee9363e36c4f1 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5e3fe0e83a1753131eee9363e36c4f1">buffer</a> (PodType(&amp;<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>)[<a class="el" href="interface_8cc.html#a0240ac851181b84ac374872dc5434ee4">N</a>]) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad5e3fe0e83a1753131eee9363e36c4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <br /></td></tr>
<tr class="memitem:a6718b1a29f43038bd66424e814f85dfa" id="r_a6718b1a29f43038bd66424e814f85dfa"><td class="memTemplParams" colspan="2">template&lt;typename PodType, std::size_t N&gt; </td></tr>
<tr class="memitem:a6718b1a29f43038bd66424e814f85dfa template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6718b1a29f43038bd66424e814f85dfa">buffer</a> (PodType(&amp;<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>)[<a class="el" href="interface_8cc.html#a0240ac851181b84ac374872dc5434ee4">N</a>], std::size_t max_size_in_bytes) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:a6718b1a29f43038bd66424e814f85dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <br /></td></tr>
<tr class="memitem:a3f4a8399dc1d37dc59fbfb1a022a9f41" id="r_a3f4a8399dc1d37dc59fbfb1a022a9f41"><td class="memTemplParams" colspan="2">template&lt;typename PodType, std::size_t N&gt; </td></tr>
<tr class="memitem:a3f4a8399dc1d37dc59fbfb1a022a9f41 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f4a8399dc1d37dc59fbfb1a022a9f41">buffer</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> PodType(&amp;<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>)[<a class="el" href="interface_8cc.html#a0240ac851181b84ac374872dc5434ee4">N</a>]) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3f4a8399dc1d37dc59fbfb1a022a9f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <br /></td></tr>
<tr class="memitem:afb8ba631a53bb59557e5d0518d450d09" id="r_afb8ba631a53bb59557e5d0518d450d09"><td class="memTemplParams" colspan="2">template&lt;typename PodType, std::size_t N&gt; </td></tr>
<tr class="memitem:afb8ba631a53bb59557e5d0518d450d09 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb8ba631a53bb59557e5d0518d450d09">buffer</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> PodType(&amp;<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>)[<a class="el" href="interface_8cc.html#a0240ac851181b84ac374872dc5434ee4">N</a>], std::size_t max_size_in_bytes) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:afb8ba631a53bb59557e5d0518d450d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <br /></td></tr>
<tr class="memitem:ad9d36bcb3c3178a352c89b8752a0b6f7" id="r_ad9d36bcb3c3178a352c89b8752a0b6f7"><td class="memTemplParams" colspan="2">template&lt;typename PodType, std::size_t N&gt; </td></tr>
<tr class="memitem:ad9d36bcb3c3178a352c89b8752a0b6f7 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9d36bcb3c3178a352c89b8752a0b6f7">buffer</a> (<a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, <a class="el" href="interface_8cc.html#a0240ac851181b84ac374872dc5434ee4">N</a> &gt; &amp;<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad9d36bcb3c3178a352c89b8752a0b6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <br /></td></tr>
<tr class="memitem:afa50ee8a50ea8e3de2a4e24a3f479712" id="r_afa50ee8a50ea8e3de2a4e24a3f479712"><td class="memTemplParams" colspan="2">template&lt;typename PodType, std::size_t N&gt; </td></tr>
<tr class="memitem:afa50ee8a50ea8e3de2a4e24a3f479712 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa50ee8a50ea8e3de2a4e24a3f479712">buffer</a> (<a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, <a class="el" href="interface_8cc.html#a0240ac851181b84ac374872dc5434ee4">N</a> &gt; &amp;<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, std::size_t max_size_in_bytes) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:afa50ee8a50ea8e3de2a4e24a3f479712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <br /></td></tr>
<tr class="memitem:ab33ce05280e1d634d9c3a06e473ab7e3" id="r_ab33ce05280e1d634d9c3a06e473ab7e3"><td class="memTemplParams" colspan="2">template&lt;typename PodType, std::size_t N&gt; </td></tr>
<tr class="memitem:ab33ce05280e1d634d9c3a06e473ab7e3 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab33ce05280e1d634d9c3a06e473ab7e3">buffer</a> (<a class="el" href="classboost_1_1array.html">boost::array</a>&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> PodType, <a class="el" href="interface_8cc.html#a0240ac851181b84ac374872dc5434ee4">N</a> &gt; &amp;<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab33ce05280e1d634d9c3a06e473ab7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <br /></td></tr>
<tr class="memitem:ac8610fbc63212d464bafb1543716ba5c" id="r_ac8610fbc63212d464bafb1543716ba5c"><td class="memTemplParams" colspan="2">template&lt;typename PodType, std::size_t N&gt; </td></tr>
<tr class="memitem:ac8610fbc63212d464bafb1543716ba5c template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8610fbc63212d464bafb1543716ba5c">buffer</a> (<a class="el" href="classboost_1_1array.html">boost::array</a>&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> PodType, <a class="el" href="interface_8cc.html#a0240ac851181b84ac374872dc5434ee4">N</a> &gt; &amp;<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, std::size_t max_size_in_bytes) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac8610fbc63212d464bafb1543716ba5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <br /></td></tr>
<tr class="memitem:aa62463079331806495a6822204fbceec" id="r_aa62463079331806495a6822204fbceec"><td class="memTemplParams" colspan="2">template&lt;typename PodType, std::size_t N&gt; </td></tr>
<tr class="memitem:aa62463079331806495a6822204fbceec template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa62463079331806495a6822204fbceec">buffer</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, <a class="el" href="interface_8cc.html#a0240ac851181b84ac374872dc5434ee4">N</a> &gt; &amp;<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:aa62463079331806495a6822204fbceec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <br /></td></tr>
<tr class="memitem:a66ca9f4c43d4aebdd2beba9488f99243" id="r_a66ca9f4c43d4aebdd2beba9488f99243"><td class="memTemplParams" colspan="2">template&lt;typename PodType, std::size_t N&gt; </td></tr>
<tr class="memitem:a66ca9f4c43d4aebdd2beba9488f99243 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66ca9f4c43d4aebdd2beba9488f99243">buffer</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, <a class="el" href="interface_8cc.html#a0240ac851181b84ac374872dc5434ee4">N</a> &gt; &amp;<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, std::size_t max_size_in_bytes) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:a66ca9f4c43d4aebdd2beba9488f99243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <br /></td></tr>
<tr class="memitem:a3bcd62537bad84dcf220ebb6d7c98fce" id="r_a3bcd62537bad84dcf220ebb6d7c98fce"><td class="memTemplParams" colspan="2">template&lt;typename PodType, typename Allocator&gt; </td></tr>
<tr class="memitem:a3bcd62537bad84dcf220ebb6d7c98fce template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bcd62537bad84dcf220ebb6d7c98fce">buffer</a> (std::vector&lt; PodType, Allocator &gt; &amp;<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:a3bcd62537bad84dcf220ebb6d7c98fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD vector.  <br /></td></tr>
<tr class="memitem:ab259071c0eb07d60166a241ae6897fa5" id="r_ab259071c0eb07d60166a241ae6897fa5"><td class="memTemplParams" colspan="2">template&lt;typename PodType, typename Allocator&gt; </td></tr>
<tr class="memitem:ab259071c0eb07d60166a241ae6897fa5 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab259071c0eb07d60166a241ae6897fa5">buffer</a> (std::vector&lt; PodType, Allocator &gt; &amp;<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, std::size_t max_size_in_bytes) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:ab259071c0eb07d60166a241ae6897fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD vector.  <br /></td></tr>
<tr class="memitem:a5b3392160817dd6911a156cac82e8bdb" id="r_a5b3392160817dd6911a156cac82e8bdb"><td class="memTemplParams" colspan="2">template&lt;typename PodType, typename Allocator&gt; </td></tr>
<tr class="memitem:a5b3392160817dd6911a156cac82e8bdb template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b3392160817dd6911a156cac82e8bdb">buffer</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::vector&lt; PodType, Allocator &gt; &amp;<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:a5b3392160817dd6911a156cac82e8bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD vector.  <br /></td></tr>
<tr class="memitem:acc892c137c8804fbbaa23d09a0fb5195" id="r_acc892c137c8804fbbaa23d09a0fb5195"><td class="memTemplParams" colspan="2">template&lt;typename PodType, typename Allocator&gt; </td></tr>
<tr class="memitem:acc892c137c8804fbbaa23d09a0fb5195 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc892c137c8804fbbaa23d09a0fb5195">buffer</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::vector&lt; PodType, Allocator &gt; &amp;<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, std::size_t max_size_in_bytes) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:acc892c137c8804fbbaa23d09a0fb5195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD vector.  <br /></td></tr>
<tr class="memitem:ad668759a45f9234b9f0680d4e264d908" id="r_ad668759a45f9234b9f0680d4e264d908"><td class="memTemplParams" colspan="2">template&lt;typename Elem, typename Traits, typename Allocator&gt; </td></tr>
<tr class="memitem:ad668759a45f9234b9f0680d4e264d908 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad668759a45f9234b9f0680d4e264d908">buffer</a> (std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad668759a45f9234b9f0680d4e264d908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given string.  <br /></td></tr>
<tr class="memitem:a1652342c5fa036d0cf87d437b5807370" id="r_a1652342c5fa036d0cf87d437b5807370"><td class="memTemplParams" colspan="2">template&lt;typename Elem, typename Traits, typename Allocator&gt; </td></tr>
<tr class="memitem:a1652342c5fa036d0cf87d437b5807370 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1652342c5fa036d0cf87d437b5807370">buffer</a> (std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, std::size_t max_size_in_bytes) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:a1652342c5fa036d0cf87d437b5807370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given string.  <br /></td></tr>
<tr class="memitem:a87b1758913fefb7f8ddf03bbb22ead2a" id="r_a87b1758913fefb7f8ddf03bbb22ead2a"><td class="memTemplParams" colspan="2">template&lt;typename Elem, typename Traits, typename Allocator&gt; </td></tr>
<tr class="memitem:a87b1758913fefb7f8ddf03bbb22ead2a template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87b1758913fefb7f8ddf03bbb22ead2a">buffer</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:a87b1758913fefb7f8ddf03bbb22ead2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given string.  <br /></td></tr>
<tr class="memitem:ad1e98367b9e0233f03d1b918043c3093" id="r_ad1e98367b9e0233f03d1b918043c3093"><td class="memTemplParams" colspan="2">template&lt;typename Elem, typename Traits, typename Allocator&gt; </td></tr>
<tr class="memitem:ad1e98367b9e0233f03d1b918043c3093 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1e98367b9e0233f03d1b918043c3093">buffer</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, std::size_t max_size_in_bytes) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:ad1e98367b9e0233f03d1b918043c3093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given string.  <br /></td></tr>
<tr class="memitem:a082ceaa5ce3217fda0bcc008a211a272" id="r_a082ceaa5ce3217fda0bcc008a211a272"><td class="memTemplParams" colspan="2">template&lt;typename Elem, typename Traits, typename Allocator&gt; </td></tr>
<tr class="memitem:a082ceaa5ce3217fda0bcc008a211a272 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1dynamic__string__buffer.html">dynamic_string_buffer</a>&lt; Elem, Traits, Allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a082ceaa5ce3217fda0bcc008a211a272">dynamic_buffer</a> (std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:a082ceaa5ce3217fda0bcc008a211a272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new dynamic buffer that represents the given string.  <br /></td></tr>
<tr class="memitem:a72f4c6e4f3c663830431f48bd91188d4" id="r_a72f4c6e4f3c663830431f48bd91188d4"><td class="memTemplParams" colspan="2">template&lt;typename Elem, typename Traits, typename Allocator&gt; </td></tr>
<tr class="memitem:a72f4c6e4f3c663830431f48bd91188d4 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1dynamic__string__buffer.html">dynamic_string_buffer</a>&lt; Elem, Traits, Allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72f4c6e4f3c663830431f48bd91188d4">dynamic_buffer</a> (std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, std::size_t max_size) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:a72f4c6e4f3c663830431f48bd91188d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new dynamic buffer that represents the given string.  <br /></td></tr>
<tr class="memitem:aaa9fce6304552101942da09828a3b167" id="r_aaa9fce6304552101942da09828a3b167"><td class="memTemplParams" colspan="2">template&lt;typename Elem, typename Allocator&gt; </td></tr>
<tr class="memitem:aaa9fce6304552101942da09828a3b167 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1dynamic__vector__buffer.html">dynamic_vector_buffer</a>&lt; Elem, Allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa9fce6304552101942da09828a3b167">dynamic_buffer</a> (std::vector&lt; Elem, Allocator &gt; &amp;<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:aaa9fce6304552101942da09828a3b167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new dynamic buffer that represents the given vector.  <br /></td></tr>
<tr class="memitem:a08d3f6046e87b03363fdd0cb85ec100b" id="r_a08d3f6046e87b03363fdd0cb85ec100b"><td class="memTemplParams" colspan="2">template&lt;typename Elem, typename Allocator&gt; </td></tr>
<tr class="memitem:a08d3f6046e87b03363fdd0cb85ec100b template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1dynamic__vector__buffer.html">dynamic_vector_buffer</a>&lt; Elem, Allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08d3f6046e87b03363fdd0cb85ec100b">dynamic_buffer</a> (std::vector&lt; Elem, Allocator &gt; &amp;<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, std::size_t max_size) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:a08d3f6046e87b03363fdd0cb85ec100b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new dynamic buffer that represents the given vector.  <br /></td></tr>
<tr class="memitem:a160d0c4badd630c133c213c66b095fc1" id="r_a160d0c4badd630c133c213c66b095fc1"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence, typename ConstBufferSequence&gt; </td></tr>
<tr class="memitem:a160d0c4badd630c133c213c66b095fc1 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a160d0c4badd630c133c213c66b095fc1">buffer_copy</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence &amp;target, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence &amp;source) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:a160d0c4badd630c133c213c66b095fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies bytes from a source buffer sequence to a target buffer sequence.  <br /></td></tr>
<tr class="memitem:a39d2fd7acd66546ce9e539753618bb75" id="r_a39d2fd7acd66546ce9e539753618bb75"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence, typename ConstBufferSequence&gt; </td></tr>
<tr class="memitem:a39d2fd7acd66546ce9e539753618bb75 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39d2fd7acd66546ce9e539753618bb75">buffer_copy</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence &amp;target, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence &amp;source, std::size_t max_bytes_to_copy) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memitem:a42e267c80155b2747d041d2932357762" id="r_a42e267c80155b2747d041d2932357762"><td class="memTemplParams" colspan="2">template&lt;typename BufferSequence&gt; </td></tr>
<tr class="memitem:a42e267c80155b2747d041d2932357762 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1buffers__iterator.html">buffers_iterator</a>&lt; BufferSequence &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42e267c80155b2747d041d2932357762">buffers_begin</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> BufferSequence &amp;<a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>)</td></tr>
<tr class="memdesc:a42e267c80155b2747d041d2932357762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an iterator representing the beginning of the buffers' data.  <br /></td></tr>
<tr class="memitem:a1c586f56452e13b3798ae1925bd35595" id="r_a1c586f56452e13b3798ae1925bd35595"><td class="memTemplParams" colspan="2">template&lt;typename BufferSequence&gt; </td></tr>
<tr class="memitem:a1c586f56452e13b3798ae1925bd35595 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1buffers__iterator.html">buffers_iterator</a>&lt; BufferSequence &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c586f56452e13b3798ae1925bd35595">buffers_end</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> BufferSequence &amp;<a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>)</td></tr>
<tr class="memdesc:a1c586f56452e13b3798ae1925bd35595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an iterator representing the end of the buffers' data.  <br /></td></tr>
<tr class="memitem:a4a82e92df79aa8401a8bc2117d4cf900" id="r_a4a82e92df79aa8401a8bc2117d4cf900"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1detail_1_1transfer__all__t.html">detail::transfer_all_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a82e92df79aa8401a8bc2117d4cf900">transfer_all</a> ()</td></tr>
<tr class="memitem:a2b10af704afcd6c7ed7f0d3b740033ef" id="r_a2b10af704afcd6c7ed7f0d3b740033ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1detail_1_1transfer__at__least__t.html">detail::transfer_at_least_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b10af704afcd6c7ed7f0d3b740033ef">transfer_at_least</a> (std::size_t minimum)</td></tr>
<tr class="memitem:adb2ada9400d78a5df0e5f65dd2b9967e" id="r_adb2ada9400d78a5df0e5f65dd2b9967e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1detail_1_1transfer__exactly__t.html">detail::transfer_exactly_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb2ada9400d78a5df0e5f65dd2b9967e">transfer_exactly</a> (std::size_t size)</td></tr>
<tr class="memitem:a5278b4c4bcd1303ce616b2f0fff4c395" id="r_a5278b4c4bcd1303ce616b2f0fff4c395"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken, typename Signature, typename Implementation&gt; </td></tr>
<tr class="memitem:a5278b4c4bcd1303ce616b2f0fff4c395 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5278b4c4bcd1303ce616b2f0fff4c395">async_compose</a> (<a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(Implementation) implementation, <a class="el" href="config_8hpp.html#abe8a635435f7cc0358f9b4134b6b424e">ASIO_NONDEDUCED_MOVE_ARG</a>(CompletionToken) <a class="el" href="#a6ef043a2bc0f0ec501dc3c51b31e2de8">token</a>)</td></tr>
<tr class="memitem:a451e58dc85e01aced92a59bbf5ca4d47" id="r_a451e58dc85e01aced92a59bbf5ca4d47"><td class="memTemplParams" colspan="2">template&lt;typename Protocol, typename Executor, typename EndpointSequence&gt; </td></tr>
<tr class="memitem:a451e58dc85e01aced92a59bbf5ca4d47 template"><td class="memItemLeft" align="right" valign="top">Protocol::endpoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a451e58dc85e01aced92a59bbf5ca4d47">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence &amp;<a class="el" href="#aba818fe3267fb794f98329cd5a75aee1">endpoints</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:a451e58dc85e01aced92a59bbf5ca4d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <br /></td></tr>
<tr class="memitem:aec3d375db898c9bf6f30e7903d8affec" id="r_aec3d375db898c9bf6f30e7903d8affec"><td class="memTemplParams" colspan="2">template&lt;typename Protocol, typename Executor, typename EndpointSequence&gt; </td></tr>
<tr class="memitem:aec3d375db898c9bf6f30e7903d8affec template"><td class="memItemLeft" align="right" valign="top">Protocol::endpoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec3d375db898c9bf6f30e7903d8affec">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence &amp;<a class="el" href="#aba818fe3267fb794f98329cd5a75aee1">endpoints</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:aec3d375db898c9bf6f30e7903d8affec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <br /></td></tr>
<tr class="memitem:a795806648aa9dee1c9d2c820e0e7839e" id="r_a795806648aa9dee1c9d2c820e0e7839e"><td class="memTemplParams" colspan="2">template&lt;typename Protocol, typename Executor, typename Iterator&gt; </td></tr>
<tr class="memitem:a795806648aa9dee1c9d2c820e0e7839e template"><td class="memItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a795806648aa9dee1c9d2c820e0e7839e">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, Iterator <a class="el" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memitem:a74238337e726fc0b10f0350ffa4aba96" id="r_a74238337e726fc0b10f0350ffa4aba96"><td class="memTemplParams" colspan="2">template&lt;typename Protocol, typename Executor, typename Iterator&gt; </td></tr>
<tr class="memitem:a74238337e726fc0b10f0350ffa4aba96 template"><td class="memItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74238337e726fc0b10f0350ffa4aba96">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, Iterator <a class="el" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memitem:aa8c58255744686dfcd930523d98bc0c2" id="r_aa8c58255744686dfcd930523d98bc0c2"><td class="memTemplParams" colspan="2">template&lt;typename Protocol, typename Executor, typename Iterator&gt; </td></tr>
<tr class="memitem:aa8c58255744686dfcd930523d98bc0c2 template"><td class="memItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8c58255744686dfcd930523d98bc0c2">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, Iterator <a class="el" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>, Iterator <a class="el" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>)</td></tr>
<tr class="memdesc:aa8c58255744686dfcd930523d98bc0c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <br /></td></tr>
<tr class="memitem:a5be799cfeb2dc75e371ffba20d2e62db" id="r_a5be799cfeb2dc75e371ffba20d2e62db"><td class="memTemplParams" colspan="2">template&lt;typename Protocol, typename Executor, typename Iterator&gt; </td></tr>
<tr class="memitem:a5be799cfeb2dc75e371ffba20d2e62db template"><td class="memItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5be799cfeb2dc75e371ffba20d2e62db">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, Iterator <a class="el" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>, Iterator <a class="el" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a5be799cfeb2dc75e371ffba20d2e62db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <br /></td></tr>
<tr class="memitem:a2a5c08454b4139eefd1b24d6141dc11d" id="r_a2a5c08454b4139eefd1b24d6141dc11d"><td class="memTemplParams" colspan="2">template&lt;typename Protocol, typename Executor, typename EndpointSequence, typename ConnectCondition&gt; </td></tr>
<tr class="memitem:a2a5c08454b4139eefd1b24d6141dc11d template"><td class="memItemLeft" align="right" valign="top">Protocol::endpoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a5c08454b4139eefd1b24d6141dc11d">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence &amp;<a class="el" href="#aba818fe3267fb794f98329cd5a75aee1">endpoints</a>, ConnectCondition <a class="el" href="#a9accb3ddb108d48e0e70093ec8d40885">connect_condition</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:a2a5c08454b4139eefd1b24d6141dc11d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <br /></td></tr>
<tr class="memitem:a7baa8d70606b0c0cf064b6596035d048" id="r_a7baa8d70606b0c0cf064b6596035d048"><td class="memTemplParams" colspan="2">template&lt;typename Protocol, typename Executor, typename EndpointSequence, typename ConnectCondition&gt; </td></tr>
<tr class="memitem:a7baa8d70606b0c0cf064b6596035d048 template"><td class="memItemLeft" align="right" valign="top">Protocol::endpoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7baa8d70606b0c0cf064b6596035d048">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence &amp;<a class="el" href="#aba818fe3267fb794f98329cd5a75aee1">endpoints</a>, ConnectCondition <a class="el" href="#a9accb3ddb108d48e0e70093ec8d40885">connect_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:a7baa8d70606b0c0cf064b6596035d048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <br /></td></tr>
<tr class="memitem:aca03102489231106ce9649d52885ad2a" id="r_aca03102489231106ce9649d52885ad2a"><td class="memTemplParams" colspan="2">template&lt;typename Protocol, typename Executor, typename Iterator, typename ConnectCondition&gt; </td></tr>
<tr class="memitem:aca03102489231106ce9649d52885ad2a template"><td class="memItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca03102489231106ce9649d52885ad2a">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, Iterator <a class="el" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>, ConnectCondition <a class="el" href="#a9accb3ddb108d48e0e70093ec8d40885">connect_condition</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memitem:abe0f090f44a2471433a2d236b21cea1c" id="r_abe0f090f44a2471433a2d236b21cea1c"><td class="memTemplParams" colspan="2">template&lt;typename Protocol, typename Executor, typename Iterator, typename ConnectCondition&gt; </td></tr>
<tr class="memitem:abe0f090f44a2471433a2d236b21cea1c template"><td class="memItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe0f090f44a2471433a2d236b21cea1c">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, Iterator <a class="el" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>, ConnectCondition <a class="el" href="#a9accb3ddb108d48e0e70093ec8d40885">connect_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memitem:ad2f94719f8fa630e293df94e5819e4ba" id="r_ad2f94719f8fa630e293df94e5819e4ba"><td class="memTemplParams" colspan="2">template&lt;typename Protocol, typename Executor, typename Iterator, typename ConnectCondition&gt; </td></tr>
<tr class="memitem:ad2f94719f8fa630e293df94e5819e4ba template"><td class="memItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2f94719f8fa630e293df94e5819e4ba">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, Iterator <a class="el" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>, Iterator <a class="el" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>, ConnectCondition <a class="el" href="#a9accb3ddb108d48e0e70093ec8d40885">connect_condition</a>)</td></tr>
<tr class="memdesc:ad2f94719f8fa630e293df94e5819e4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <br /></td></tr>
<tr class="memitem:aec7be5e72ae43d07fced121d88f7b1e2" id="r_aec7be5e72ae43d07fced121d88f7b1e2"><td class="memTemplParams" colspan="2">template&lt;typename Protocol, typename Executor, typename Iterator, typename ConnectCondition&gt; </td></tr>
<tr class="memitem:aec7be5e72ae43d07fced121d88f7b1e2 template"><td class="memItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec7be5e72ae43d07fced121d88f7b1e2">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, Iterator <a class="el" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>, Iterator <a class="el" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>, ConnectCondition <a class="el" href="#a9accb3ddb108d48e0e70093ec8d40885">connect_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:aec7be5e72ae43d07fced121d88f7b1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <br /></td></tr>
<tr class="memitem:aeafc22dcf4397b1b5f52ced939a55203" id="r_aeafc22dcf4397b1b5f52ced939a55203"><td class="memTemplParams" colspan="2">template&lt;typename Protocol, typename Executor, typename EndpointSequence, typename RangeConnectHandler&gt; </td></tr>
<tr class="memitem:aeafc22dcf4397b1b5f52ced939a55203 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeafc22dcf4397b1b5f52ced939a55203">ASIO_INITFN_RESULT_TYPE</a> (RangeConnectHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, typename Protocol::endpoint)) async_connect(<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol</td></tr>
<tr class="memitem:aa83ebf40e1378cd1060cd903baaf294f" id="r_aa83ebf40e1378cd1060cd903baaf294f"><td class="memItemLeft" align="right" valign="top">Executor <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa83ebf40e1378cd1060cd903baaf294f">ASIO_MOVE_ARG</a> (RangeConnectHandler) handler</td></tr>
<tr class="memitem:a3bb009ce2502d1d33b995e7294f3de49" id="r_a3bb009ce2502d1d33b995e7294f3de49"><td class="memTemplParams" colspan="2">template&lt;typename Protocol, typename Executor, typename Iterator, typename IteratorConnectHandler&gt; </td></tr>
<tr class="memitem:a3bb009ce2502d1d33b995e7294f3de49 template"><td class="memItemLeft" align="right" valign="top">Executor <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bb009ce2502d1d33b995e7294f3de49">ASIO_INITFN_RESULT_TYPE</a> (IteratorConnectHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, Iterator)) async_connect(<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol</td></tr>
<tr class="memitem:ad430339c3225c5e715a0dc9fb8a1fec8" id="r_ad430339c3225c5e715a0dc9fb8a1fec8"><td class="memItemLeft" align="right" valign="top">Executor <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> Executor Iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad430339c3225c5e715a0dc9fb8a1fec8">ASIO_MOVE_ARG</a> (IteratorConnectHandler) handler</td></tr>
<tr class="memitem:accc1ea2b415306eaa165aa45ed92f837" id="r_accc1ea2b415306eaa165aa45ed92f837"><td class="memTemplParams" colspan="2">template&lt;typename Protocol, typename Executor, typename Iterator, typename IteratorConnectHandler&gt; </td></tr>
<tr class="memitem:accc1ea2b415306eaa165aa45ed92f837 template"><td class="memItemLeft" align="right" valign="top">Executor <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> Executor Iterator <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accc1ea2b415306eaa165aa45ed92f837">ASIO_INITFN_RESULT_TYPE</a> (IteratorConnectHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, Iterator)) async_connect(<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol</td></tr>
<tr class="memitem:a983464c451e1885c6662a2553fc672d9" id="r_a983464c451e1885c6662a2553fc672d9"><td class="memTemplParams" colspan="2">template&lt;typename Protocol, typename Executor, typename EndpointSequence, typename ConnectCondition, typename RangeConnectHandler&gt; </td></tr>
<tr class="memitem:a983464c451e1885c6662a2553fc672d9 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a983464c451e1885c6662a2553fc672d9">ASIO_INITFN_RESULT_TYPE</a> (RangeConnectHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, typename Protocol::endpoint)) async_connect(<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol</td></tr>
<tr class="memitem:a71085872969c7c0aa8d8d0ae123f103a" id="r_a71085872969c7c0aa8d8d0ae123f103a"><td class="memTemplParams" colspan="2">template&lt;typename Protocol, typename Executor, typename Iterator, typename ConnectCondition, typename IteratorConnectHandler&gt; </td></tr>
<tr class="memitem:a71085872969c7c0aa8d8d0ae123f103a template"><td class="memItemLeft" align="right" valign="top">Executor <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence ConnectCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71085872969c7c0aa8d8d0ae123f103a">ASIO_INITFN_RESULT_TYPE</a> (IteratorConnectHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, Iterator)) async_connect(<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol</td></tr>
<tr class="memitem:ade13b08b021b4b6121f847026c0ea79d" id="r_ade13b08b021b4b6121f847026c0ea79d"><td class="memTemplParams" colspan="2">template&lt;typename Protocol, typename Executor, typename Iterator, typename ConnectCondition, typename IteratorConnectHandler&gt; </td></tr>
<tr class="memitem:ade13b08b021b4b6121f847026c0ea79d template"><td class="memItemLeft" align="right" valign="top">Executor <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence ConnectCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> Executor Iterator ConnectCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade13b08b021b4b6121f847026c0ea79d">ASIO_INITFN_RESULT_TYPE</a> (IteratorConnectHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, Iterator)) async_connect(<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol</td></tr>
<tr class="memitem:a32f4e8ad4781c5ab71346c1035d50be5" id="r_a32f4e8ad4781c5ab71346c1035d50be5"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken&gt; </td></tr>
<tr class="memitem:a32f4e8ad4781c5ab71346c1035d50be5 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32f4e8ad4781c5ab71346c1035d50be5">ASIO_INITFN_RESULT_TYPE</a> (CompletionToken, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>()) defer(<a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(CompletionToken) <a class="el" href="#a6ef043a2bc0f0ec501dc3c51b31e2de8">token</a>)</td></tr>
<tr class="memdesc:a32f4e8ad4781c5ab71346c1035d50be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <br /></td></tr>
<tr class="memitem:a311928c56726e9bd750bd406aeaa2867" id="r_a311928c56726e9bd750bd406aeaa2867"><td class="memTemplParams" colspan="2">template&lt;typename Executor, typename CompletionToken&gt; </td></tr>
<tr class="memitem:a311928c56726e9bd750bd406aeaa2867 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a311928c56726e9bd750bd406aeaa2867">ASIO_INITFN_RESULT_TYPE</a> (CompletionToken, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>()) defer(<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Executor &amp;ex</td></tr>
<tr class="memdesc:a311928c56726e9bd750bd406aeaa2867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <br /></td></tr>
<tr class="memitem:a537a9872ab842095055922cac3ff3e5a" id="r_a537a9872ab842095055922cac3ff3e5a"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext, typename CompletionToken&gt; </td></tr>
<tr class="memitem:a537a9872ab842095055922cac3ff3e5a template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a537a9872ab842095055922cac3ff3e5a">ASIO_INITFN_RESULT_TYPE</a> (CompletionToken, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>()) defer(ExecutionContext &amp;ctx = 0)</td></tr>
<tr class="memdesc:a537a9872ab842095055922cac3ff3e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <br /></td></tr>
<tr class="memitem:ac4859eacaf587bf46901d9597e139f6c" id="r_ac4859eacaf587bf46901d9597e139f6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ab54d01ea04afeb9a8b39cfac467656b7">ASIO_DECL</a> <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1error__category.html">error_category</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4859eacaf587bf46901d9597e139f6c">system_category</a> ()</td></tr>
<tr class="memdesc:ac4859eacaf587bf46901d9597e139f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error category used for the system errors produced by asio.  <br /></td></tr>
<tr class="memitem:a14f798e0ac350e7b7359337982aa7b36" id="r_a14f798e0ac350e7b7359337982aa7b36"><td class="memTemplParams" colspan="2">template&lt;typename Elem, typename Traits&gt; </td></tr>
<tr class="memitem:a14f798e0ac350e7b7359337982aa7b36 template"><td class="memItemLeft" align="right" valign="top">std::basic_ostream&lt; Elem, Traits &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14f798e0ac350e7b7359337982aa7b36">operator&lt;&lt;</a> (std::basic_ostream&lt; Elem, Traits &gt; &amp;os, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a14f798e0ac350e7b7359337982aa7b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output an error code.  <br /></td></tr>
<tr class="memitem:a43c69d055116813ff29daebb22bde7e6" id="r_a43c69d055116813ff29daebb22bde7e6"><td class="memTemplParams" colspan="2">template&lt;typename Service&gt; </td></tr>
<tr class="memitem:a43c69d055116813ff29daebb22bde7e6 template"><td class="memItemLeft" align="right" valign="top">Service &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43c69d055116813ff29daebb22bde7e6">use_service</a> (<a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;e)</td></tr>
<tr class="memitem:a9947a7e740f8bad04a2307b31fa03919" id="r_a9947a7e740f8bad04a2307b31fa03919"><td class="memTemplParams" colspan="2">template&lt;typename Service&gt; </td></tr>
<tr class="memitem:a9947a7e740f8bad04a2307b31fa03919 template"><td class="memItemLeft" align="right" valign="top">Service &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9947a7e740f8bad04a2307b31fa03919">use_service</a> (<a class="el" href="classasio_1_1io__context.html">io_context</a> &amp;ioc)</td></tr>
<tr class="memitem:a372038fbe1978742fe65b07a1b2fbcd9" id="r_a372038fbe1978742fe65b07a1b2fbcd9"><td class="memTemplParams" colspan="2">template&lt;typename Service&gt; </td></tr>
<tr class="memitem:a372038fbe1978742fe65b07a1b2fbcd9 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a372038fbe1978742fe65b07a1b2fbcd9">add_service</a> (<a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;e, Service *svc)</td></tr>
<tr class="memitem:acd7c8e7883fd13e8f1c357d788817ec6" id="r_acd7c8e7883fd13e8f1c357d788817ec6"><td class="memTemplParams" colspan="2">template&lt;typename Service&gt; </td></tr>
<tr class="memitem:acd7c8e7883fd13e8f1c357d788817ec6 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd7c8e7883fd13e8f1c357d788817ec6">has_service</a> (<a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;e)</td></tr>
<tr class="memitem:aaf777e5b849da59fc6cc5ecf01167171" id="r_aaf777e5b849da59fc6cc5ecf01167171"><td class="memTemplParams" colspan="2">template&lt;typename Executor&gt; </td></tr>
<tr class="memitem:aaf777e5b849da59fc6cc5ecf01167171 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; Executor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf777e5b849da59fc6cc5ecf01167171">make_work_guard</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Executor &amp;ex, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:aaf777e5b849da59fc6cc5ecf01167171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object.  <br /></td></tr>
<tr class="memitem:aff6c8de3eb46ade8c78befe0fa08d14e" id="r_aff6c8de3eb46ade8c78befe0fa08d14e"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext&gt; </td></tr>
<tr class="memitem:aff6c8de3eb46ade8c78befe0fa08d14e template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; typename ExecutionContext::executor_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff6c8de3eb46ade8c78befe0fa08d14e">make_work_guard</a> (ExecutionContext &amp;ctx, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:aff6c8de3eb46ade8c78befe0fa08d14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object.  <br /></td></tr>
<tr class="memitem:a6f19b548e6446b7bc7a3506ba14f5bff" id="r_a6f19b548e6446b7bc7a3506ba14f5bff"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>&gt; </td></tr>
<tr class="memitem:a6f19b548e6446b7bc7a3506ba14f5bff template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; typename <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f19b548e6446b7bc7a3506ba14f5bff">make_work_guard</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &amp;t, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!is_convertible&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:a6f19b548e6446b7bc7a3506ba14f5bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object.  <br /></td></tr>
<tr class="memitem:a87285e2871b719f7218ed313878f707b" id="r_a87285e2871b719f7218ed313878f707b"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>, typename Executor&gt; </td></tr>
<tr class="memitem:a87285e2871b719f7218ed313878f707b template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; typename <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>, Executor &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87285e2871b719f7218ed313878f707b">make_work_guard</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &amp;t, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Executor &amp;ex, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:a87285e2871b719f7218ed313878f707b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object.  <br /></td></tr>
<tr class="memitem:a607caf8c766a5c57958ab9f033d34d0b" id="r_a607caf8c766a5c57958ab9f033d34d0b"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>, typename ExecutionContext&gt; </td></tr>
<tr class="memitem:a607caf8c766a5c57958ab9f033d34d0b template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; typename <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>, typename ExecutionContext::executor_type &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a607caf8c766a5c57958ab9f033d34d0b">make_work_guard</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &amp;t, ExecutionContext &amp;ctx, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!is_convertible&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:a607caf8c766a5c57958ab9f033d34d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object.  <br /></td></tr>
<tr class="memitem:ace79295fdc53d94dd93a55901764d2d9" id="r_ace79295fdc53d94dd93a55901764d2d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ab54d01ea04afeb9a8b39cfac467656b7">ASIO_DECL</a> <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace79295fdc53d94dd93a55901764d2d9">asio_handler_allocate</a> (std::size_t size,...)</td></tr>
<tr class="memdesc:ace79295fdc53d94dd93a55901764d2d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default allocation function for handlers.  <br /></td></tr>
<tr class="memitem:a2a2adf6e52107fa4e93d30d053f1d417" id="r_a2a2adf6e52107fa4e93d30d053f1d417"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#ab54d01ea04afeb9a8b39cfac467656b7">ASIO_DECL</a> <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a2adf6e52107fa4e93d30d053f1d417">asio_handler_deallocate</a> (<a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a> *pointer, std::size_t size,...)</td></tr>
<tr class="memdesc:a2a2adf6e52107fa4e93d30d053f1d417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default deallocation function for handlers.  <br /></td></tr>
<tr class="memitem:a7613e3b437b2491c154e056f1a26668f" id="r_a7613e3b437b2491c154e056f1a26668f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7613e3b437b2491c154e056f1a26668f">asio_handler_is_continuation</a> (...)</td></tr>
<tr class="memdesc:a7613e3b437b2491c154e056f1a26668f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default continuation function for handlers.  <br /></td></tr>
<tr class="memitem:a91c8e702816572ffb691ca3f60a27871" id="r_a91c8e702816572ffb691ca3f60a27871"><td class="memTemplParams" colspan="2">template&lt;typename Function&gt; </td></tr>
<tr class="memitem:a91c8e702816572ffb691ca3f60a27871 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91c8e702816572ffb691ca3f60a27871">asio_handler_invoke</a> (Function &amp;function,...)</td></tr>
<tr class="memdesc:a91c8e702816572ffb691ca3f60a27871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler invocation hook used for non-const function objects.  <br /></td></tr>
<tr class="memitem:abe759a0b25886ffc0b10ecd98bb69edd" id="r_abe759a0b25886ffc0b10ecd98bb69edd"><td class="memTemplParams" colspan="2">template&lt;typename Function&gt; </td></tr>
<tr class="memitem:abe759a0b25886ffc0b10ecd98bb69edd template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe759a0b25886ffc0b10ecd98bb69edd">asio_handler_invoke</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Function &amp;function,...)</td></tr>
<tr class="memdesc:abe759a0b25886ffc0b10ecd98bb69edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler invocation hook used for const function objects.  <br /></td></tr>
<tr class="memitem:a461c3a69a56dac355730dd6bbddf4ec3" id="r_a461c3a69a56dac355730dd6bbddf4ec3"><td class="memTemplParams" colspan="2">template&lt;typename ReadHandler&gt; </td></tr>
<tr class="memitem:a461c3a69a56dac355730dd6bbddf4ec3 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a461c3a69a56dac355730dd6bbddf4ec3">ASIO_INITFN_RESULT_TYPE</a> (ReadHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) <a class="el" href="classasio_1_1buffered__read__stream.html">buffered_read_stream</a>&lt; Stream &gt;</td></tr>
<tr class="memitem:ae7deb94f1e4f209ff535c2fd9ac06ba8" id="r_ae7deb94f1e4f209ff535c2fd9ac06ba8"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence, typename ReadHandler&gt; </td></tr>
<tr class="memitem:ae7deb94f1e4f209ff535c2fd9ac06ba8 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7deb94f1e4f209ff535c2fd9ac06ba8">ASIO_INITFN_RESULT_TYPE</a> (ReadHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) <a class="el" href="classasio_1_1buffered__read__stream.html">buffered_read_stream</a>&lt; Stream &gt;</td></tr>
<tr class="memitem:a83cc551c7151133f0292ec21e4d08647" id="r_a83cc551c7151133f0292ec21e4d08647"><td class="memTemplParams" colspan="2">template&lt;typename WriteHandler&gt; </td></tr>
<tr class="memitem:a83cc551c7151133f0292ec21e4d08647 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83cc551c7151133f0292ec21e4d08647">ASIO_INITFN_RESULT_TYPE</a> (WriteHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) <a class="el" href="classasio_1_1buffered__write__stream.html">buffered_write_stream</a>&lt; Stream &gt;</td></tr>
<tr class="memitem:aae155d327b1f08e08ca04fad48cf39b9" id="r_aae155d327b1f08e08ca04fad48cf39b9"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence, typename WriteHandler&gt; </td></tr>
<tr class="memitem:aae155d327b1f08e08ca04fad48cf39b9 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae155d327b1f08e08ca04fad48cf39b9">ASIO_INITFN_RESULT_TYPE</a> (WriteHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) <a class="el" href="classasio_1_1buffered__write__stream.html">buffered_write_stream</a>&lt; Stream &gt;</td></tr>
<tr class="memitem:a945cf70a9b0fe077311e197150977d68" id="r_a945cf70a9b0fe077311e197150977d68"><td class="memTemplParams" colspan="2">template&lt;typename Executor, typename F, typename CompletionToken&gt; </td></tr>
<tr class="memitem:a945cf70a9b0fe077311e197150977d68 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a945cf70a9b0fe077311e197150977d68">ASIO_INITFN_RESULT_TYPE</a> (CompletionToken, typename detail::awaitable_signature&lt; typename result_of&lt; F()&gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a>) co_spawn(<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Executor &amp;ex</td></tr>
<tr class="memitem:a2275e25f151718105a35815c6d7f473f" id="r_a2275e25f151718105a35815c6d7f473f"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext, typename F, typename CompletionToken&gt; </td></tr>
<tr class="memitem:a2275e25f151718105a35815c6d7f473f template"><td class="memItemLeft" align="right" valign="top">F CompletionToken <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2275e25f151718105a35815c6d7f473f">ASIO_INITFN_RESULT_TYPE</a> (CompletionToken, typename detail::awaitable_signature&lt; typename result_of&lt; F()&gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a>) co_spawn(ExecutionContext &amp;ctx</td></tr>
<tr class="memitem:acaae9584b5011eb2d929f4ee9d5e91d3" id="r_acaae9584b5011eb2d929f4ee9d5e91d3"><td class="memTemplParams" colspan="2">template&lt;typename Service&gt; </td></tr>
<tr class="memitem:acaae9584b5011eb2d929f4ee9d5e91d3 template"><td class="memItemLeft" align="right" valign="top">Service &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acaae9584b5011eb2d929f4ee9d5e91d3">make_service</a> (<a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;e)</td></tr>
<tr class="memitem:a764e1235aa162478633294d9b20ef3e3" id="r_a764e1235aa162478633294d9b20ef3e3"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a764e1235aa162478633294d9b20ef3e3 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceasio_1_1detail.html#a18464be2f80491d42628366e26c34ff7">detail::io_context_impl</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a764e1235aa162478633294d9b20ef3e3">use_service&lt; detail::io_context_impl &gt;</a> (<a class="el" href="classasio_1_1io__context.html">io_context</a> &amp;ioc)</td></tr>
<tr class="memitem:ac2d04c42f9c62cfdfad22c1e47371afe" id="r_ac2d04c42f9c62cfdfad22c1e47371afe"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename MutableBufferSequence, typename CompletionCondition&gt; </td></tr>
<tr class="memitem:ac2d04c42f9c62cfdfad22c1e47371afe template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2d04c42f9c62cfdfad22c1e47371afe">read</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence &amp;<a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, CompletionCondition <a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:ac2d04c42f9c62cfdfad22c1e47371afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="memitem:a6139ae5217bdda60c94939c37f6971b6" id="r_a6139ae5217bdda60c94939c37f6971b6"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename MutableBufferSequence&gt; </td></tr>
<tr class="memitem:a6139ae5217bdda60c94939c37f6971b6 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6139ae5217bdda60c94939c37f6971b6">read</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence &amp;<a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:a6139ae5217bdda60c94939c37f6971b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="memitem:afff9ff31b97492c326e599398599366b" id="r_afff9ff31b97492c326e599398599366b"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename MutableBufferSequence&gt; </td></tr>
<tr class="memitem:afff9ff31b97492c326e599398599366b template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afff9ff31b97492c326e599398599366b">read</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence &amp;<a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:afff9ff31b97492c326e599398599366b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="memitem:ae08771e9fbf8a4e92e8b4d2cf801a428" id="r_ae08771e9fbf8a4e92e8b4d2cf801a428"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename MutableBufferSequence, typename CompletionCondition&gt; </td></tr>
<tr class="memitem:ae08771e9fbf8a4e92e8b4d2cf801a428 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae08771e9fbf8a4e92e8b4d2cf801a428">read</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence &amp;<a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, CompletionCondition <a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:ae08771e9fbf8a4e92e8b4d2cf801a428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="memitem:aaa22b8532143e0b27c0af29d69cc1d15" id="r_aaa22b8532143e0b27c0af29d69cc1d15"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename DynamicBuffer_v1, typename CompletionCondition&gt; </td></tr>
<tr class="memitem:aaa22b8532143e0b27c0af29d69cc1d15 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa22b8532143e0b27c0af29d69cc1d15">read</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1) <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, CompletionCondition <a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:aaa22b8532143e0b27c0af29d69cc1d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="memitem:a8fee811dd4da39d29632f7eff041b6fc" id="r_a8fee811dd4da39d29632f7eff041b6fc"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename DynamicBuffer_v1&gt; </td></tr>
<tr class="memitem:a8fee811dd4da39d29632f7eff041b6fc template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fee811dd4da39d29632f7eff041b6fc">read</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1) <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:a8fee811dd4da39d29632f7eff041b6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="memitem:a762fc24a5be2db44f5b4095af618b8b9" id="r_a762fc24a5be2db44f5b4095af618b8b9"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename DynamicBuffer_v1&gt; </td></tr>
<tr class="memitem:a762fc24a5be2db44f5b4095af618b8b9 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a762fc24a5be2db44f5b4095af618b8b9">read</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1) <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:a762fc24a5be2db44f5b4095af618b8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="memitem:ae2bc01a3cfbb23d492c75dc6414d24f1" id="r_ae2bc01a3cfbb23d492c75dc6414d24f1"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename DynamicBuffer_v1, typename CompletionCondition&gt; </td></tr>
<tr class="memitem:ae2bc01a3cfbb23d492c75dc6414d24f1 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2bc01a3cfbb23d492c75dc6414d24f1">read</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1) <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, CompletionCondition <a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:ae2bc01a3cfbb23d492c75dc6414d24f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="memitem:a6038b695e95ef357b104f35a28edfe3d" id="r_a6038b695e95ef357b104f35a28edfe3d"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename Allocator, typename CompletionCondition&gt; </td></tr>
<tr class="memitem:a6038b695e95ef357b104f35a28edfe3d template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6038b695e95ef357b104f35a28edfe3d">read</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, CompletionCondition <a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a6038b695e95ef357b104f35a28edfe3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="memitem:aaeda9d140628ff399cbe4a076cb15cee" id="r_aaeda9d140628ff399cbe4a076cb15cee"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename Allocator&gt; </td></tr>
<tr class="memitem:aaeda9d140628ff399cbe4a076cb15cee template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaeda9d140628ff399cbe4a076cb15cee">read</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>)</td></tr>
<tr class="memdesc:aaeda9d140628ff399cbe4a076cb15cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="memitem:abc0bc3183df1291c7b2a35ec30d5428c" id="r_abc0bc3183df1291c7b2a35ec30d5428c"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename Allocator&gt; </td></tr>
<tr class="memitem:abc0bc3183df1291c7b2a35ec30d5428c template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc0bc3183df1291c7b2a35ec30d5428c">read</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:abc0bc3183df1291c7b2a35ec30d5428c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="memitem:aeadfb55ae835155abb8b6dc11a063b54" id="r_aeadfb55ae835155abb8b6dc11a063b54"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename Allocator, typename CompletionCondition&gt; </td></tr>
<tr class="memitem:aeadfb55ae835155abb8b6dc11a063b54 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeadfb55ae835155abb8b6dc11a063b54">read</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, CompletionCondition <a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>)</td></tr>
<tr class="memdesc:aeadfb55ae835155abb8b6dc11a063b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="memitem:acb17bc14c1e92bc3209991b706b6495d" id="r_acb17bc14c1e92bc3209991b706b6495d"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename DynamicBuffer_v2, typename CompletionCondition&gt; </td></tr>
<tr class="memitem:acb17bc14c1e92bc3209991b706b6495d template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb17bc14c1e92bc3209991b706b6495d">read</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, DynamicBuffer_v2 <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, CompletionCondition <a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:acb17bc14c1e92bc3209991b706b6495d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="memitem:a5588d6732ebb692217a10f639db11f0e" id="r_a5588d6732ebb692217a10f639db11f0e"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename DynamicBuffer_v2&gt; </td></tr>
<tr class="memitem:a5588d6732ebb692217a10f639db11f0e template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5588d6732ebb692217a10f639db11f0e">read</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, DynamicBuffer_v2 <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:a5588d6732ebb692217a10f639db11f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="memitem:a2cb13f54d15172a2e93b73c1ea9fb1b5" id="r_a2cb13f54d15172a2e93b73c1ea9fb1b5"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename DynamicBuffer_v2&gt; </td></tr>
<tr class="memitem:a2cb13f54d15172a2e93b73c1ea9fb1b5 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cb13f54d15172a2e93b73c1ea9fb1b5">read</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, DynamicBuffer_v2 <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:a2cb13f54d15172a2e93b73c1ea9fb1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="memitem:a1a384fd2010fdaf4d6047b4426d3199f" id="r_a1a384fd2010fdaf4d6047b4426d3199f"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename DynamicBuffer_v2, typename CompletionCondition&gt; </td></tr>
<tr class="memitem:a1a384fd2010fdaf4d6047b4426d3199f template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a384fd2010fdaf4d6047b4426d3199f">read</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, DynamicBuffer_v2 <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, CompletionCondition <a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:a1a384fd2010fdaf4d6047b4426d3199f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <br /></td></tr>
<tr class="memitem:ab321259782b3683c80f33eb1050a3251" id="r_ab321259782b3683c80f33eb1050a3251"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream, typename MutableBufferSequence, typename CompletionCondition, typename ReadHandler&gt; </td></tr>
<tr class="memitem:ab321259782b3683c80f33eb1050a3251 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab321259782b3683c80f33eb1050a3251">ASIO_INITFN_RESULT_TYPE</a> (ReadHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_read(AsyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a></td></tr>
<tr class="memitem:aec3a9e489c8dd295db16f2d8f58fa528" id="r_aec3a9e489c8dd295db16f2d8f58fa528"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence CompletionCondition&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec3a9e489c8dd295db16f2d8f58fa528">ASIO_MOVE_ARG</a> (ReadHandler) handler</td></tr>
<tr class="memitem:a7c651c815405ce015b8ff36ca95cbfae" id="r_a7c651c815405ce015b8ff36ca95cbfae"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream, typename MutableBufferSequence, typename ReadHandler&gt; </td></tr>
<tr class="memitem:a7c651c815405ce015b8ff36ca95cbfae template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence CompletionCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c651c815405ce015b8ff36ca95cbfae">ASIO_INITFN_RESULT_TYPE</a> (ReadHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_read(AsyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a></td></tr>
<tr class="memitem:a3d4f5c52cc8c1c5d16fc7bf7e0f75c4b" id="r_a3d4f5c52cc8c1c5d16fc7bf7e0f75c4b"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream, typename DynamicBuffer_v1, typename ReadHandler&gt; </td></tr>
<tr class="memitem:a3d4f5c52cc8c1c5d16fc7bf7e0f75c4b template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d4f5c52cc8c1c5d16fc7bf7e0f75c4b">ASIO_INITFN_RESULT_TYPE</a> (ReadHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_read(AsyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a></td></tr>
<tr class="memitem:a8d01fccd641197c92ea3430755174bc7" id="r_a8d01fccd641197c92ea3430755174bc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d01fccd641197c92ea3430755174bc7">ASIO_MOVE_ARG</a> (DynamicBuffer_v1) <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a></td></tr>
<tr class="memitem:a0f6dc45f82474ab7cfd43ccd969cbdb6" id="r_a0f6dc45f82474ab7cfd43ccd969cbdb6"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream, typename DynamicBuffer_v1, typename CompletionCondition, typename ReadHandler&gt; </td></tr>
<tr class="memitem:a0f6dc45f82474ab7cfd43ccd969cbdb6 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f6dc45f82474ab7cfd43ccd969cbdb6">ASIO_INITFN_RESULT_TYPE</a> (ReadHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_read(AsyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a></td></tr>
<tr class="memitem:a739600dc1b0a8e68342342f7a5ecfe2c" id="r_a739600dc1b0a8e68342342f7a5ecfe2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> CompletionCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a739600dc1b0a8e68342342f7a5ecfe2c">async_initiate&lt; ReadHandler, void(asio::error_code, std::size_t)&gt;</a> (<a class="el" href="structasio_1_1detail_1_1initiate__async__read__dynbuf__v1.html">detail::initiate_async_read_dynbuf_v1</a>(), handler, &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="config_8hpp.html#a746be5b8f1f4110bc1e7a836afa08ee4">ASIO_MOVE_CAST</a>(DynamicBuffer_v1)(<a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>), <a class="el" href="config_8hpp.html#a746be5b8f1f4110bc1e7a836afa08ee4">ASIO_MOVE_CAST</a>(CompletionCondition)(<a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>))</td></tr>
<tr class="memitem:a78500cf480d94be08533585b357e5ba5" id="r_a78500cf480d94be08533585b357e5ba5"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream, typename DynamicBuffer_v2, typename CompletionCondition, typename ReadHandler&gt; </td></tr>
<tr class="memitem:a78500cf480d94be08533585b357e5ba5 template"><td class="memItemLeft" align="right" valign="top">DynamicBuffer_v2 <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78500cf480d94be08533585b357e5ba5">ASIO_INITFN_RESULT_TYPE</a> (ReadHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_read(AsyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a> = 0)</td></tr>
<tr class="memitem:a875e856ec74ea026d0c5915f1c43f3f8" id="r_a875e856ec74ea026d0c5915f1c43f3f8"><td class="memItemLeft" align="right" valign="top">DynamicBuffer_v2 <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> DynamicBuffer_v2 CompletionCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *return&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a875e856ec74ea026d0c5915f1c43f3f8">async_initiate&lt; ReadHandler, void(asio::error_code, std::size_t)&gt;</a> (<a class="el" href="structasio_1_1detail_1_1initiate__async__read__dynbuf__v2.html">detail::initiate_async_read_dynbuf_v2</a>(), handler, &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="config_8hpp.html#a746be5b8f1f4110bc1e7a836afa08ee4">ASIO_MOVE_CAST</a>(DynamicBuffer_v2)(<a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>), <a class="el" href="config_8hpp.html#a746be5b8f1f4110bc1e7a836afa08ee4">ASIO_MOVE_CAST</a>(CompletionCondition)(<a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>))</td></tr>
<tr class="memitem:a88604242259da9fb0bacf3c4f0cc0002" id="r_a88604242259da9fb0bacf3c4f0cc0002"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice, typename MutableBufferSequence, typename CompletionCondition&gt; </td></tr>
<tr class="memitem:a88604242259da9fb0bacf3c4f0cc0002 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88604242259da9fb0bacf3c4f0cc0002">read_at</a> (SyncRandomAccessReadDevice &amp;d, <a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a> <a class="el" href="#a8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence &amp;<a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, CompletionCondition <a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memitem:a4ef7a26ff401494d673ad462a3f3f5c0" id="r_a4ef7a26ff401494d673ad462a3f3f5c0"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice, typename MutableBufferSequence&gt; </td></tr>
<tr class="memitem:a4ef7a26ff401494d673ad462a3f3f5c0 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ef7a26ff401494d673ad462a3f3f5c0">read_at</a> (SyncRandomAccessReadDevice &amp;d, <a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a> <a class="el" href="#a8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence &amp;<a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>)</td></tr>
<tr class="memitem:a6587e766e26325457154a5dac2a0b785" id="r_a6587e766e26325457154a5dac2a0b785"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice, typename MutableBufferSequence&gt; </td></tr>
<tr class="memitem:a6587e766e26325457154a5dac2a0b785 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6587e766e26325457154a5dac2a0b785">read_at</a> (SyncRandomAccessReadDevice &amp;d, <a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a> <a class="el" href="#a8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence &amp;<a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memitem:aa16ebd52ad98e521ea4b75676d4db9fd" id="r_aa16ebd52ad98e521ea4b75676d4db9fd"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice, typename MutableBufferSequence, typename CompletionCondition&gt; </td></tr>
<tr class="memitem:aa16ebd52ad98e521ea4b75676d4db9fd template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa16ebd52ad98e521ea4b75676d4db9fd">read_at</a> (SyncRandomAccessReadDevice &amp;d, <a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a> <a class="el" href="#a8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence &amp;<a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, CompletionCondition <a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>)</td></tr>
<tr class="memitem:a926222f6d0bb8a716a17161a1eb725aa" id="r_a926222f6d0bb8a716a17161a1eb725aa"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice, typename Allocator, typename CompletionCondition&gt; </td></tr>
<tr class="memitem:a926222f6d0bb8a716a17161a1eb725aa template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a926222f6d0bb8a716a17161a1eb725aa">read_at</a> (SyncRandomAccessReadDevice &amp;d, <a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a> <a class="el" href="#a8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, CompletionCondition <a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memitem:a301406c670bc22190df6e8628cbf0037" id="r_a301406c670bc22190df6e8628cbf0037"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice, typename Allocator&gt; </td></tr>
<tr class="memitem:a301406c670bc22190df6e8628cbf0037 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a301406c670bc22190df6e8628cbf0037">read_at</a> (SyncRandomAccessReadDevice &amp;d, <a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a> <a class="el" href="#a8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>)</td></tr>
<tr class="memitem:a4511bad893697fc58d379d6e00aa84ff" id="r_a4511bad893697fc58d379d6e00aa84ff"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice, typename Allocator&gt; </td></tr>
<tr class="memitem:a4511bad893697fc58d379d6e00aa84ff template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4511bad893697fc58d379d6e00aa84ff">read_at</a> (SyncRandomAccessReadDevice &amp;d, <a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a> <a class="el" href="#a8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memitem:a0126c00568f324b47c24b494c97ece14" id="r_a0126c00568f324b47c24b494c97ece14"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice, typename Allocator, typename CompletionCondition&gt; </td></tr>
<tr class="memitem:a0126c00568f324b47c24b494c97ece14 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0126c00568f324b47c24b494c97ece14">read_at</a> (SyncRandomAccessReadDevice &amp;d, <a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a> <a class="el" href="#a8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, CompletionCondition <a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>)</td></tr>
<tr class="memitem:a49ff1260194288ac9bcdc6ea0b73807e" id="r_a49ff1260194288ac9bcdc6ea0b73807e"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename DynamicBuffer_v1&gt; </td></tr>
<tr class="memitem:a49ff1260194288ac9bcdc6ea0b73807e template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49ff1260194288ac9bcdc6ea0b73807e">read_until</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1) <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, char <a class="el" href="#a96c8c8ad73c13e29b2214f76069cc05d">delim</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *)</td></tr>
<tr class="memitem:abd583f2d812419d975bbc69d37f1f739" id="r_abd583f2d812419d975bbc69d37f1f739"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename DynamicBuffer_v1&gt; </td></tr>
<tr class="memitem:abd583f2d812419d975bbc69d37f1f739 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd583f2d812419d975bbc69d37f1f739">read_until</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1) <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, char <a class="el" href="#a96c8c8ad73c13e29b2214f76069cc05d">delim</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *)</td></tr>
<tr class="memitem:ada416a8709a21c605687f43882a006ec" id="r_ada416a8709a21c605687f43882a006ec"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename DynamicBuffer_v1&gt; </td></tr>
<tr class="memitem:ada416a8709a21c605687f43882a006ec template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada416a8709a21c605687f43882a006ec">read_until</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1) <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> <a class="el" href="#a96c8c8ad73c13e29b2214f76069cc05d">delim</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *)</td></tr>
<tr class="memitem:a86b246368f232bcadec5ba61eb146ef3" id="r_a86b246368f232bcadec5ba61eb146ef3"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename DynamicBuffer_v1&gt; </td></tr>
<tr class="memitem:a86b246368f232bcadec5ba61eb146ef3 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86b246368f232bcadec5ba61eb146ef3">read_until</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1) <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> <a class="el" href="#a96c8c8ad73c13e29b2214f76069cc05d">delim</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *)</td></tr>
<tr class="memitem:a129234c517df519e5ffec9fabc5bc1a8" id="r_a129234c517df519e5ffec9fabc5bc1a8"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename DynamicBuffer_v1, typename MatchCondition&gt; </td></tr>
<tr class="memitem:a129234c517df519e5ffec9fabc5bc1a8 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a129234c517df519e5ffec9fabc5bc1a8">read_until</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1) <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, MatchCondition <a class="el" href="#a0b30afc4cf6e545180cda990770c535e">match_condition</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;<a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *)</td></tr>
<tr class="memitem:a5d6f8bd4b1ac0fdf5937ab513f38eebf" id="r_a5d6f8bd4b1ac0fdf5937ab513f38eebf"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename DynamicBuffer_v1, typename MatchCondition&gt; </td></tr>
<tr class="memitem:a5d6f8bd4b1ac0fdf5937ab513f38eebf template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d6f8bd4b1ac0fdf5937ab513f38eebf">read_until</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1) <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, MatchCondition <a class="el" href="#a0b30afc4cf6e545180cda990770c535e">match_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;<a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *)</td></tr>
<tr class="memitem:a1aae2baa82596a6a9ad320e80b016006" id="r_a1aae2baa82596a6a9ad320e80b016006"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename Allocator&gt; </td></tr>
<tr class="memitem:a1aae2baa82596a6a9ad320e80b016006 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1aae2baa82596a6a9ad320e80b016006">read_until</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, char <a class="el" href="#a96c8c8ad73c13e29b2214f76069cc05d">delim</a>)</td></tr>
<tr class="memdesc:a1aae2baa82596a6a9ad320e80b016006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <br /></td></tr>
<tr class="memitem:ab9d265cc5b757caf9c9a602da2d6a3e5" id="r_ab9d265cc5b757caf9c9a602da2d6a3e5"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename Allocator&gt; </td></tr>
<tr class="memitem:ab9d265cc5b757caf9c9a602da2d6a3e5 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9d265cc5b757caf9c9a602da2d6a3e5">read_until</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, char <a class="el" href="#a96c8c8ad73c13e29b2214f76069cc05d">delim</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ab9d265cc5b757caf9c9a602da2d6a3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <br /></td></tr>
<tr class="memitem:a03a433d903eae4dd097bc2c55efbf1ee" id="r_a03a433d903eae4dd097bc2c55efbf1ee"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename Allocator&gt; </td></tr>
<tr class="memitem:a03a433d903eae4dd097bc2c55efbf1ee template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03a433d903eae4dd097bc2c55efbf1ee">read_until</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> <a class="el" href="#a96c8c8ad73c13e29b2214f76069cc05d">delim</a>)</td></tr>
<tr class="memdesc:a03a433d903eae4dd097bc2c55efbf1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <br /></td></tr>
<tr class="memitem:a78faf8cf08d47515162de95b18b0a860" id="r_a78faf8cf08d47515162de95b18b0a860"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename Allocator&gt; </td></tr>
<tr class="memitem:a78faf8cf08d47515162de95b18b0a860 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78faf8cf08d47515162de95b18b0a860">read_until</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> <a class="el" href="#a96c8c8ad73c13e29b2214f76069cc05d">delim</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a78faf8cf08d47515162de95b18b0a860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <br /></td></tr>
<tr class="memitem:a5aa4b441eca98c82a144cb9a3c625db4" id="r_a5aa4b441eca98c82a144cb9a3c625db4"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename Allocator, typename MatchCondition&gt; </td></tr>
<tr class="memitem:a5aa4b441eca98c82a144cb9a3c625db4 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5aa4b441eca98c82a144cb9a3c625db4">read_until</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, MatchCondition <a class="el" href="#a0b30afc4cf6e545180cda990770c535e">match_condition</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:a5aa4b441eca98c82a144cb9a3c625db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until a function object indicates a match.  <br /></td></tr>
<tr class="memitem:aacb23419d8878f33e469e3f743c738d6" id="r_aacb23419d8878f33e469e3f743c738d6"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename Allocator, typename MatchCondition&gt; </td></tr>
<tr class="memitem:aacb23419d8878f33e469e3f743c738d6 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacb23419d8878f33e469e3f743c738d6">read_until</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, MatchCondition <a class="el" href="#a0b30afc4cf6e545180cda990770c535e">match_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:aacb23419d8878f33e469e3f743c738d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until a function object indicates a match.  <br /></td></tr>
<tr class="memitem:a6570b94e42614f0ba103a44c07928587" id="r_a6570b94e42614f0ba103a44c07928587"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename DynamicBuffer_v2&gt; </td></tr>
<tr class="memitem:a6570b94e42614f0ba103a44c07928587 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6570b94e42614f0ba103a44c07928587">read_until</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, DynamicBuffer_v2 <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, char <a class="el" href="#a96c8c8ad73c13e29b2214f76069cc05d">delim</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *)</td></tr>
<tr class="memitem:a71bd6351279c888f194fe8d226c60d2a" id="r_a71bd6351279c888f194fe8d226c60d2a"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename DynamicBuffer_v2&gt; </td></tr>
<tr class="memitem:a71bd6351279c888f194fe8d226c60d2a template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71bd6351279c888f194fe8d226c60d2a">read_until</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, DynamicBuffer_v2 <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, char <a class="el" href="#a96c8c8ad73c13e29b2214f76069cc05d">delim</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *)</td></tr>
<tr class="memitem:a4fe46a96bdd946fffc1c226444a180f5" id="r_a4fe46a96bdd946fffc1c226444a180f5"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename DynamicBuffer_v2&gt; </td></tr>
<tr class="memitem:a4fe46a96bdd946fffc1c226444a180f5 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fe46a96bdd946fffc1c226444a180f5">read_until</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, DynamicBuffer_v2 <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> <a class="el" href="#a96c8c8ad73c13e29b2214f76069cc05d">delim</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *)</td></tr>
<tr class="memitem:aec29c48526eb7ca6c1b440c8f98726e9" id="r_aec29c48526eb7ca6c1b440c8f98726e9"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename DynamicBuffer_v2&gt; </td></tr>
<tr class="memitem:aec29c48526eb7ca6c1b440c8f98726e9 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec29c48526eb7ca6c1b440c8f98726e9">read_until</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, DynamicBuffer_v2 <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> <a class="el" href="#a96c8c8ad73c13e29b2214f76069cc05d">delim</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *)</td></tr>
<tr class="memitem:a207f1897ca08a4be247c507cf61910b4" id="r_a207f1897ca08a4be247c507cf61910b4"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename DynamicBuffer_v2, typename MatchCondition&gt; </td></tr>
<tr class="memitem:a207f1897ca08a4be247c507cf61910b4 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a207f1897ca08a4be247c507cf61910b4">read_until</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, DynamicBuffer_v2 <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, MatchCondition <a class="el" href="#a0b30afc4cf6e545180cda990770c535e">match_condition</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *)</td></tr>
<tr class="memitem:aa5ddaf76b60c08ea7a53c0d0592c81be" id="r_aa5ddaf76b60c08ea7a53c0d0592c81be"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream, typename DynamicBuffer_v2, typename MatchCondition&gt; </td></tr>
<tr class="memitem:aa5ddaf76b60c08ea7a53c0d0592c81be template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5ddaf76b60c08ea7a53c0d0592c81be">read_until</a> (SyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, DynamicBuffer_v2 <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, MatchCondition <a class="el" href="#a0b30afc4cf6e545180cda990770c535e">match_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *)</td></tr>
<tr class="memitem:a2d26a9486ae3d40639c6a56db6efcd93" id="r_a2d26a9486ae3d40639c6a56db6efcd93"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream, typename Allocator, typename ReadHandler&gt; </td></tr>
<tr class="memitem:a2d26a9486ae3d40639c6a56db6efcd93 template"><td class="memItemLeft" align="right" valign="top">MatchCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;<a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d26a9486ae3d40639c6a56db6efcd93">ASIO_INITFN_RESULT_TYPE</a> (ReadHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_read_until(AsyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a></td></tr>
<tr class="memitem:af6cc8ba57dc5d66607b764c8d28d7ea6" id="r_af6cc8ba57dc5d66607b764c8d28d7ea6"><td class="memTemplParams" colspan="2">template&lt;typename Function&gt; </td></tr>
<tr class="memitem:af6cc8ba57dc5d66607b764c8d28d7ea6 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6cc8ba57dc5d66607b764c8d28d7ea6">spawn</a> (<a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(Function) function, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> boost::coroutines::attributes &amp;attributes)</td></tr>
<tr class="memitem:a070eba0e9e578cd6f164156b0b6e38fc" id="r_a070eba0e9e578cd6f164156b0b6e38fc"><td class="memTemplParams" colspan="2">template&lt;typename Handler, typename Function&gt; </td></tr>
<tr class="memitem:a070eba0e9e578cd6f164156b0b6e38fc template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a070eba0e9e578cd6f164156b0b6e38fc">spawn</a> (<a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(Handler) handler, <a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(Function) function, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> boost::coroutines::attributes &amp;attributes, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; typename decay&lt; Handler &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!is_convertible&lt; Handler &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *)</td></tr>
<tr class="memitem:a96a673b1867f7983c6701bb0dc658c36" id="r_a96a673b1867f7983c6701bb0dc658c36"><td class="memTemplParams" colspan="2">template&lt;typename Handler, typename Function&gt; </td></tr>
<tr class="memitem:a96a673b1867f7983c6701bb0dc658c36 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96a673b1867f7983c6701bb0dc658c36">spawn</a> (<a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; Handler &gt; ctx, <a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(Function) function, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> boost::coroutines::attributes &amp;attributes=boost::coroutines::attributes())</td></tr>
<tr class="memdesc:a96a673b1867f7983c6701bb0dc658c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new stackful coroutine, inheriting the execution context of another.  <br /></td></tr>
<tr class="memitem:adec63d482b774deed5e8ecb37a90ee34" id="r_adec63d482b774deed5e8ecb37a90ee34"><td class="memTemplParams" colspan="2">template&lt;typename Function, typename Executor&gt; </td></tr>
<tr class="memitem:adec63d482b774deed5e8ecb37a90ee34 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adec63d482b774deed5e8ecb37a90ee34">spawn</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Executor &amp;ex, <a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(Function) function, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> boost::coroutines::attributes &amp;attributes=boost::coroutines::attributes(), typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:adec63d482b774deed5e8ecb37a90ee34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new stackful coroutine that executes on a given executor.  <br /></td></tr>
<tr class="memitem:a716b2b7e00ba379e54648ffe56dab229" id="r_a716b2b7e00ba379e54648ffe56dab229"><td class="memTemplParams" colspan="2">template&lt;typename Function, typename Executor&gt; </td></tr>
<tr class="memitem:a716b2b7e00ba379e54648ffe56dab229 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a716b2b7e00ba379e54648ffe56dab229">spawn</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1strand.html">strand</a>&lt; Executor &gt; &amp;ex, <a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(Function) function, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> boost::coroutines::attributes &amp;attributes=boost::coroutines::attributes())</td></tr>
<tr class="memdesc:a716b2b7e00ba379e54648ffe56dab229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new stackful coroutine that executes on a given strand.  <br /></td></tr>
<tr class="memitem:a61e4ad40fada7bc4c374309b8b6bc5b5" id="r_a61e4ad40fada7bc4c374309b8b6bc5b5"><td class="memTemplParams" colspan="2">template&lt;typename Function&gt; </td></tr>
<tr class="memitem:a61e4ad40fada7bc4c374309b8b6bc5b5 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61e4ad40fada7bc4c374309b8b6bc5b5">spawn</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1io__context_1_1strand.html">asio::io_context::strand</a> &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(Function) function, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> boost::coroutines::attributes &amp;attributes=boost::coroutines::attributes())</td></tr>
<tr class="memdesc:a61e4ad40fada7bc4c374309b8b6bc5b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new stackful coroutine that executes in the context of a strand.  <br /></td></tr>
<tr class="memitem:a864b8c8c72e7cbfce7bc84a378d2a3f3" id="r_a864b8c8c72e7cbfce7bc84a378d2a3f3"><td class="memTemplParams" colspan="2">template&lt;typename Function, typename ExecutionContext&gt; </td></tr>
<tr class="memitem:a864b8c8c72e7cbfce7bc84a378d2a3f3 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a864b8c8c72e7cbfce7bc84a378d2a3f3">spawn</a> (ExecutionContext &amp;ctx, <a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(Function) function, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> boost::coroutines::attributes &amp;attributes=boost::coroutines::attributes(), typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:a864b8c8c72e7cbfce7bc84a378d2a3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new stackful coroutine that executes on a given execution context.  <br /></td></tr>
<tr class="memitem:a0836b66664a36ebc7ca74f0441fc4188" id="r_a0836b66664a36ebc7ca74f0441fc4188"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream, typename ConstBufferSequence, typename CompletionCondition&gt; </td></tr>
<tr class="memitem:a0836b66664a36ebc7ca74f0441fc4188 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0836b66664a36ebc7ca74f0441fc4188">write</a> (SyncWriteStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence &amp;<a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, CompletionCondition <a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:a0836b66664a36ebc7ca74f0441fc4188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <br /></td></tr>
<tr class="memitem:a700a5a376b28c391c478707a8dec6b83" id="r_a700a5a376b28c391c478707a8dec6b83"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream, typename ConstBufferSequence&gt; </td></tr>
<tr class="memitem:a700a5a376b28c391c478707a8dec6b83 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a700a5a376b28c391c478707a8dec6b83">write</a> (SyncWriteStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence &amp;<a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:a700a5a376b28c391c478707a8dec6b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <br /></td></tr>
<tr class="memitem:a76bea26a365e2db58363090c667ae763" id="r_a76bea26a365e2db58363090c667ae763"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream, typename ConstBufferSequence&gt; </td></tr>
<tr class="memitem:a76bea26a365e2db58363090c667ae763 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76bea26a365e2db58363090c667ae763">write</a> (SyncWriteStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence &amp;<a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:a76bea26a365e2db58363090c667ae763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <br /></td></tr>
<tr class="memitem:a8386d6d624c52cc30eb22aa0021c66eb" id="r_a8386d6d624c52cc30eb22aa0021c66eb"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream, typename ConstBufferSequence, typename CompletionCondition&gt; </td></tr>
<tr class="memitem:a8386d6d624c52cc30eb22aa0021c66eb template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8386d6d624c52cc30eb22aa0021c66eb">write</a> (SyncWriteStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence &amp;<a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, CompletionCondition <a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:a8386d6d624c52cc30eb22aa0021c66eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <br /></td></tr>
<tr class="memitem:abf7e8df8ce570b07f32acd0a3cc0c4e3" id="r_abf7e8df8ce570b07f32acd0a3cc0c4e3"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream, typename DynamicBuffer_v1, typename CompletionCondition&gt; </td></tr>
<tr class="memitem:abf7e8df8ce570b07f32acd0a3cc0c4e3 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf7e8df8ce570b07f32acd0a3cc0c4e3">write</a> (SyncWriteStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1) <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, CompletionCondition <a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:abf7e8df8ce570b07f32acd0a3cc0c4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <br /></td></tr>
<tr class="memitem:a3a85a48308f812d037cd64c368e69329" id="r_a3a85a48308f812d037cd64c368e69329"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream, typename DynamicBuffer_v1&gt; </td></tr>
<tr class="memitem:a3a85a48308f812d037cd64c368e69329 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a85a48308f812d037cd64c368e69329">write</a> (SyncWriteStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1) <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:a3a85a48308f812d037cd64c368e69329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <br /></td></tr>
<tr class="memitem:a038641314390c2f3f4164457eecdf0ee" id="r_a038641314390c2f3f4164457eecdf0ee"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream, typename DynamicBuffer_v1&gt; </td></tr>
<tr class="memitem:a038641314390c2f3f4164457eecdf0ee template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a038641314390c2f3f4164457eecdf0ee">write</a> (SyncWriteStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1) <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:a038641314390c2f3f4164457eecdf0ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <br /></td></tr>
<tr class="memitem:ad0706de491271959e2b811fc011b2c53" id="r_ad0706de491271959e2b811fc011b2c53"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream, typename DynamicBuffer_v1, typename CompletionCondition&gt; </td></tr>
<tr class="memitem:ad0706de491271959e2b811fc011b2c53 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0706de491271959e2b811fc011b2c53">write</a> (SyncWriteStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1) <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, CompletionCondition <a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:ad0706de491271959e2b811fc011b2c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <br /></td></tr>
<tr class="memitem:a393e12e427f89cb932c6a2bd800236fb" id="r_a393e12e427f89cb932c6a2bd800236fb"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream, typename Allocator, typename CompletionCondition&gt; </td></tr>
<tr class="memitem:a393e12e427f89cb932c6a2bd800236fb template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a393e12e427f89cb932c6a2bd800236fb">write</a> (SyncWriteStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, CompletionCondition <a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a393e12e427f89cb932c6a2bd800236fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <br /></td></tr>
<tr class="memitem:a85807d13da87adf48b62979f65f41152" id="r_a85807d13da87adf48b62979f65f41152"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream, typename Allocator&gt; </td></tr>
<tr class="memitem:a85807d13da87adf48b62979f65f41152 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85807d13da87adf48b62979f65f41152">write</a> (SyncWriteStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>)</td></tr>
<tr class="memdesc:a85807d13da87adf48b62979f65f41152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <br /></td></tr>
<tr class="memitem:af72f7eddd7d4629ea2e2b7f5b7f355bc" id="r_af72f7eddd7d4629ea2e2b7f5b7f355bc"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream, typename Allocator&gt; </td></tr>
<tr class="memitem:af72f7eddd7d4629ea2e2b7f5b7f355bc template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af72f7eddd7d4629ea2e2b7f5b7f355bc">write</a> (SyncWriteStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:af72f7eddd7d4629ea2e2b7f5b7f355bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <br /></td></tr>
<tr class="memitem:aa80988391fb309ee53cc557d0065550a" id="r_aa80988391fb309ee53cc557d0065550a"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream, typename Allocator, typename CompletionCondition&gt; </td></tr>
<tr class="memitem:aa80988391fb309ee53cc557d0065550a template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa80988391fb309ee53cc557d0065550a">write</a> (SyncWriteStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, CompletionCondition <a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>)</td></tr>
<tr class="memdesc:aa80988391fb309ee53cc557d0065550a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <br /></td></tr>
<tr class="memitem:ad5cee1a0dd40e2cc9a61c6386123edd5" id="r_ad5cee1a0dd40e2cc9a61c6386123edd5"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream, typename DynamicBuffer_v2, typename CompletionCondition&gt; </td></tr>
<tr class="memitem:ad5cee1a0dd40e2cc9a61c6386123edd5 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5cee1a0dd40e2cc9a61c6386123edd5">write</a> (SyncWriteStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, DynamicBuffer_v2 <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, CompletionCondition <a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:ad5cee1a0dd40e2cc9a61c6386123edd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <br /></td></tr>
<tr class="memitem:a2e11be64adb48357a70afd0970b8b89f" id="r_a2e11be64adb48357a70afd0970b8b89f"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream, typename DynamicBuffer_v2&gt; </td></tr>
<tr class="memitem:a2e11be64adb48357a70afd0970b8b89f template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e11be64adb48357a70afd0970b8b89f">write</a> (SyncWriteStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, DynamicBuffer_v2 <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:a2e11be64adb48357a70afd0970b8b89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <br /></td></tr>
<tr class="memitem:aa78968a00365a30471fc734c91890491" id="r_aa78968a00365a30471fc734c91890491"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream, typename DynamicBuffer_v2&gt; </td></tr>
<tr class="memitem:aa78968a00365a30471fc734c91890491 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa78968a00365a30471fc734c91890491">write</a> (SyncWriteStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, DynamicBuffer_v2 <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:aa78968a00365a30471fc734c91890491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <br /></td></tr>
<tr class="memitem:a25da8d99e8028b80391f7c683f1cd4b6" id="r_a25da8d99e8028b80391f7c683f1cd4b6"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream, typename DynamicBuffer_v2, typename CompletionCondition&gt; </td></tr>
<tr class="memitem:a25da8d99e8028b80391f7c683f1cd4b6 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25da8d99e8028b80391f7c683f1cd4b6">write</a> (SyncWriteStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, DynamicBuffer_v2 <a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, CompletionCondition <a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:a25da8d99e8028b80391f7c683f1cd4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <br /></td></tr>
<tr class="memitem:a5a1e5b963aeb45f6fc692c4e1a07ed04" id="r_a5a1e5b963aeb45f6fc692c4e1a07ed04"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream, typename ConstBufferSequence, typename CompletionCondition, typename WriteHandler&gt; </td></tr>
<tr class="memitem:a5a1e5b963aeb45f6fc692c4e1a07ed04 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a1e5b963aeb45f6fc692c4e1a07ed04">ASIO_INITFN_RESULT_TYPE</a> (WriteHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_write(AsyncWriteStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a></td></tr>
<tr class="memitem:a7400ce0053da9b64c94220331137bc1d" id="r_a7400ce0053da9b64c94220331137bc1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence CompletionCondition&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7400ce0053da9b64c94220331137bc1d">ASIO_MOVE_ARG</a> (WriteHandler) handler</td></tr>
<tr class="memitem:a5fb5cd33c071fc2aa92ef4f879cf1737" id="r_a5fb5cd33c071fc2aa92ef4f879cf1737"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream, typename ConstBufferSequence, typename WriteHandler&gt; </td></tr>
<tr class="memitem:a5fb5cd33c071fc2aa92ef4f879cf1737 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence CompletionCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fb5cd33c071fc2aa92ef4f879cf1737">ASIO_INITFN_RESULT_TYPE</a> (WriteHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_write(AsyncWriteStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a></td></tr>
<tr class="memitem:a7b61e40209cec169c7de5fafc16a6f9c" id="r_a7b61e40209cec169c7de5fafc16a6f9c"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream, typename DynamicBuffer_v1, typename WriteHandler&gt; </td></tr>
<tr class="memitem:a7b61e40209cec169c7de5fafc16a6f9c template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b61e40209cec169c7de5fafc16a6f9c">ASIO_INITFN_RESULT_TYPE</a> (WriteHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_write(AsyncWriteStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a></td></tr>
<tr class="memitem:a6d760c5d46c4deb1082b15e1bb9f48f9" id="r_a6d760c5d46c4deb1082b15e1bb9f48f9"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream, typename DynamicBuffer_v1, typename CompletionCondition, typename WriteHandler&gt; </td></tr>
<tr class="memitem:a6d760c5d46c4deb1082b15e1bb9f48f9 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d760c5d46c4deb1082b15e1bb9f48f9">ASIO_INITFN_RESULT_TYPE</a> (WriteHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_write(AsyncWriteStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a></td></tr>
<tr class="memitem:ae63086926973ee7bc0f93da88ce6c78b" id="r_ae63086926973ee7bc0f93da88ce6c78b"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream, typename Allocator, typename WriteHandler&gt; </td></tr>
<tr class="memitem:ae63086926973ee7bc0f93da88ce6c78b template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> CompletionCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae63086926973ee7bc0f93da88ce6c78b">ASIO_INITFN_RESULT_TYPE</a> (WriteHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_write(AsyncWriteStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a></td></tr>
<tr class="memitem:ad23b95ef832ce39d3633a273f59b905b" id="r_ad23b95ef832ce39d3633a273f59b905b"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream, typename DynamicBuffer_v2, typename CompletionCondition, typename WriteHandler&gt; </td></tr>
<tr class="memitem:ad23b95ef832ce39d3633a273f59b905b template"><td class="memItemLeft" align="right" valign="top">DynamicBuffer_v2 <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad23b95ef832ce39d3633a273f59b905b">ASIO_INITFN_RESULT_TYPE</a> (WriteHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_write(AsyncWriteStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a> = 0)</td></tr>
<tr class="memitem:a51133c1e260b8abeeed55646e765fdd6" id="r_a51133c1e260b8abeeed55646e765fdd6"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice, typename ConstBufferSequence, typename CompletionCondition&gt; </td></tr>
<tr class="memitem:a51133c1e260b8abeeed55646e765fdd6 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51133c1e260b8abeeed55646e765fdd6">write_at</a> (SyncRandomAccessWriteDevice &amp;d, <a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a> <a class="el" href="#a8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence &amp;<a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, CompletionCondition <a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a51133c1e260b8abeeed55646e765fdd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data at a specified offset before returning.  <br /></td></tr>
<tr class="memitem:add67a05a29d183782491d14aceec7d41" id="r_add67a05a29d183782491d14aceec7d41"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice, typename ConstBufferSequence&gt; </td></tr>
<tr class="memitem:add67a05a29d183782491d14aceec7d41 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add67a05a29d183782491d14aceec7d41">write_at</a> (SyncRandomAccessWriteDevice &amp;d, <a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a> <a class="el" href="#a8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence &amp;<a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>)</td></tr>
<tr class="memdesc:add67a05a29d183782491d14aceec7d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data at the specified offset before returning.  <br /></td></tr>
<tr class="memitem:a8c1abcb5870505ea2a0c524a59638da0" id="r_a8c1abcb5870505ea2a0c524a59638da0"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice, typename ConstBufferSequence&gt; </td></tr>
<tr class="memitem:a8c1abcb5870505ea2a0c524a59638da0 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c1abcb5870505ea2a0c524a59638da0">write_at</a> (SyncRandomAccessWriteDevice &amp;d, <a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a> <a class="el" href="#a8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence &amp;<a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a8c1abcb5870505ea2a0c524a59638da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data at the specified offset before returning.  <br /></td></tr>
<tr class="memitem:a3e6b2f5dd13f4273695fbf0cdec0314a" id="r_a3e6b2f5dd13f4273695fbf0cdec0314a"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice, typename ConstBufferSequence, typename CompletionCondition&gt; </td></tr>
<tr class="memitem:a3e6b2f5dd13f4273695fbf0cdec0314a template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e6b2f5dd13f4273695fbf0cdec0314a">write_at</a> (SyncRandomAccessWriteDevice &amp;d, <a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a> <a class="el" href="#a8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence &amp;<a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>, CompletionCondition <a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>)</td></tr>
<tr class="memdesc:a3e6b2f5dd13f4273695fbf0cdec0314a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data at a specified offset before returning.  <br /></td></tr>
<tr class="memitem:a431966af634f0701ceac7f54fc1b0371" id="r_a431966af634f0701ceac7f54fc1b0371"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice, typename Allocator, typename CompletionCondition&gt; </td></tr>
<tr class="memitem:a431966af634f0701ceac7f54fc1b0371 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a431966af634f0701ceac7f54fc1b0371">write_at</a> (SyncRandomAccessWriteDevice &amp;d, <a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a> <a class="el" href="#a8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, CompletionCondition <a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a431966af634f0701ceac7f54fc1b0371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data at a specified offset before returning.  <br /></td></tr>
<tr class="memitem:a1db1f75a907c17918092b41f2f242104" id="r_a1db1f75a907c17918092b41f2f242104"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice, typename Allocator&gt; </td></tr>
<tr class="memitem:a1db1f75a907c17918092b41f2f242104 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1db1f75a907c17918092b41f2f242104">write_at</a> (SyncRandomAccessWriteDevice &amp;d, <a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a> <a class="el" href="#a8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>)</td></tr>
<tr class="memdesc:a1db1f75a907c17918092b41f2f242104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data at the specified offset before returning.  <br /></td></tr>
<tr class="memitem:aa6f42435acf937c35ee4c81af44ee6ce" id="r_aa6f42435acf937c35ee4c81af44ee6ce"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice, typename Allocator&gt; </td></tr>
<tr class="memitem:aa6f42435acf937c35ee4c81af44ee6ce template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6f42435acf937c35ee4c81af44ee6ce">write_at</a> (SyncRandomAccessWriteDevice &amp;d, <a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a> <a class="el" href="#a8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:aa6f42435acf937c35ee4c81af44ee6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data at the specified offset before returning.  <br /></td></tr>
<tr class="memitem:a2e23f5418309ba130d75f6757b7b8e15" id="r_a2e23f5418309ba130d75f6757b7b8e15"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice, typename Allocator, typename CompletionCondition&gt; </td></tr>
<tr class="memitem:a2e23f5418309ba130d75f6757b7b8e15 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e23f5418309ba130d75f6757b7b8e15">write_at</a> (SyncRandomAccessWriteDevice &amp;d, <a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a> <a class="el" href="#a8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, CompletionCondition <a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>)</td></tr>
<tr class="memdesc:a2e23f5418309ba130d75f6757b7b8e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data at a specified offset before returning.  <br /></td></tr>
<tr class="memitem:a729111d0a4d1340520c4b141a6901f81" id="r_a729111d0a4d1340520c4b141a6901f81"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream, typename MutableBufferSequence, typename CompletionCondition, typename ReadHandler&gt; </td></tr>
<tr class="memitem:a729111d0a4d1340520c4b141a6901f81 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a729111d0a4d1340520c4b141a6901f81">ASIO_INITFN_RESULT_TYPE</a> (ReadHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_read(AsyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a></td></tr>
<tr class="memitem:a11a815252341210b54be7122bad17957" id="r_a11a815252341210b54be7122bad17957"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream, typename DynamicBuffer_v1, typename ReadHandler&gt; </td></tr>
<tr class="memitem:a11a815252341210b54be7122bad17957 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence CompletionCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11a815252341210b54be7122bad17957">ASIO_INITFN_RESULT_TYPE</a> (ReadHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_read(AsyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a></td></tr>
<tr class="memitem:a642f96a619ad598a51010dfe5aaeadc1" id="r_a642f96a619ad598a51010dfe5aaeadc1"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream, typename DynamicBuffer_v1, typename CompletionCondition, typename ReadHandler&gt; </td></tr>
<tr class="memitem:a642f96a619ad598a51010dfe5aaeadc1 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence CompletionCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a642f96a619ad598a51010dfe5aaeadc1">ASIO_INITFN_RESULT_TYPE</a> (ReadHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_read(AsyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a></td></tr>
<tr class="memitem:af6fdb33a7ac7cc9e014aa3f8a83536f0" id="r_af6fdb33a7ac7cc9e014aa3f8a83536f0"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream, typename Allocator, typename ReadHandler&gt; </td></tr>
<tr class="memitem:af6fdb33a7ac7cc9e014aa3f8a83536f0 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence CompletionCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> CompletionCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6fdb33a7ac7cc9e014aa3f8a83536f0">ASIO_INITFN_RESULT_TYPE</a> (ReadHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_read(AsyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a></td></tr>
<tr class="memitem:acb346160884658b39dab4802831886f4" id="r_acb346160884658b39dab4802831886f4"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream, typename DynamicBuffer_v1, typename ReadHandler&gt; </td></tr>
<tr class="memitem:acb346160884658b39dab4802831886f4 template"><td class="memItemLeft" align="right" valign="top">char <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb346160884658b39dab4802831886f4">ASIO_INITFN_RESULT_TYPE</a> (ReadHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_read_until(AsyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a></td></tr>
<tr class="memitem:a0b2efe1bc8fe9d612b77edc297cd99db" id="r_a0b2efe1bc8fe9d612b77edc297cd99db"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream, typename DynamicBuffer_v1, typename MatchCondition, typename ReadHandler&gt; </td></tr>
<tr class="memitem:a0b2efe1bc8fe9d612b77edc297cd99db template"><td class="memItemLeft" align="right" valign="top">char <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b2efe1bc8fe9d612b77edc297cd99db">ASIO_INITFN_RESULT_TYPE</a> (ReadHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_read_until(AsyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a></td></tr>
<tr class="memitem:a70c358b3e3ab127c34d2ee25808c3732" id="r_a70c358b3e3ab127c34d2ee25808c3732"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream, typename Allocator, typename ReadHandler&gt; </td></tr>
<tr class="memitem:a70c358b3e3ab127c34d2ee25808c3732 template"><td class="memItemLeft" align="right" valign="top">char <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> MatchCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;<a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70c358b3e3ab127c34d2ee25808c3732">ASIO_INITFN_RESULT_TYPE</a> (ReadHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_read_until(AsyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a></td></tr>
<tr class="memitem:a999d80b70224557c1308f4c491225b9a" id="r_a999d80b70224557c1308f4c491225b9a"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream, typename DynamicBuffer_v2, typename ReadHandler&gt; </td></tr>
<tr class="memitem:a999d80b70224557c1308f4c491225b9a template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; MatchCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a999d80b70224557c1308f4c491225b9a">ASIO_INITFN_RESULT_TYPE</a> (ReadHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_read_until(AsyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a></td></tr>
<tr class="memitem:a1f3e0018c2b969146601261c22c37f58" id="r_a1f3e0018c2b969146601261c22c37f58"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream, typename DynamicBuffer_v2, typename ReadHandler&gt; </td></tr>
<tr class="memitem:a1f3e0018c2b969146601261c22c37f58 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; MatchCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> DynamicBuffer_v2 char <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f3e0018c2b969146601261c22c37f58">ASIO_INITFN_RESULT_TYPE</a> (ReadHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_read_until(AsyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a></td></tr>
<tr class="memitem:ac02cf8fe9ef8b1078606fd4eb88087a9" id="r_ac02cf8fe9ef8b1078606fd4eb88087a9"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream, typename DynamicBuffer_v2, typename MatchCondition, typename ReadHandler&gt; </td></tr>
<tr class="memitem:ac02cf8fe9ef8b1078606fd4eb88087a9 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; MatchCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> DynamicBuffer_v2 char <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> DynamicBuffer_v2 <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac02cf8fe9ef8b1078606fd4eb88087a9">ASIO_INITFN_RESULT_TYPE</a> (ReadHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_read_until(AsyncReadStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a></td></tr>
<tr class="memitem:aaf2dc4bc523764497147013d1c3ef4eb" id="r_aaf2dc4bc523764497147013d1c3ef4eb"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken&gt; </td></tr>
<tr class="memitem:aaf2dc4bc523764497147013d1c3ef4eb template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1redirect__error__t.html">redirect_error_t</a>&lt; typename decay&lt; CompletionToken &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf2dc4bc523764497147013d1c3ef4eb">redirect_error</a> (<a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(CompletionToken) completion_token, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:aaf2dc4bc523764497147013d1c3ef4eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a completion token to capture <a class="el" href="classasio_1_1error__code.html" title="Class to represent an error code value.">error_code</a> values to a variable.  <br /></td></tr>
<tr class="memitem:ae690ffe5492a8ebfd0f70ff37a3887bb" id="r_ae690ffe5492a8ebfd0f70ff37a3887bb"><td class="memTemplParams" colspan="2">template&lt;typename Executor&gt; </td></tr>
<tr class="memitem:ae690ffe5492a8ebfd0f70ff37a3887bb template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1strand.html">strand</a>&lt; Executor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae690ffe5492a8ebfd0f70ff37a3887bb">make_strand</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Executor &amp;ex, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:ae690ffe5492a8ebfd0f70ff37a3887bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classasio_1_1strand.html">strand</a> object for an executor.  <br /></td></tr>
<tr class="memitem:a141d6d4a8ef1d17de12863e54fddc87a" id="r_a141d6d4a8ef1d17de12863e54fddc87a"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext&gt; </td></tr>
<tr class="memitem:a141d6d4a8ef1d17de12863e54fddc87a template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1strand.html">strand</a>&lt; typename ExecutionContext::executor_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a141d6d4a8ef1d17de12863e54fddc87a">make_strand</a> (ExecutionContext &amp;ctx, typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *=0)</td></tr>
<tr class="memdesc:a141d6d4a8ef1d17de12863e54fddc87a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classasio_1_1strand.html">strand</a> object for an execution context.  <br /></td></tr>
<tr class="memitem:a9ae1706a25367978314f34e4fe5a3854" id="r_a9ae1706a25367978314f34e4fe5a3854"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream, typename ConstBufferSequence, typename CompletionCondition, typename WriteHandler&gt; </td></tr>
<tr class="memitem:a9ae1706a25367978314f34e4fe5a3854 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ae1706a25367978314f34e4fe5a3854">ASIO_INITFN_RESULT_TYPE</a> (WriteHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_write(AsyncWriteStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a></td></tr>
<tr class="memitem:af1c38825940ed7ac93c5491e8afc69e9" id="r_af1c38825940ed7ac93c5491e8afc69e9"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream, typename DynamicBuffer_v1, typename WriteHandler&gt; </td></tr>
<tr class="memitem:af1c38825940ed7ac93c5491e8afc69e9 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence CompletionCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1c38825940ed7ac93c5491e8afc69e9">ASIO_INITFN_RESULT_TYPE</a> (WriteHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_write(AsyncWriteStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a></td></tr>
<tr class="memitem:a80196643d36e182e957d443d4635427c" id="r_a80196643d36e182e957d443d4635427c"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream, typename DynamicBuffer_v1, typename CompletionCondition, typename WriteHandler&gt; </td></tr>
<tr class="memitem:a80196643d36e182e957d443d4635427c template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence CompletionCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80196643d36e182e957d443d4635427c">ASIO_INITFN_RESULT_TYPE</a> (WriteHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_write(AsyncWriteStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a></td></tr>
<tr class="memitem:a0f4d323747c9d0cb131fe8a4e820719b" id="r_a0f4d323747c9d0cb131fe8a4e820719b"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream, typename Allocator, typename WriteHandler&gt; </td></tr>
<tr class="memitem:a0f4d323747c9d0cb131fe8a4e820719b template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence CompletionCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> CompletionCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f4d323747c9d0cb131fe8a4e820719b">ASIO_INITFN_RESULT_TYPE</a> (WriteHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)) async_write(AsyncWriteStream &amp;<a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a></td></tr>
<tr class="memitem:a82de52bf47a8238c3b66e08f7b008d70" id="r_a82de52bf47a8238c3b66e08f7b008d70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1mutable__buffer.html#a82de52bf47a8238c3b66e08f7b008d70">operator+</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, std::size_t n) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:a82de52bf47a8238c3b66e08f7b008d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that is offset from the start of another.  <br /></td></tr>
<tr class="memitem:ac05e284fd2f83d88248118e2451f3ce5" id="r_ac05e284fd2f83d88248118e2451f3ce5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1mutable__buffer.html#ac05e284fd2f83d88248118e2451f3ce5">operator+</a> (std::size_t n, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:ac05e284fd2f83d88248118e2451f3ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that is offset from the start of another.  <br /></td></tr>
<tr class="memitem:a75775d8aed2e629c459b5de8b3e1bc45" id="r_a75775d8aed2e629c459b5de8b3e1bc45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1const__buffer.html#a75775d8aed2e629c459b5de8b3e1bc45">operator+</a> (<a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, std::size_t n) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:a75775d8aed2e629c459b5de8b3e1bc45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that is offset from the start of another.  <br /></td></tr>
<tr class="memitem:a9799613c5303a7aef60f508396c15758" id="r_a9799613c5303a7aef60f508396c15758"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1const__buffer.html#a9799613c5303a7aef60f508396c15758">operator+</a> (std::size_t n, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;<a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>) <a class="el" href="config_8hpp.html#aea8b7328492188751fb2f07bd77113ad">ASIO_NOEXCEPT</a></td></tr>
<tr class="memdesc:a9799613c5303a7aef60f508396c15758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that is offset from the start of another.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a551ec1a519b15e013e05cb1fe1c4b362" id="r_a551ec1a519b15e013e05cb1fe1c4b362"><td class="memItemLeft" align="right" valign="top">Executor &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a></td></tr>
<tr class="memitem:aba818fe3267fb794f98329cd5a75aee1" id="r_aba818fe3267fb794f98329cd5a75aee1"><td class="memItemLeft" align="right" valign="top">Executor <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba818fe3267fb794f98329cd5a75aee1">endpoints</a></td></tr>
<tr class="memitem:a9accb3ddb108d48e0e70093ec8d40885" id="r_a9accb3ddb108d48e0e70093ec8d40885"><td class="memItemLeft" align="right" valign="top">Executor <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence ConnectCondition&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9accb3ddb108d48e0e70093ec8d40885">connect_condition</a></td></tr>
<tr class="memitem:aebf19830093dfbea6cb74e6fae02a6c8" id="r_aebf19830093dfbea6cb74e6fae02a6c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a> (CompletionToken) <a class="el" href="#a6ef043a2bc0f0ec501dc3c51b31e2de8">token</a></td></tr>
<tr class="memitem:a3dca3b78c7a354543013ff458ca8284b" id="r_a3dca3b78c7a354543013ff458ca8284b"><td class="memItemLeft" align="right" valign="top">F &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3dca3b78c7a354543013ff458ca8284b">f</a></td></tr>
<tr class="memitem:a6ef043a2bc0f0ec501dc3c51b31e2de8" id="r_a6ef043a2bc0f0ec501dc3c51b31e2de8"><td class="memItemLeft" align="right" valign="top">F CompletionToken &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ef043a2bc0f0ec501dc3c51b31e2de8">token</a></td></tr>
<tr class="memitem:a54dede45c3175148a77fe6635222c47d" id="r_a54dede45c3175148a77fe6635222c47d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a></td></tr>
<tr class="memitem:ae2e215d5013596cc2b385bb6c13fa518" id="r_ae2e215d5013596cc2b385bb6c13fa518"><td class="memItemLeft" align="right" valign="top"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence CompletionCondition&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a></td></tr>
<tr class="memitem:a945a5c18fa77a9e2eba420f8f44b2a4f" id="r_a945a5c18fa77a9e2eba420f8f44b2a4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a></td></tr>
<tr class="memitem:a8dcdb41a4adfd6fe5322b5dd666d9f29" id="r_a8dcdb41a4adfd6fe5322b5dd666d9f29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a></td></tr>
<tr class="memitem:a96c8c8ad73c13e29b2214f76069cc05d" id="r_a96c8c8ad73c13e29b2214f76069cc05d"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96c8c8ad73c13e29b2214f76069cc05d">delim</a></td></tr>
<tr class="memitem:a0b30afc4cf6e545180cda990770c535e" id="r_a0b30afc4cf6e545180cda990770c535e"><td class="memItemLeft" align="right" valign="top">MatchCondition&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b30afc4cf6e545180cda990770c535e">match_condition</a></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="a29630b390f0e1aa1a8121ec3962ea9eb" name="a29630b390f0e1aa1a8121ec3962ea9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29630b390f0e1aa1a8121ec3962ea9eb">&#9670;&#160;</a></span>begin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Executor <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence ConnectCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> Executor Iterator ConnectCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> Executor Iterator <a class="el" href="#a29630b390f0e1aa1a8121ec3962ea9eb">asio::begin</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab90565a6d8a05fc349e42527443ca30f" name="ab90565a6d8a05fc349e42527443ca30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90565a6d8a05fc349e42527443ca30f">&#9670;&#160;</a></span>end</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Executor <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence ConnectCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> Executor Iterator ConnectCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> Executor Iterator Iterator <a class="el" href="#ab90565a6d8a05fc349e42527443ca30f">asio::end</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8904bd25ca421af4140ab7ac95b0b956" name="a8904bd25ca421af4140ab7ac95b0b956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8904bd25ca421af4140ab7ac95b0b956">&#9670;&#160;</a></span>io_service</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1io__context.html">io_context</a> <a class="el" href="#a8904bd25ca421af4140ab7ac95b0b956">asio::io_service</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for backwards compatibility. </p>

</div>
</div>
<a id="a4f135fc124cc60e4e00dc2dbb309f354" name="a4f135fc124cc60e4e00dc2dbb309f354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f135fc124cc60e4e00dc2dbb309f354">&#9670;&#160;</a></span>signal_set</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1basic__signal__set.html">basic_signal_set</a> <a class="el" href="#a4f135fc124cc60e4e00dc2dbb309f354">asio::signal_set</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for the typical usage of a signal set. </p>

</div>
</div>
<a id="a6a7ba348943527312eeace3492bf32ee" name="a6a7ba348943527312eeace3492bf32ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7ba348943527312eeace3492bf32ee">&#9670;&#160;</a></span>streambuf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a> <a class="el" href="#a6a7ba348943527312eeace3492bf32ee">asio::streambuf</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for the typical usage of <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a>. </p>

</div>
</div>
<a id="a9924bebddd5beaed619069edb81f09d7" name="a9924bebddd5beaed619069edb81f09d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9924bebddd5beaed619069edb81f09d7">&#9670;&#160;</a></span>yield_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; <a class="el" href="classasio_1_1executor__binder.html">executor_binder</a>&lt;<a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(*)(), <a class="el" href="classasio_1_1executor.html">executor</a>&gt; &gt; <a class="el" href="#a9924bebddd5beaed619069edb81f09d7">asio::yield_context</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a372038fbe1978742fe65b07a1b2fbcd9" name="a372038fbe1978742fe65b07a1b2fbcd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372038fbe1978742fe65b07a1b2fbcd9">&#9670;&#160;</a></span>add_service()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a> asio::add_service </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Service *</td>          <td class="paramname"><span class="paramname"><em>svc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>(Deprecated: Use <a class="el" href="#acaae9584b5011eb2d929f4ee9d5e91d3">make_service()</a>.) Add a service object to the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a>. This function is used to add a service to the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> object that owns the service.</td></tr>
    <tr><td class="paramname">svc</td><td>The service object. On success, ownership of the service object is transferred to the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a>. When the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> object is destroyed, it will destroy the service object by performing: <div class="fragment"><div class="line"><span class="keyword">delete</span> <span class="keyword">static_cast&lt;</span><a class="code hl_class" href="classasio_1_1execution__context_1_1service.html">execution_context::service</a>*<span class="keyword">&gt;</span>(svc) </div>
<div class="ttc" id="aclassasio_1_1execution__context_1_1service_html"><div class="ttname"><a href="classasio_1_1execution__context_1_1service.html">asio::execution_context::service</a></div><div class="ttdoc">Base class for all io_context services.</div><div class="ttdef"><b>Definition</b> execution_context.hpp:317</div></div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1service__already__exists.html">asio::service_already_exists</a></td><td>Thrown if a service of the given type is already present in the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a>.</td></tr>
    <tr><td class="paramname"><a class="el" href="classasio_1_1invalid__service__owner.html">asio::invalid_service_owner</a></td><td>Thrown if the service's owning <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> is not the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> object specified by the <code>e</code> parameter. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a372038fbe1978742fe65b07a1b2fbcd9_icgraph.svg" width="336" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ace79295fdc53d94dd93a55901764d2d9" name="ace79295fdc53d94dd93a55901764d2d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace79295fdc53d94dd93a55901764d2d9">&#9670;&#160;</a></span>asio_handler_allocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ab54d01ea04afeb9a8b39cfac467656b7">ASIO_DECL</a> <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a> * asio::asio_handler_allocate </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default allocation function for handlers. </p>
<p>Asynchronous operations may need to allocate temporary objects. Since asynchronous operations have a handler function object, these temporary objects can be said to be associated with the handler.</p>
<p>Implement asio_handler_allocate and asio_handler_deallocate for your own handlers to provide custom allocation for these temporary objects.</p>
<p>The default implementation of these allocation hooks uses <span class="tt">::operator
new</span> and <span class="tt">::operator delete</span>.</p>
<dl class="section note"><dt>Note</dt><dd>All temporary objects associated with a handler will be deallocated before the upcall to the handler is performed. This allows the same memory to be reused for a subsequent asynchronous operation initiated by the handler.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keyword">class </span>my_handler;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span>* <a class="code hl_function" href="#ace79295fdc53d94dd93a55901764d2d9">asio_handler_allocate</a>(std::size_t size, my_handler* context)</div>
<div class="line">{</div>
<div class="line">  return ::operator <span class="keyword">new</span>(size);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="#a2a2adf6e52107fa4e93d30d053f1d417">asio_handler_deallocate</a>(<span class="keywordtype">void</span>* pointer, std::size_t size,</div>
<div class="line">    my_handler* context)</div>
<div class="line">{</div>
<div class="line">  ::operator <span class="keyword">delete</span>(pointer);</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceasio_html_a2a2adf6e52107fa4e93d30d053f1d417"><div class="ttname"><a href="#a2a2adf6e52107fa4e93d30d053f1d417">asio::asio_handler_deallocate</a></div><div class="ttdeci">ASIO_DECL void asio_handler_deallocate(void *pointer, std::size_t size,...)</div><div class="ttdoc">Default deallocation function for handlers.</div></div>
<div class="ttc" id="anamespaceasio_html_ace79295fdc53d94dd93a55901764d2d9"><div class="ttname"><a href="#ace79295fdc53d94dd93a55901764d2d9">asio::asio_handler_allocate</a></div><div class="ttdeci">ASIO_DECL void * asio_handler_allocate(std::size_t size,...)</div><div class="ttdoc">Default allocation function for handlers.</div></div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_ace79295fdc53d94dd93a55901764d2d9_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a2a2adf6e52107fa4e93d30d053f1d417" name="a2a2adf6e52107fa4e93d30d053f1d417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2adf6e52107fa4e93d30d053f1d417">&#9670;&#160;</a></span>asio_handler_deallocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ab54d01ea04afeb9a8b39cfac467656b7">ASIO_DECL</a> <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a> asio::asio_handler_deallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a> *</td>          <td class="paramname"><span class="paramname"><em>pointer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default deallocation function for handlers. </p>
<p>Implement asio_handler_allocate and asio_handler_deallocate for your own handlers to provide custom allocation for the associated temporary objects.</p>
<p>The default implementation of these allocation hooks uses <span class="tt">::operator
new</span> and <span class="tt">::operator delete</span>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ace79295fdc53d94dd93a55901764d2d9" title="Default allocation function for handlers.">asio_handler_allocate</a>. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a2a2adf6e52107fa4e93d30d053f1d417_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="abe759a0b25886ffc0b10ecd98bb69edd" name="abe759a0b25886ffc0b10ecd98bb69edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe759a0b25886ffc0b10ecd98bb69edd">&#9670;&#160;</a></span>asio_handler_invoke() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a> asio::asio_handler_invoke </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Function &amp;</td>          <td class="paramname"><span class="paramname"><em>function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default handler invocation hook used for const function objects. </p>

</div>
</div>
<a id="a91c8e702816572ffb691ca3f60a27871" name="a91c8e702816572ffb691ca3f60a27871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c8e702816572ffb691ca3f60a27871">&#9670;&#160;</a></span>asio_handler_invoke() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a> asio::asio_handler_invoke </td>
          <td>(</td>
          <td class="paramtype">Function &amp;</td>          <td class="paramname"><span class="paramname"><em>function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default handler invocation hook used for non-const function objects. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a91c8e702816572ffb691ca3f60a27871_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a7613e3b437b2491c154e056f1a26668f" name="a7613e3b437b2491c154e056f1a26668f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7613e3b437b2491c154e056f1a26668f">&#9670;&#160;</a></span>asio_handler_is_continuation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool asio::asio_handler_is_continuation </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default continuation function for handlers. </p>
<p>Asynchronous operations may represent a continuation of the asynchronous control flow associated with the current handler. The implementation can use this knowledge to optimise scheduling of the handler.</p>
<p>Implement asio_handler_is_continuation for your own handlers to indicate when a handler represents a continuation.</p>
<p>The default implementation of the continuation hook returns <span class="tt"><a class="el" href="ordinals_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></span>.</p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keyword">class </span>my_handler;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> <a class="code hl_function" href="#a7613e3b437b2491c154e056f1a26668f">asio_handler_is_continuation</a>(my_handler* context)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceasio_html_a7613e3b437b2491c154e056f1a26668f"><div class="ttname"><a href="#a7613e3b437b2491c154e056f1a26668f">asio::asio_handler_is_continuation</a></div><div class="ttdeci">bool asio_handler_is_continuation(...)</div><div class="ttdoc">Default continuation function for handlers.</div><div class="ttdef"><b>Definition</b> handler_continuation_hook.hpp:45</div></div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a7613e3b437b2491c154e056f1a26668f_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a945cf70a9b0fe077311e197150977d68" name="a945cf70a9b0fe077311e197150977d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945cf70a9b0fe077311e197150977d68">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[1/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor, typename F, typename CompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">CompletionToken</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename detail::awaitable_signature&lt; typename result_of&lt; F()&gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2275e25f151718105a35815c6d7f473f" name="a2275e25f151718105a35815c6d7f473f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2275e25f151718105a35815c6d7f473f">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[2/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext, typename F, typename CompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">F CompletionToken <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">CompletionToken</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename detail::awaitable_signature&lt; typename result_of&lt; F()&gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32f4e8ad4781c5ab71346c1035d50be5" name="a32f4e8ad4781c5ab71346c1035d50be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f4e8ad4781c5ab71346c1035d50be5">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[3/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">CompletionToken</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>()</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<p>This function submits an object for execution using the object's associated executor. The function object is queued for execution, and is never called from the current thread prior to returning from <span class="tt">defer()</span>.</p>
<p>The use of <code>defer()</code>, rather than post(), indicates the caller's preference that the executor defer the queueing of the function object. This may allow the executor to optimise queueing for cases when the function object represents a continuation of the current call context.</p>
<p>This function has the following effects:</p>
<ul>
<li>Constructs a function object handler of type <code>Handler</code>, initialized with <span class="tt">handler(forward&lt;CompletionToken&gt;(token))</span>.</li>
</ul>
<ul>
<li>Constructs an object <code>result</code> of type <span class="tt"><a class="el" href="classasio_1_1async__result.html" title="An interface for customising the behaviour of an initiating function.">async_result&lt;Handler&gt;</a></span>, initializing the object as <span class="tt">result(handler)</span>.</li>
</ul>
<ul>
<li>Obtains the handler's associated executor object <code>ex</code> by performing <span class="tt">get_associated_executor(handler)</span>.</li>
</ul>
<ul>
<li>Obtains the handler's associated allocator object <code>alloc</code> by performing <span class="tt">get_associated_allocator(handler)</span>.</li>
</ul>
<ul>
<li>Performs <span class="tt">ex.defer(std::move(handler), alloc)</span>.</li>
</ul>
<ul>
<li>Returns <span class="tt">result.get()</span>.</li>
</ul>
<p>This function submits an object for execution using the object's associated executor. The function object may be called from the current thread prior to returning from <span class="tt">dispatch()</span>. Otherwise, it is queued for execution.</p>
<p>This function has the following effects:</p>
<ul>
<li>Constructs a function object handler of type <code>Handler</code>, initialized with <span class="tt">handler(forward&lt;CompletionToken&gt;(token))</span>.</li>
</ul>
<ul>
<li>Constructs an object <code>result</code> of type <span class="tt"><a class="el" href="classasio_1_1async__result.html" title="An interface for customising the behaviour of an initiating function.">async_result&lt;Handler&gt;</a></span>, initializing the object as <span class="tt">result(handler)</span>.</li>
</ul>
<ul>
<li>Obtains the handler's associated executor object <code>ex</code> by performing <span class="tt">get_associated_executor(handler)</span>.</li>
</ul>
<ul>
<li>Obtains the handler's associated allocator object <code>alloc</code> by performing <span class="tt">get_associated_allocator(handler)</span>.</li>
</ul>
<ul>
<li>Performs <span class="tt">ex.dispatch(std::move(handler), alloc)</span>.</li>
</ul>
<ul>
<li>Returns <span class="tt">result.get()</span>.</li>
</ul>
<p>This function submits an object for execution using the object's associated executor. The function object is queued for execution, and is never called from the current thread prior to returning from <span class="tt">post()</span>.</p>
<p>The use of <code>post()</code>, rather than defer(), indicates the caller's preference that the function object be eagerly queued for execution.</p>
<p>This function has the following effects:</p>
<ul>
<li>Constructs a function object handler of type <code>Handler</code>, initialized with <span class="tt">handler(forward&lt;CompletionToken&gt;(token))</span>.</li>
</ul>
<ul>
<li>Constructs an object <code>result</code> of type <span class="tt"><a class="el" href="classasio_1_1async__result.html" title="An interface for customising the behaviour of an initiating function.">async_result&lt;Handler&gt;</a></span>, initializing the object as <span class="tt">result(handler)</span>.</li>
</ul>
<ul>
<li>Obtains the handler's associated executor object <code>ex</code> by performing <span class="tt">get_associated_executor(handler)</span>.</li>
</ul>
<ul>
<li>Obtains the handler's associated allocator object <code>alloc</code> by performing <span class="tt">get_associated_allocator(handler)</span>.</li>
</ul>
<ul>
<li>Performs <span class="tt">ex.post(std::move(handler), alloc)</span>.</li>
</ul>
<ul>
<li>Returns <span class="tt">result.get()</span>. </li>
</ul>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a32f4e8ad4781c5ab71346c1035d50be5_cgraph.svg" width="424" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a311928c56726e9bd750bd406aeaa2867" name="a311928c56726e9bd750bd406aeaa2867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311928c56726e9bd750bd406aeaa2867">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[4/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor, typename CompletionToken&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">CompletionToken</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>()</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<p>This function submits an object for execution using the specified executor. The function object is queued for execution, and is never called from the current thread prior to returning from <span class="tt">defer()</span>.</p>
<p>The use of <code>defer()</code>, rather than post(), indicates the caller's preference that the executor defer the queueing of the function object. This may allow the executor to optimise queueing for cases when the function object represents a continuation of the current call context.</p>
<p>This function has the following effects:</p>
<ul>
<li>Constructs a function object handler of type <code>Handler</code>, initialized with <span class="tt">handler(forward&lt;CompletionToken&gt;(token))</span>.</li>
</ul>
<ul>
<li>Constructs an object <code>result</code> of type <span class="tt"><a class="el" href="classasio_1_1async__result.html" title="An interface for customising the behaviour of an initiating function.">async_result&lt;Handler&gt;</a></span>, initializing the object as <span class="tt">result(handler)</span>.</li>
</ul>
<ul>
<li>Obtains the handler's associated executor object <code>ex1</code> by performing <span class="tt">get_associated_executor(handler)</span>.</li>
</ul>
<ul>
<li>Creates a work object <code>w</code> by performing <span class="tt">make_work(ex1)</span>.</li>
</ul>
<ul>
<li>Obtains the handler's associated allocator object <code>alloc</code> by performing <span class="tt">get_associated_allocator(handler)</span>.</li>
</ul>
<ul>
<li>Constructs a function object <code>f</code> with a function call operator that performs <span class="tt">ex1.dispatch(std::move(handler), alloc)</span> followed by <span class="tt">w.reset()</span>.</li>
</ul>
<ul>
<li>Performs <span class="tt">Executor(ex).defer(std::move(f), alloc)</span>.</li>
</ul>
<ul>
<li>Returns <span class="tt">result.get()</span>.</li>
</ul>
<p>This function submits an object for execution using the specified executor. The function object may be called from the current thread prior to returning from <span class="tt">dispatch()</span>. Otherwise, it is queued for execution.</p>
<p>This function has the following effects:</p>
<ul>
<li>Constructs a function object handler of type <code>Handler</code>, initialized with <span class="tt">handler(forward&lt;CompletionToken&gt;(token))</span>.</li>
</ul>
<ul>
<li>Constructs an object <code>result</code> of type <span class="tt"><a class="el" href="classasio_1_1async__result.html" title="An interface for customising the behaviour of an initiating function.">async_result&lt;Handler&gt;</a></span>, initializing the object as <span class="tt">result(handler)</span>.</li>
</ul>
<ul>
<li>Obtains the handler's associated executor object <code>ex1</code> by performing <span class="tt">get_associated_executor(handler)</span>.</li>
</ul>
<ul>
<li>Creates a work object <code>w</code> by performing <span class="tt">make_work(ex1)</span>.</li>
</ul>
<ul>
<li>Obtains the handler's associated allocator object <code>alloc</code> by performing <span class="tt">get_associated_allocator(handler)</span>.</li>
</ul>
<ul>
<li>Constructs a function object <code>f</code> with a function call operator that performs <span class="tt">ex1.dispatch(std::move(handler), alloc)</span> followed by <span class="tt">w.reset()</span>.</li>
</ul>
<ul>
<li>Performs <span class="tt">Executor(ex).dispatch(std::move(f), alloc)</span>.</li>
</ul>
<ul>
<li>Returns <span class="tt">result.get()</span>.</li>
</ul>
<p>This function submits an object for execution using the specified executor. The function object is queued for execution, and is never called from the current thread prior to returning from <span class="tt">post()</span>.</p>
<p>The use of <code>post()</code>, rather than defer(), indicates the caller's preference that the function object be eagerly queued for execution.</p>
<p>This function has the following effects:</p>
<ul>
<li>Constructs a function object handler of type <code>Handler</code>, initialized with <span class="tt">handler(forward&lt;CompletionToken&gt;(token))</span>.</li>
</ul>
<ul>
<li>Constructs an object <code>result</code> of type <span class="tt"><a class="el" href="classasio_1_1async__result.html" title="An interface for customising the behaviour of an initiating function.">async_result&lt;Handler&gt;</a></span>, initializing the object as <span class="tt">result(handler)</span>.</li>
</ul>
<ul>
<li>Obtains the handler's associated executor object <code>ex1</code> by performing <span class="tt">get_associated_executor(handler)</span>.</li>
</ul>
<ul>
<li>Creates a work object <code>w</code> by performing <span class="tt">make_work(ex1)</span>.</li>
</ul>
<ul>
<li>Obtains the handler's associated allocator object <code>alloc</code> by performing <span class="tt">get_associated_allocator(handler)</span>.</li>
</ul>
<ul>
<li>Constructs a function object <code>f</code> with a function call operator that performs <span class="tt">ex1.dispatch(std::move(handler), alloc)</span> followed by <span class="tt">w.reset()</span>.</li>
</ul>
<ul>
<li>Performs <span class="tt">Executor(ex).post(std::move(f), alloc)</span>.</li>
</ul>
<ul>
<li>Returns <span class="tt">result.get()</span>. </li>
</ul>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a311928c56726e9bd750bd406aeaa2867_cgraph.svg" width="528" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a537a9872ab842095055922cac3ff3e5a" name="a537a9872ab842095055922cac3ff3e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537a9872ab842095055922cac3ff3e5a">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[5/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext, typename CompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">CompletionToken</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>()</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp; = 0)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">defer(ctx.get_executor(), forward&lt;CompletionToken&gt;(token))</span>.</dd>
<dd>
<span class="tt">dispatch(ctx.get_executor(),
forward&lt;CompletionToken&gt;(token))</span>.</dd>
<dd>
<span class="tt">post(ctx.get_executor(), forward&lt;CompletionToken&gt;(token))</span>. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a537a9872ab842095055922cac3ff3e5a_cgraph.svg" width="528" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ade13b08b021b4b6121f847026c0ea79d" name="ade13b08b021b4b6121f847026c0ea79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade13b08b021b4b6121f847026c0ea79d">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[6/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Executor, typename Iterator, typename ConnectCondition, typename IteratorConnectHandler&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Executor <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence ConnectCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> Executor Iterator ConnectCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">IteratorConnectHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, Iterator)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="#aed2f96583612003958535ed0e116650c">async_initiate</a>&lt;IteratorConnectHandler,</div>
<div class="line">    <a class="code hl_define" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a> (<a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>, Iterator)&gt;(</div>
<div class="line">      <a class="code hl_struct" href="structasio_1_1detail_1_1initiate__async__iterator__connect.html">detail::initiate_async_iterator_connect</a>(),</div>
<div class="line">      handler, &amp;<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_typedef" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>, Iterator(), <a class="code hl_variable" href="#a9accb3ddb108d48e0e70093ec8d40885">connect_condition</a>)</div>
<div class="ttc" id="aclassasio_1_1error__code_html"><div class="ttname"><a href="classasio_1_1error__code.html">asio::error_code</a></div><div class="ttdoc">Class to represent an error code value.</div><div class="ttdef"><b>Definition</b> error_code.hpp:81</div></div>
<div class="ttc" id="anamespaceasio_html_a29630b390f0e1aa1a8121ec3962ea9eb"><div class="ttname"><a href="#a29630b390f0e1aa1a8121ec3962ea9eb">asio::begin</a></div><div class="ttdeci">Executor const EndpointSequence enable_if&lt; is_endpoint_sequence&lt; EndpointSequence &gt;::value &gt;::type Executor Iterator begin</div><div class="ttdef"><b>Definition</b> connect.hpp:718</div></div>
<div class="ttc" id="anamespaceasio_html_a551ec1a519b15e013e05cb1fe1c4b362"><div class="ttname"><a href="#a551ec1a519b15e013e05cb1fe1c4b362">asio::s</a></div><div class="ttdeci">Executor &amp; s</div><div class="ttdef"><b>Definition</b> connect.hpp:672</div></div>
<div class="ttc" id="anamespaceasio_html_a9accb3ddb108d48e0e70093ec8d40885"><div class="ttname"><a href="#a9accb3ddb108d48e0e70093ec8d40885">asio::connect_condition</a></div><div class="ttdeci">Executor const EndpointSequence ConnectCondition connect_condition</div><div class="ttdef"><b>Definition</b> connect.hpp:879</div></div>
<div class="ttc" id="anamespaceasio_html_aed2f96583612003958535ed0e116650c"><div class="ttname"><a href="#aed2f96583612003958535ed0e116650c">asio::async_initiate</a></div><div class="ttdeci">enable_if&lt; detail::async_result_has_initiate_memfn&lt; CompletionToken, Signature &gt;::value, ASIO_INITFN_RESULT_TYPE(CompletionToken, Signature)&gt;::type async_initiate(ASIO_MOVE_ARG(Initiation) initiation, ASIO_NONDEDUCED_MOVE_ARG(CompletionToken) token)</div><div class="ttdef"><b>Definition</b> async_result.hpp:286</div></div>
<div class="ttc" id="astructasio_1_1detail_1_1initiate__async__iterator__connect_html"><div class="ttname"><a href="structasio_1_1detail_1_1initiate__async__iterator__connect.html">asio::detail::initiate_async_iterator_connect</a></div><div class="ttdef"><b>Definition</b> connect.hpp:627</div></div>
<div class="ttc" id="aunzipfx-carla-control_2unzip_8h_html_aa8c59027f9ab2769342f248709d68d17"><div class="ttname"><a href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a></div><div class="ttdeci">#define void</div><div class="ttdef"><b>Definition</b> unzip.h:396</div></div>
</div><!-- fragment --><p>Asynchronously establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>async_connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code hl_variable" href="#a9accb3ddb108d48e0e70093ec8d40885">connect_condition</a>(</div>
<div class="line">   <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the connect operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation. if the sequence is empty, set to</span></div>
<div class="line">  <span class="comment">// asio::error::not_found. Otherwise, contains the</span></div>
<div class="line">  <span class="comment">// error from the last connection attempt.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// On success, an iterator denoting the successfully</span></div>
<div class="line">  <span class="comment">// connected endpoint. Otherwise, the end iterator.</span></div>
<div class="line">  Iterator iterator</div>
<div class="line">); </div>
<div class="ttc" id="anamespaceasio_1_1error_html"><div class="ttname"><a href="namespaceasio_1_1error.html">asio::error</a></div><div class="ttdef"><b>Definition</b> error.hpp:64</div></div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>The following connect condition function object can be used to output information about the individual connection attempts: <div class="fragment"><div class="line"> <span class="keyword">struct </span>my_connect_condition</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">bool</span> operator()(</div>
<div class="line">      <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div>
<div class="line">      const::tcp::endpoint&amp; next)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (ec) std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.<a class="code hl_function" href="classasio_1_1error__code.html#a7029a8f8f51f7e03da42bd50c2b3c85b">message</a>() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">}; </div>
<div class="ttc" id="aclassasio_1_1error__code_html_a7029a8f8f51f7e03da42bd50c2b3c85b"><div class="ttname"><a href="classasio_1_1error__code.html#a7029a8f8f51f7e03da42bd50c2b3c85b">asio::error_code::message</a></div><div class="ttdeci">std::string message() const</div><div class="ttdoc">Get the message associated with the error.</div><div class="ttdef"><b>Definition</b> error_code.hpp:131</div></div>
</div><!-- fragment --> It would be used with the <a class="el" href="#a451e58dc85e01aced92a59bbf5ca4d47" title="Establishes a socket connection by trying each endpoint in a sequence.">asio::connect</a> function as follows: <div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line">tcp::socket <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>(my_context);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">r.async_resolve(q, resolve_handler);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> resolve_handler(</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div>
<div class="line">    tcp::resolver::iterator <a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!ec)</div>
<div class="line">  {</div>
<div class="line">    tcp::resolver::iterator <a class="code hl_typedef" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>;</div>
<div class="line">    asio::async_connect(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, <a class="code hl_typedef" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>,</div>
<div class="line">        my_connect_condition(),</div>
<div class="line">        connect_handler);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> connect_handler(</div>
<div class="line">    <span class="keyword">const</span> asio::error_code&amp; ec,</div>
<div class="line">    tcp::resolver::iterator <a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (ec)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// An error occurred.</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Connected to: &quot;</span> &lt;&lt; <a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>-&gt;endpoint() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">} </div>
<div class="ttc" id="anamespaceasio_html_ab90565a6d8a05fc349e42527443ca30f"><div class="ttname"><a href="#ab90565a6d8a05fc349e42527443ca30f">asio::end</a></div><div class="ttdeci">Executor const EndpointSequence enable_if&lt; is_endpoint_sequence&lt; EndpointSequence &gt;::value &gt;::type Executor Iterator enable_if&lt;!is_endpoint_sequence&lt; Iterator &gt;::value &gt;::type Executor Iterator Iterator end</div><div class="ttdef"><b>Definition</b> connect.hpp:776</div></div>
<div class="ttc" id="asrc_23rdparty_2jack2_2tests_2test_8cpp_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">int i</div><div class="ttdef"><b>Definition</b> test.cpp:91</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a71085872969c7c0aa8d8d0ae123f103a" name="a71085872969c7c0aa8d8d0ae123f103a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71085872969c7c0aa8d8d0ae123f103a">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[7/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Executor, typename Iterator, typename ConnectCondition, typename IteratorConnectHandler&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Executor <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence ConnectCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">IteratorConnectHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, Iterator)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="#aed2f96583612003958535ed0e116650c">async_initiate</a>&lt;RangeConnectHandler,</div>
<div class="line">    <a class="code hl_define" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a> (<a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>, <span class="keyword">typename</span> Protocol::endpoint)&gt;(</div>
<div class="line">      <a class="code hl_struct" href="structasio_1_1detail_1_1initiate__async__range__connect.html">detail::initiate_async_range_connect</a>(),</div>
<div class="line">      handler, &amp;<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#aba818fe3267fb794f98329cd5a75aee1">endpoints</a>, <a class="code hl_variable" href="#a9accb3ddb108d48e0e70093ec8d40885">connect_condition</a>)</div>
<div class="ttc" id="anamespaceasio_html_aba818fe3267fb794f98329cd5a75aee1"><div class="ttname"><a href="#aba818fe3267fb794f98329cd5a75aee1">asio::endpoints</a></div><div class="ttdeci">Executor const EndpointSequence &amp; endpoints</div><div class="ttdef"><b>Definition</b> connect.hpp:673</div></div>
<div class="ttc" id="astructasio_1_1detail_1_1initiate__async__range__connect_html"><div class="ttname"><a href="structasio_1_1detail_1_1initiate__async__range__connect.html">asio::detail::initiate_async_range_connect</a></div><div class="ttdef"><b>Definition</b> connect.hpp:458</div></div>
</div><!-- fragment --><p>(Deprecated: Use range overload.) Asynchronously establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>async_connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code hl_variable" href="#a9accb3ddb108d48e0e70093ec8d40885">connect_condition</a>(</div>
<div class="line">   <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the connect operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation. if the sequence is empty, set to</span></div>
<div class="line">  <span class="comment">// asio::error::not_found. Otherwise, contains the</span></div>
<div class="line">  <span class="comment">// error from the last connection attempt.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// On success, an iterator denoting the successfully</span></div>
<div class="line">  <span class="comment">// connected endpoint. Otherwise, the end iterator.</span></div>
<div class="line">  Iterator iterator</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload assumes that a default constructed object of type <code>Iterator</code> represents the end of the sequence. This is a valid assumption for iterator types such as <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a0c3dbc8d36448e3cf70439e8388396d9">asio::ip::tcp::resolver::iterator</a></code>. </dd></dl>

</div>
</div>
<a id="accc1ea2b415306eaa165aa45ed92f837" name="accc1ea2b415306eaa165aa45ed92f837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc1ea2b415306eaa165aa45ed92f837">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[8/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Executor, typename Iterator, typename IteratorConnectHandler&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Executor <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> Executor Iterator <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">IteratorConnectHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, Iterator)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="#aed2f96583612003958535ed0e116650c">async_initiate</a>&lt;IteratorConnectHandler,</div>
<div class="line">    <a class="code hl_define" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a> (<a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>, Iterator)&gt;(</div>
<div class="line">      <a class="code hl_struct" href="structasio_1_1detail_1_1initiate__async__iterator__connect.html">detail::initiate_async_iterator_connect</a>(), handler,</div>
<div class="line">      &amp;<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_typedef" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>, Iterator(), <a class="code hl_struct" href="structasio_1_1detail_1_1default__connect__condition.html">detail::default_connect_condition</a>())</div>
<div class="ttc" id="astructasio_1_1detail_1_1default__connect__condition_html"><div class="ttname"><a href="structasio_1_1detail_1_1default__connect__condition.html">asio::detail::default_connect_condition</a></div><div class="ttdef"><b>Definition</b> connect.hpp:38</div></div>
</div><!-- fragment --><p>Asynchronously establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>async_connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the connect operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation. if the sequence is empty, set to</span></div>
<div class="line">  <span class="comment">// asio::error::not_found. Otherwise, contains the</span></div>
<div class="line">  <span class="comment">// error from the last connection attempt.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// On success, an iterator denoting the successfully</span></div>
<div class="line">  <span class="comment">// connected endpoint. Otherwise, the end iterator.</span></div>
<div class="line">  Iterator iterator</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> std::vector&lt;tcp::endpoint&gt; <a class="code hl_variable" href="#aba818fe3267fb794f98329cd5a75aee1">endpoints</a> = ...;</div>
<div class="line">tcp::socket <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>(my_context);</div>
<div class="line">asio::async_connect(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>,</div>
<div class="line">    <a class="code hl_variable" href="#aba818fe3267fb794f98329cd5a75aee1">endpoints</a>.begin(), <a class="code hl_variable" href="#aba818fe3267fb794f98329cd5a75aee1">endpoints</a>.end(),</div>
<div class="line">    connect_handler);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> connect_handler(</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div>
<div class="line">    std::vector&lt;tcp::endpoint&gt;::iterator <a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">} </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3bb009ce2502d1d33b995e7294f3de49" name="a3bb009ce2502d1d33b995e7294f3de49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb009ce2502d1d33b995e7294f3de49">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[9/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Executor, typename Iterator, typename IteratorConnectHandler&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Executor <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">IteratorConnectHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, Iterator)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="#aed2f96583612003958535ed0e116650c">async_initiate</a>&lt;RangeConnectHandler,</div>
<div class="line">    <a class="code hl_define" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a> (<a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>, <span class="keyword">typename</span> Protocol::endpoint)&gt;(</div>
<div class="line">      <a class="code hl_struct" href="structasio_1_1detail_1_1initiate__async__range__connect.html">detail::initiate_async_range_connect</a>(), handler,</div>
<div class="line">      &amp;<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#aba818fe3267fb794f98329cd5a75aee1">endpoints</a>, <a class="code hl_struct" href="structasio_1_1detail_1_1default__connect__condition.html">detail::default_connect_condition</a>())</div>
</div><!-- fragment --><p>(Deprecated: Use range overload.) Asynchronously establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>async_connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the connect operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation. if the sequence is empty, set to</span></div>
<div class="line">  <span class="comment">// asio::error::not_found. Otherwise, contains the</span></div>
<div class="line">  <span class="comment">// error from the last connection attempt.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// On success, an iterator denoting the successfully</span></div>
<div class="line">  <span class="comment">// connected endpoint. Otherwise, the end iterator.</span></div>
<div class="line">  Iterator iterator</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload assumes that a default constructed object of type <code>Iterator</code> represents the end of the sequence. This is a valid assumption for iterator types such as <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a0c3dbc8d36448e3cf70439e8388396d9">asio::ip::tcp::resolver::iterator</a></code>. </dd></dl>

</div>
</div>
<a id="a983464c451e1885c6662a2553fc672d9" name="a983464c451e1885c6662a2553fc672d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983464c451e1885c6662a2553fc672d9">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[10/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Executor, typename EndpointSequence, typename ConnectCondition, typename RangeConnectHandler&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">RangeConnectHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, typename Protocol::endpoint)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronously establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>async_connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code hl_variable" href="#a9accb3ddb108d48e0e70093ec8d40885">connect_condition</a>(</div>
<div class="line">   <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the connect operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation. if the sequence is empty, set to</span></div>
<div class="line">  <span class="comment">// asio::error::not_found. Otherwise, contains the</span></div>
<div class="line">  <span class="comment">// error from the last connection attempt.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// On success, an iterator denoting the successfully</span></div>
<div class="line">  <span class="comment">// connected endpoint. Otherwise, the end iterator.</span></div>
<div class="line">  Iterator iterator</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>The following connect condition function object can be used to output information about the individual connection attempts: <div class="fragment"><div class="line"> <span class="keyword">struct </span>my_connect_condition</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">bool</span> operator()(</div>
<div class="line">      <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div>
<div class="line">      const::tcp::endpoint&amp; next)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (ec) std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.<a class="code hl_function" href="classasio_1_1error__code.html#a7029a8f8f51f7e03da42bd50c2b3c85b">message</a>() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">}; </div>
</div><!-- fragment --> It would be used with the <a class="el" href="#a451e58dc85e01aced92a59bbf5ca4d47" title="Establishes a socket connection by trying each endpoint in a sequence.">asio::connect</a> function as follows: <div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line">tcp::socket <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>(my_context);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">r.async_resolve(q, resolve_handler);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> resolve_handler(</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div>
<div class="line">    tcp::resolver::results_type results)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!ec)</div>
<div class="line">  {</div>
<div class="line">    asio::async_connect(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, results,</div>
<div class="line">        my_connect_condition(),</div>
<div class="line">        connect_handler);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> connect_handler(</div>
<div class="line">    <span class="keyword">const</span> asio::error_code&amp; ec,</div>
<div class="line">    <span class="keyword">const</span> tcp::endpoint&amp; endpoint)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (ec)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// An error occurred.</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Connected to: &quot;</span> &lt;&lt; endpoint &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">} </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a983464c451e1885c6662a2553fc672d9_cgraph.svg" width="528" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aeafc22dcf4397b1b5f52ced939a55203" name="aeafc22dcf4397b1b5f52ced939a55203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeafc22dcf4397b1b5f52ced939a55203">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[11/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Executor, typename EndpointSequence, typename RangeConnectHandler&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">RangeConnectHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, typename Protocol::endpoint)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronously establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>async_connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the connect operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation. if the sequence is empty, set to</span></div>
<div class="line">  <span class="comment">// asio::error::not_found. Otherwise, contains the</span></div>
<div class="line">  <span class="comment">// error from the last connection attempt.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// On success, the successfully connected endpoint.</span></div>
<div class="line">  <span class="comment">// Otherwise, a default-constructed endpoint.</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; endpoint</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line">tcp::socket <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>(my_context);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">r.async_resolve(q, resolve_handler);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> resolve_handler(</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div>
<div class="line">    tcp::resolver::results_type results)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!ec)</div>
<div class="line">  {</div>
<div class="line">    asio::async_connect(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, results, connect_handler);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> connect_handler(</div>
<div class="line">    <span class="keyword">const</span> asio::error_code&amp; ec,</div>
<div class="line">    <span class="keyword">const</span> tcp::endpoint&amp; endpoint)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">} </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_aeafc22dcf4397b1b5f52ced939a55203_icgraph.svg" width="100%" height="438"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a78500cf480d94be08533585b357e5ba5" name="a78500cf480d94be08533585b357e5ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78500cf480d94be08533585b357e5ba5">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[12/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream, typename DynamicBuffer_v2, typename CompletionCondition, typename ReadHandler&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DynamicBuffer_v2 <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ReadHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp; = 0)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest async_read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
<div class="ttc" id="anamespaceasio_html_ae2e215d5013596cc2b385bb6c13fa518"><div class="ttname"><a href="#ae2e215d5013596cc2b385bb6c13fa518">asio::completion_condition</a></div><div class="ttdeci">const MutableBufferSequence CompletionCondition completion_condition</div><div class="ttdef"><b>Definition</b> read.hpp:523</div></div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async_read_some function.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>, <span class="comment">// Result of operation.</span></div>
<div class="line"> </div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes copied into the</span></div>
<div class="line">                                          <span class="comment">// buffers. If an error occurred,</span></div>
<div class="line">                                          <span class="comment">// this will be the  number of</span></div>
<div class="line">                                          <span class="comment">// bytes successfully transferred</span></div>
<div class="line">                                          <span class="comment">// prior to the error.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f6dc45f82474ab7cfd43ccd969cbdb6" name="a0f6dc45f82474ab7cfd43ccd969cbdb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6dc45f82474ab7cfd43ccd969cbdb6">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[13/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream, typename DynamicBuffer_v1, typename CompletionCondition, typename ReadHandler&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ReadHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d4f5c52cc8c1c5d16fc7bf7e0f75c4b" name="a3d4f5c52cc8c1c5d16fc7bf7e0f75c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4f5c52cc8c1c5d16fc7bf7e0f75c4b">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[14/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream, typename DynamicBuffer_v1, typename ReadHandler&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ReadHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>, <span class="comment">// Result of operation.</span></div>
<div class="line"> </div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes copied into the</span></div>
<div class="line">                                          <span class="comment">// buffers. If an error occurred,</span></div>
<div class="line">                                          <span class="comment">// this will be the  number of</span></div>
<div class="line">                                          <span class="comment">// bytes successfully transferred</span></div>
<div class="line">                                          <span class="comment">// prior to the error.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line">asio::async_read(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_function" href="#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, size), handler);</div>
<div class="ttc" id="ajpeglib_8h_html_aa379dc8ae39e55ae0c431a61a7d2f2bc"><div class="ttname"><a href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a></div><div class="ttdeci">JSAMPIMAGE data</div><div class="ttdef"><b>Definition</b> jpeglib.h:945</div></div>
<div class="ttc" id="anamespaceasio_html_aab2e5a8bd2a00b088a5644c64ef73e2a"><div class="ttname"><a href="#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a></div><div class="ttdeci">ASIO_MUTABLE_BUFFER buffer(const mutable_buffer &amp;b) ASIO_NOEXCEPT</div><div class="ttdoc">Create a new modifiable buffer from an existing buffer.</div><div class="ttdef"><b>Definition</b> buffer.hpp:907</div></div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line">asio::async_read(</div>
<div class="line">   <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(),</div>
<div class="line">   handler); </div>
<div class="ttc" id="anamespaceasio_html_a4a82e92df79aa8401a8bc2117d4cf900"><div class="ttname"><a href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a></div><div class="ttdeci">detail::transfer_all_t transfer_all()</div><div class="ttdef"><b>Definition</b> completion_condition.hpp:138</div></div>
<div class="ttc" id="anamespaceasio_html_a54dede45c3175148a77fe6635222c47d"><div class="ttname"><a href="#a54dede45c3175148a77fe6635222c47d">asio::buffers</a></div><div class="ttdeci">const MutableBufferSequence &amp; buffers</div><div class="ttdef"><b>Definition</b> read.hpp:522</div></div>
</div><!-- fragment --></dd></dl>
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>, <span class="comment">// Result of operation.</span></div>
<div class="line"> </div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes copied into the</span></div>
<div class="line">                                          <span class="comment">// buffers. If an error occurred,</span></div>
<div class="line">                                          <span class="comment">// this will be the  number of</span></div>
<div class="line">                                          <span class="comment">// bytes successfully transferred</span></div>
<div class="line">                                          <span class="comment">// prior to the error.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line">asio::async_read(</div>
<div class="line">   <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(),</div>
<div class="line">   handler); </div>
</div><!-- fragment --></dd></dl>
<p>Start an asynchronous operation to read a certain amount of data at the specified offset. This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_read_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the AsyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line">asio::async_read_at(d, 42, <a class="code hl_function" href="#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, size), handler);</div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line">asio::async_read_at(</div>
<div class="line">   d, 42, <a class="code hl_variable" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(),</div>
<div class="line">   handler); </div>
</div><!-- fragment --></dd></dl>
<p>Start an asynchronous operation to read a certain amount of data at the specified offset. This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_read_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the AsyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line">asio::async_read_at(</div>
<div class="line">   d, 42, <a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(),</div>
<div class="line">   handler); </div>
<div class="ttc" id="anamespaceasio_html_a945a5c18fa77a9e2eba420f8f44b2a4f"><div class="ttname"><a href="#a945a5c18fa77a9e2eba420f8f44b2a4f">asio::b</a></div><div class="ttdeci">basic_streambuf&lt; Allocator &gt; &amp; b</div><div class="ttdef"><b>Definition</b> read.hpp:804</div></div>
</div><!-- fragment --></dd></dl>
<p>Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the dynamic buffer sequence's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the dynamic buffer sequence&#39;s</span></div>
<div class="line">  <span class="comment">// get area up to and including the delimiter.</span></div>
<div class="line">  <span class="comment">// 0 if an error occurred.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To asynchronously read data into a <code>std::string</code> until a newline is encountered: <div class="fragment"><div class="line"> std::string <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>;</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; e, std::size_t size)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!e)</div>
<div class="line">  {</div>
<div class="line">    std::string line = <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.substr(0, n);</div>
<div class="line">    <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.erase(0, n);</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">asio::async_read_until(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, <span class="charliteral">&#39;\n&#39;</span>, handler); </div>
</div><!-- fragment --> After the <code>async_read_until</code> operation completes successfully, the buffer <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the buffer <code>data</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>async_read_until</code> operation.</dd></dl>
<p>Start an asynchronous operation to read data into a streambuf until it contains a specified delimiter. This function is used to asynchronously read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the streambuf's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the streambuf&#39;s get</span></div>
<div class="line">  <span class="comment">// area up to and including the delimiter.</span></div>
<div class="line">  <span class="comment">// 0 if an error occurred.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To asynchronously read data into a streambuf until a newline is encountered: <div class="fragment"><div class="line"> <a class="code hl_typedef" href="#a6a7ba348943527312eeace3492bf32ee">asio::streambuf</a> <a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>;</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; e, std::size_t size)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!e)</div>
<div class="line">  {</div>
<div class="line">    std::istream is(&amp;<a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>);</div>
<div class="line">    std::string line;</div>
<div class="line">    std::getline(is, line);</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">asio::async_read_until(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, <span class="stringliteral">&quot;\r\n&quot;</span>, handler); </div>
<div class="ttc" id="anamespaceasio_html_a6a7ba348943527312eeace3492bf32ee"><div class="ttname"><a href="#a6a7ba348943527312eeace3492bf32ee">asio::streambuf</a></div><div class="ttdeci">basic_streambuf streambuf</div><div class="ttdoc">Typedef for the typical usage of basic_streambuf.</div><div class="ttdef"><b>Definition</b> streambuf.hpp:27</div></div>
</div><!-- fragment --> After the <code>async_read_until</code> operation completes successfully, the buffer <code>b</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>std::getline</code> then extracts the data up to and including the newline (which is discarded), so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span> } </div>
</div><!-- fragment --> The remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>async_read_until</code> operation. </dd></dl>

</div>
</div>
<a id="a7c651c815405ce015b8ff36ca95cbfae" name="a7c651c815405ce015b8ff36ca95cbfae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c651c815405ce015b8ff36ca95cbfae">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[15/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream, typename MutableBufferSequence, typename ReadHandler&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence CompletionCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ReadHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a7c651c815405ce015b8ff36ca95cbfae_cgraph.svg" width="424" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ab321259782b3683c80f33eb1050a3251" name="ab321259782b3683c80f33eb1050a3251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab321259782b3683c80f33eb1050a3251">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[16/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream, typename MutableBufferSequence, typename CompletionCondition, typename ReadHandler&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ReadHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest async_read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async_read_some function.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>, <span class="comment">// Result of operation.</span></div>
<div class="line"> </div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes copied into the</span></div>
<div class="line">                                          <span class="comment">// buffers. If an error occurred,</span></div>
<div class="line">                                          <span class="comment">// this will be the  number of</span></div>
<div class="line">                                          <span class="comment">// bytes successfully transferred</span></div>
<div class="line">                                          <span class="comment">// prior to the error.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<p>Start an asynchronous operation to read a certain amount of data at the specified offset. This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the AsyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest async_read_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's async_read_some_at function.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line">asio::async_read_at(d, 42,</div>
<div class="line">   <a class="code hl_function" href="#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, size),</div>
<div class="line">   <a class="code hl_function" href="#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(32),</div>
<div class="line">   handler); </div>
<div class="ttc" id="anamespaceasio_html_a2b10af704afcd6c7ed7f0d3b740033ef"><div class="ttname"><a href="#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a></div><div class="ttdeci">detail::transfer_at_least_t transfer_at_least(std::size_t minimum)</div><div class="ttdef"><b>Definition</b> completion_condition.hpp:172</div></div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<p>Start an asynchronous operation to read a certain amount of data at the specified offset. This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_read_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the AsyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest async_read_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's async_read_some_at function.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes copied into the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be the number of bytes successfully</span></div>
<div class="line">  <span class="comment">// transferred prior to the error.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<p>Start an asynchronous operation to read data into a streambuf until a function object indicates a match. This function is used to asynchronously read data into the specified streambuf until a user-defined match condition function object, when applied to the data contained in the streambuf, indicates a successful match. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the match condition function object already indicates a match, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; <a class="code hl_variable" href="#a0b30afc4cf6e545180cda990770c535e">match_condition</a>(iterator <a class="code hl_typedef" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>, iterator <a class="code hl_typedef" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>);</div>
<div class="ttc" id="anamespaceasio_html_a0b30afc4cf6e545180cda990770c535e"><div class="ttname"><a href="#a0b30afc4cf6e545180cda990770c535e">asio::match_condition</a></div><div class="ttdeci">MatchCondition match_condition</div><div class="ttdef"><b>Definition</b> read_until.hpp:1835</div></div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1buffers__iterator.html">buffers_iterator&lt;basic_streambuf&lt;Allocator&gt;::const_buffers_type</a>&gt;</div>
<div class="ttc" id="aclassasio_1_1buffers__iterator_html"><div class="ttname"><a href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a></div><div class="ttdoc">A random access iterator over the bytes in a buffer sequence.</div><div class="ttdef"><b>Definition</b> buffers_iterator.hpp:111</div></div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the streambuf&#39;s get</span></div>
<div class="line">  <span class="comment">// area that have been fully consumed by the</span></div>
<div class="line">  <span class="comment">// match function. O if an error occurred.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the streambuf may contain additional data beyond that which matched the function object. An application will typically leave that data in the streambuf for a subsequent async_read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>To asynchronously read data into a streambuf until whitespace is encountered: <div class="fragment"><div class="line"> <span class="keyword">typedef</span> <a class="code hl_class" href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a>&lt;</div>
<div class="line">    <a class="code hl_typedef" href="classasio_1_1basic__streambuf.html#a9e2ffddcb9e89d68048254ea787c2258">asio::streambuf::const_buffers_type</a>&gt; iterator;</div>
<div class="line"> </div>
<div class="line">std::pair&lt;iterator, bool&gt;</div>
<div class="line">match_whitespace(iterator <a class="code hl_typedef" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>, iterator <a class="code hl_typedef" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>)</div>
<div class="line">{</div>
<div class="line">  iterator <a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> = <a class="code hl_typedef" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>;</div>
<div class="line">  <span class="keywordflow">while</span> (<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> != <a class="code hl_typedef" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>)</div>
<div class="line">    <span class="keywordflow">if</span> (std::isspace(*<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>++))</div>
<div class="line">      <span class="keywordflow">return</span> std::make_pair(<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, <span class="keyword">true</span>);</div>
<div class="line">  <span class="keywordflow">return</span> std::make_pair(<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; e, std::size_t size);</div>
<div class="line">...</div>
<div class="line">asio::streambuf <a class="code hl_variable" href="jpegint_8h.html#af320905358fa78701e4cc60b6135601f">b</a>;</div>
<div class="line">asio::async_read_until(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="jpegint_8h.html#af320905358fa78701e4cc60b6135601f">b</a>, match_whitespace, handler);</div>
<div class="ttc" id="aclassasio_1_1basic__streambuf_html_a9e2ffddcb9e89d68048254ea787c2258"><div class="ttname"><a href="classasio_1_1basic__streambuf.html#a9e2ffddcb9e89d68048254ea787c2258">asio::basic_streambuf::const_buffers_type</a></div><div class="ttdeci">ASIO_CONST_BUFFER const_buffers_type</div><div class="ttdef"><b>Definition</b> basic_streambuf.hpp:122</div></div>
<div class="ttc" id="ajpegint_8h_html_af320905358fa78701e4cc60b6135601f"><div class="ttname"><a href="jpegint_8h.html#af320905358fa78701e4cc60b6135601f">b</a></div><div class="ttdeci">long b</div><div class="ttdef"><b>Definition</b> jpegint.h:371</div></div>
</div><!-- fragment --></dd></dl>
<p>To asynchronously read data into a streambuf until a matching character is found: </p><div class="fragment"><div class="line"> <span class="keyword">class </span>match_char</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> match_char(<span class="keywordtype">char</span> <a class="code hl_variable" href="Spc__Cpu_8h.html#a4e1e0e72dd773439e333c84dd762a9c3">c</a>) : c_(<a class="code hl_variable" href="Spc__Cpu_8h.html#a4e1e0e72dd773439e333c84dd762a9c3">c</a>) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line">  std::pair&lt;Iterator, bool&gt; operator()(</div>
<div class="line">      Iterator begin, Iterator end)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    Iterator <a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> = begin;</div>
<div class="line">    <span class="keywordflow">while</span> (<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> != end)</div>
<div class="line">      <span class="keywordflow">if</span> (c_ == *<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>++)</div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, <span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordflow">return</span> std::make_pair(<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, <span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">char</span> c_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>asio {</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code hl_struct" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt;match_char&gt;</div>
<div class="line">    : <span class="keyword">public</span> boost::true_type {};</div>
<div class="line">} <span class="comment">// namespace asio</span></div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> asio::error_code&amp; e, std::size_t size);</div>
<div class="line">...</div>
<div class="line">asio::streambuf <a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>;</div>
<div class="line">asio::async_read_until(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, match_char(<span class="charliteral">&#39;a&#39;</span>), handler);</div>
<div class="ttc" id="aSpc__Cpu_8h_html_a4e1e0e72dd773439e333c84dd762a9c3"><div class="ttname"><a href="Spc__Cpu_8h.html#a4e1e0e72dd773439e333c84dd762a9c3">c</a></div><div class="ttdeci">int c</div><div class="ttdef"><b>Definition</b> Spc_Cpu.h:147</div></div>
<div class="ttc" id="astructasio_1_1is__match__condition_html"><div class="ttname"><a href="structasio_1_1is__match__condition.html">asio::is_match_condition</a></div><div class="ttdef"><b>Definition</b> read_until.hpp:54</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="af6fdb33a7ac7cc9e014aa3f8a83536f0" name="af6fdb33a7ac7cc9e014aa3f8a83536f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6fdb33a7ac7cc9e014aa3f8a83536f0">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[17/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream, typename Allocator, typename ReadHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence CompletionCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> CompletionCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ReadHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>, <span class="comment">// Result of operation.</span></div>
<div class="line"> </div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes copied into the</span></div>
<div class="line">                                          <span class="comment">// buffers. If an error occurred,</span></div>
<div class="line">                                          <span class="comment">// this will be the  number of</span></div>
<div class="line">                                          <span class="comment">// bytes successfully transferred</span></div>
<div class="line">                                          <span class="comment">// prior to the error.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line">asio::async_read(</div>
<div class="line">   <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(),</div>
<div class="line">   handler); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a642f96a619ad598a51010dfe5aaeadc1" name="a642f96a619ad598a51010dfe5aaeadc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642f96a619ad598a51010dfe5aaeadc1">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[18/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream, typename DynamicBuffer_v1, typename CompletionCondition, typename ReadHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence CompletionCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ReadHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest async_read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async_read_some function.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>, <span class="comment">// Result of operation.</span></div>
<div class="line"> </div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes copied into the</span></div>
<div class="line">                                          <span class="comment">// buffers. If an error occurred,</span></div>
<div class="line">                                          <span class="comment">// this will be the  number of</span></div>
<div class="line">                                          <span class="comment">// bytes successfully transferred</span></div>
<div class="line">                                          <span class="comment">// prior to the error.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11a815252341210b54be7122bad17957" name="a11a815252341210b54be7122bad17957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a815252341210b54be7122bad17957">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[19/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream, typename DynamicBuffer_v1, typename ReadHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence CompletionCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ReadHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>, <span class="comment">// Result of operation.</span></div>
<div class="line"> </div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes copied into the</span></div>
<div class="line">                                          <span class="comment">// buffers. If an error occurred,</span></div>
<div class="line">                                          <span class="comment">// this will be the  number of</span></div>
<div class="line">                                          <span class="comment">// bytes successfully transferred</span></div>
<div class="line">                                          <span class="comment">// prior to the error.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line">asio::async_read(</div>
<div class="line">   <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(),</div>
<div class="line">   handler); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a729111d0a4d1340520c4b141a6901f81" name="a729111d0a4d1340520c4b141a6901f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a729111d0a4d1340520c4b141a6901f81">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[20/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream, typename MutableBufferSequence, typename CompletionCondition, typename ReadHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ReadHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read a certain amount of data from a stream. This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest async_read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async_read_some function.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>, <span class="comment">// Result of operation.</span></div>
<div class="line"> </div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes copied into the</span></div>
<div class="line">                                          <span class="comment">// buffers. If an error occurred,</span></div>
<div class="line">                                          <span class="comment">// this will be the  number of</span></div>
<div class="line">                                          <span class="comment">// bytes successfully transferred</span></div>
<div class="line">                                          <span class="comment">// prior to the error.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line">asio::async_read(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>,</div>
<div class="line">   <a class="code hl_function" href="#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, size),</div>
<div class="line">   <a class="code hl_function" href="#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(32),</div>
<div class="line">   handler); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector. </dd></dl>

</div>
</div>
<a id="a2d26a9486ae3d40639c6a56db6efcd93" name="a2d26a9486ae3d40639c6a56db6efcd93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d26a9486ae3d40639c6a56db6efcd93">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[21/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream, typename Allocator, typename ReadHandler&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MatchCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;<a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ReadHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac02cf8fe9ef8b1078606fd4eb88087a9" name="ac02cf8fe9ef8b1078606fd4eb88087a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02cf8fe9ef8b1078606fd4eb88087a9">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[22/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream, typename DynamicBuffer_v2, typename MatchCondition, typename ReadHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; MatchCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> DynamicBuffer_v2 char <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> DynamicBuffer_v2 <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ReadHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read data into a dynamic buffer sequence until a function object indicates a match. This function is used to asynchronously read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the match condition function object already indicates a match, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; <a class="code hl_variable" href="#a0b30afc4cf6e545180cda990770c535e">match_condition</a>(iterator <a class="code hl_typedef" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>, iterator <a class="code hl_typedef" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1buffers__iterator.html">buffers_iterator&lt;typename DynamicBuffer_v2::const_buffers_type&gt;</a></div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the dynamic buffer sequence&#39;s</span></div>
<div class="line">  <span class="comment">// get area that have been fully consumed by the match</span></div>
<div class="line">  <span class="comment">// function. O if an error occurred.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent async_read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>To asynchronously read data into a <code>std::string</code> until whitespace is encountered: <div class="fragment"><div class="line"> <span class="keyword">typedef</span> <a class="code hl_class" href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a>&lt;</div>
<div class="line">    <a class="code hl_class" href="classasio_1_1const__buffers__1.html">asio::const_buffers_1</a>&gt; iterator;</div>
<div class="line"> </div>
<div class="line">std::pair&lt;iterator, bool&gt;</div>
<div class="line">match_whitespace(iterator <a class="code hl_typedef" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>, iterator <a class="code hl_typedef" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>)</div>
<div class="line">{</div>
<div class="line">  iterator <a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> = <a class="code hl_typedef" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>;</div>
<div class="line">  <span class="keywordflow">while</span> (<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> != <a class="code hl_typedef" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>)</div>
<div class="line">    <span class="keywordflow">if</span> (std::isspace(*<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>++))</div>
<div class="line">      <span class="keywordflow">return</span> std::make_pair(<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, <span class="keyword">true</span>);</div>
<div class="line">  <span class="keywordflow">return</span> std::make_pair(<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; e, std::size_t size);</div>
<div class="line">...</div>
<div class="line">std::string <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>;</div>
<div class="line">asio::async_read_until(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, match_whitespace, handler);</div>
<div class="ttc" id="aclassasio_1_1const__buffers__1_html"><div class="ttname"><a href="classasio_1_1const__buffers__1.html">asio::const_buffers_1</a></div><div class="ttdef"><b>Definition</b> buffer.hpp:306</div></div>
</div><!-- fragment --></dd></dl>
<p>To asynchronously read data into a <code>std::string</code> until a matching character is found: </p><div class="fragment"><div class="line"> <span class="keyword">class </span>match_char</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> match_char(<span class="keywordtype">char</span> <a class="code hl_variable" href="Spc__Cpu_8h.html#a4e1e0e72dd773439e333c84dd762a9c3">c</a>) : c_(<a class="code hl_variable" href="Spc__Cpu_8h.html#a4e1e0e72dd773439e333c84dd762a9c3">c</a>) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line">  std::pair&lt;Iterator, bool&gt; operator()(</div>
<div class="line">      Iterator begin, Iterator end)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    Iterator <a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> = begin;</div>
<div class="line">    <span class="keywordflow">while</span> (<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> != end)</div>
<div class="line">      <span class="keywordflow">if</span> (c_ == *<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>++)</div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, <span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordflow">return</span> std::make_pair(<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, <span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">char</span> c_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>asio {</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code hl_struct" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt;match_char&gt;</div>
<div class="line">    : <span class="keyword">public</span> boost::true_type {};</div>
<div class="line">} <span class="comment">// namespace asio</span></div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> asio::error_code&amp; e, std::size_t size);</div>
<div class="line">...</div>
<div class="line">std::string <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>;</div>
<div class="line">asio::async_read_until(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, match_char(<span class="charliteral">&#39;a&#39;</span>), handler);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1f3e0018c2b969146601261c22c37f58" name="a1f3e0018c2b969146601261c22c37f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3e0018c2b969146601261c22c37f58">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[23/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream, typename DynamicBuffer_v2, typename ReadHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; MatchCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> DynamicBuffer_v2 char <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ReadHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the dynamic buffer sequence's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the dynamic buffer sequence&#39;s</span></div>
<div class="line">  <span class="comment">// get area up to and including the delimiter.</span></div>
<div class="line">  <span class="comment">// 0 if an error occurred.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To asynchronously read data into a <code>std::string</code> until a CR-LF sequence is encountered: <div class="fragment"><div class="line"> std::string <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>;</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; e, std::size_t size)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!e)</div>
<div class="line">  {</div>
<div class="line">    std::string line = <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.substr(0, n);</div>
<div class="line">    <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.erase(0, n);</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">asio::async_read_until(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, <span class="stringliteral">&quot;\r\n&quot;</span>, handler); </div>
</div><!-- fragment --> After the <code>async_read_until</code> operation completes successfully, the string <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the string <code>data</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>async_read_until</code> operation. </dd></dl>

</div>
</div>
<a id="a999d80b70224557c1308f4c491225b9a" name="a999d80b70224557c1308f4c491225b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a999d80b70224557c1308f4c491225b9a">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[24/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream, typename DynamicBuffer_v2, typename ReadHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; MatchCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ReadHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the dynamic buffer sequence's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the dynamic buffer sequence&#39;s</span></div>
<div class="line">  <span class="comment">// get area up to and including the delimiter.</span></div>
<div class="line">  <span class="comment">// 0 if an error occurred.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To asynchronously read data into a <code>std::string</code> until a newline is encountered: <div class="fragment"><div class="line"> std::string <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>;</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; e, std::size_t size)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!e)</div>
<div class="line">  {</div>
<div class="line">    std::string line = <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.substr(0, n);</div>
<div class="line">    <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.erase(0, n);</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">asio::async_read_until(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, <span class="charliteral">&#39;\n&#39;</span>, handler); </div>
</div><!-- fragment --> After the <code>async_read_until</code> operation completes successfully, the buffer <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the buffer <code>data</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>async_read_until</code> operation. </dd></dl>

</div>
</div>
<a id="a70c358b3e3ab127c34d2ee25808c3732" name="a70c358b3e3ab127c34d2ee25808c3732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c358b3e3ab127c34d2ee25808c3732">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[25/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream, typename Allocator, typename ReadHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> MatchCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;<a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ReadHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read data into a streambuf until it contains a specified delimiter. This function is used to asynchronously read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the streambuf's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the streambuf&#39;s get</span></div>
<div class="line">  <span class="comment">// area up to and including the delimiter.</span></div>
<div class="line">  <span class="comment">// 0 if an error occurred.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To asynchronously read data into a streambuf until a newline is encountered: <div class="fragment"><div class="line"> <a class="code hl_typedef" href="#a6a7ba348943527312eeace3492bf32ee">asio::streambuf</a> <a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>;</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; e, std::size_t size)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!e)</div>
<div class="line">  {</div>
<div class="line">    std::istream is(&amp;<a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>);</div>
<div class="line">    std::string line;</div>
<div class="line">    std::getline(is, line);</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">asio::async_read_until(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, <span class="charliteral">&#39;\n&#39;</span>, handler); </div>
</div><!-- fragment --> After the <code>async_read_until</code> operation completes successfully, the buffer <code>b</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>std::getline</code> then extracts the data up to and including the newline (which is discarded), so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span> } </div>
</div><!-- fragment --> The remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>async_read_until</code> operation. </dd></dl>

</div>
</div>
<a id="a0b2efe1bc8fe9d612b77edc297cd99db" name="a0b2efe1bc8fe9d612b77edc297cd99db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2efe1bc8fe9d612b77edc297cd99db">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[26/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream, typename DynamicBuffer_v1, typename MatchCondition, typename ReadHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ReadHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read data into a dynamic buffer sequence until a function object indicates a match. This function is used to asynchronously read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the match condition function object already indicates a match, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; <a class="code hl_variable" href="#a0b30afc4cf6e545180cda990770c535e">match_condition</a>(iterator <a class="code hl_typedef" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>, iterator <a class="code hl_typedef" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1buffers__iterator.html">buffers_iterator&lt;typename DynamicBuffer_v1::const_buffers_type&gt;</a></div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the dynamic buffer sequence&#39;s</span></div>
<div class="line">  <span class="comment">// get area that have been fully consumed by the match</span></div>
<div class="line">  <span class="comment">// function. O if an error occurred.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent async_read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>To asynchronously read data into a <code>std::string</code> until whitespace is encountered: <div class="fragment"><div class="line"> <span class="keyword">typedef</span> <a class="code hl_class" href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a>&lt;</div>
<div class="line">    <a class="code hl_class" href="classasio_1_1const__buffers__1.html">asio::const_buffers_1</a>&gt; iterator;</div>
<div class="line"> </div>
<div class="line">std::pair&lt;iterator, bool&gt;</div>
<div class="line">match_whitespace(iterator <a class="code hl_typedef" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>, iterator <a class="code hl_typedef" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>)</div>
<div class="line">{</div>
<div class="line">  iterator <a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> = <a class="code hl_typedef" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>;</div>
<div class="line">  <span class="keywordflow">while</span> (<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> != <a class="code hl_typedef" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>)</div>
<div class="line">    <span class="keywordflow">if</span> (std::isspace(*<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>++))</div>
<div class="line">      <span class="keywordflow">return</span> std::make_pair(<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, <span class="keyword">true</span>);</div>
<div class="line">  <span class="keywordflow">return</span> std::make_pair(<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; e, std::size_t size);</div>
<div class="line">...</div>
<div class="line">std::string <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>;</div>
<div class="line">asio::async_read_until(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, match_whitespace, handler);</div>
</div><!-- fragment --></dd></dl>
<p>To asynchronously read data into a <code>std::string</code> until a matching character is found: </p><div class="fragment"><div class="line"> <span class="keyword">class </span>match_char</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> match_char(<span class="keywordtype">char</span> <a class="code hl_variable" href="Spc__Cpu_8h.html#a4e1e0e72dd773439e333c84dd762a9c3">c</a>) : c_(<a class="code hl_variable" href="Spc__Cpu_8h.html#a4e1e0e72dd773439e333c84dd762a9c3">c</a>) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line">  std::pair&lt;Iterator, bool&gt; operator()(</div>
<div class="line">      Iterator begin, Iterator end)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    Iterator <a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> = begin;</div>
<div class="line">    <span class="keywordflow">while</span> (<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> != end)</div>
<div class="line">      <span class="keywordflow">if</span> (c_ == *<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>++)</div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, <span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordflow">return</span> std::make_pair(<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, <span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">char</span> c_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>asio {</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code hl_struct" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt;match_char&gt;</div>
<div class="line">    : <span class="keyword">public</span> boost::true_type {};</div>
<div class="line">} <span class="comment">// namespace asio</span></div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> asio::error_code&amp; e, std::size_t size);</div>
<div class="line">...</div>
<div class="line">std::string <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>;</div>
<div class="line">asio::async_read_until(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, match_char(<span class="charliteral">&#39;a&#39;</span>), handler);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="acb346160884658b39dab4802831886f4" name="acb346160884658b39dab4802831886f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb346160884658b39dab4802831886f4">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[27/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream, typename DynamicBuffer_v1, typename ReadHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ReadHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the dynamic buffer sequence's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The number of bytes in the dynamic buffer sequence&#39;s</span></div>
<div class="line">  <span class="comment">// get area up to and including the delimiter.</span></div>
<div class="line">  <span class="comment">// 0 if an error occurred.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To asynchronously read data into a <code>std::string</code> until a CR-LF sequence is encountered: <div class="fragment"><div class="line"> std::string <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>;</div>
<div class="line">...</div>
<div class="line">void handler(<span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; e, std::size_t size)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!e)</div>
<div class="line">  {</div>
<div class="line">    std::string line = <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.substr(0, n);</div>
<div class="line">    <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.erase(0, n);</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">asio::async_read_until(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, <span class="stringliteral">&quot;\r\n&quot;</span>, handler); </div>
</div><!-- fragment --> After the <code>async_read_until</code> operation completes successfully, the string <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the string <code>data</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>async_read_until</code> operation. </dd></dl>

</div>
</div>
<a id="ae7deb94f1e4f209ff535c2fd9ac06ba8" name="ae7deb94f1e4f209ff535c2fd9ac06ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7deb94f1e4f209ff535c2fd9ac06ba8">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[28/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MutableBufferSequence, typename ReadHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ReadHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_ae7deb94f1e4f209ff535c2fd9ac06ba8_cgraph.svg" width="424" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a461c3a69a56dac355730dd6bbddf4ec3" name="a461c3a69a56dac355730dd6bbddf4ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461c3a69a56dac355730dd6bbddf4ec3">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[29/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReadHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ReadHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a461c3a69a56dac355730dd6bbddf4ec3_cgraph.svg" width="424" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ad23b95ef832ce39d3633a273f59b905b" name="ad23b95ef832ce39d3633a273f59b905b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad23b95ef832ce39d3633a273f59b905b">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[30/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream, typename DynamicBuffer_v2, typename CompletionCondition, typename WriteHandler&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DynamicBuffer_v2 <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">WriteHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp; = 0)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write a certain amount of data to a stream. This function is used to asynchronously write a certain number of bytes of data to a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_write_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other write operations (such as async_write, the stream's async_write_some function, or any other composed operations that perform writes) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest async_write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's async_write_some function.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>, <span class="comment">// Result of operation.</span></div>
<div class="line"> </div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes written from the</span></div>
<div class="line">                                          <span class="comment">// buffers. If an error occurred,</span></div>
<div class="line">                                          <span class="comment">// this will be less than the sum</span></div>
<div class="line">                                          <span class="comment">// of the buffer sizes.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post(). </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_ad23b95ef832ce39d3633a273f59b905b_cgraph.svg" width="424" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ae63086926973ee7bc0f93da88ce6c78b" name="ae63086926973ee7bc0f93da88ce6c78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63086926973ee7bc0f93da88ce6c78b">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[31/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream, typename Allocator, typename WriteHandler&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> CompletionCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">WriteHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d760c5d46c4deb1082b15e1bb9f48f9" name="a6d760c5d46c4deb1082b15e1bb9f48f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d760c5d46c4deb1082b15e1bb9f48f9">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[32/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream, typename DynamicBuffer_v1, typename CompletionCondition, typename WriteHandler&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">WriteHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a6d760c5d46c4deb1082b15e1bb9f48f9_cgraph.svg" width="424" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a7b61e40209cec169c7de5fafc16a6f9c" name="a7b61e40209cec169c7de5fafc16a6f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b61e40209cec169c7de5fafc16a6f9c">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[33/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream, typename DynamicBuffer_v1, typename WriteHandler&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">WriteHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write all of the supplied data to a stream. This function is used to asynchronously write a certain number of bytes of data to a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_write_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other write operations (such as async_write, the stream's async_write_some function, or any other composed operations that perform writes) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>, <span class="comment">// Result of operation.</span></div>
<div class="line"> </div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes written from the</span></div>
<div class="line">                                          <span class="comment">// buffers. If an error occurred,</span></div>
<div class="line">                                          <span class="comment">// this will be less than the sum</span></div>
<div class="line">                                          <span class="comment">// of the buffer sizes.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line">asio::async_write(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_function" href="#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, size), handler);</div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<p>Start an asynchronous operation to write all of the supplied data to a stream. This function is used to asynchronously write a certain number of bytes of data to a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_write_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other write operations (such as async_write, the stream's async_write_some function, or any other composed operations that perform writes) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>, <span class="comment">// Result of operation.</span></div>
<div class="line"> </div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes written from the</span></div>
<div class="line">                                          <span class="comment">// buffers. If an error occurred,</span></div>
<div class="line">                                          <span class="comment">// this will be less than the sum</span></div>
<div class="line">                                          <span class="comment">// of the buffer sizes.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<p>Start an asynchronous operation to write all of the supplied data at the specified offset. This function is used to asynchronously write a certain number of bytes of data to a random access device at a specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_write_some_at function, and is known as a <em>composed operation</em>. The program must ensure that the device performs no <em>overlapping</em> write operations (such as async_write_at, the device's async_write_some_at function, or any other composed operations that perform writes) until this operation completes. Operations are overlapping if the regions defined by their offsets, and the numbers of bytes to write, intersect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the AsyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line">asio::async_write_at(d, 42, <a class="code hl_function" href="#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, size), handler);</div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<p>Start an asynchronous operation to write all of the supplied data at the specified offset. This function is used to asynchronously write a certain number of bytes of data to a random access device at a specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_write_some_at function, and is known as a <em>composed operation</em>. The program must ensure that the device performs no <em>overlapping</em> write operations (such as async_write_at, the device's async_write_some_at function, or any other composed operations that perform writes) until this operation completes. Operations are overlapping if the regions defined by their offsets, and the numbers of bytes to write, intersect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the AsyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post(). </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a7b61e40209cec169c7de5fafc16a6f9c_cgraph.svg" width="408" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a5fb5cd33c071fc2aa92ef4f879cf1737" name="a5fb5cd33c071fc2aa92ef4f879cf1737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb5cd33c071fc2aa92ef4f879cf1737">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[34/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream, typename ConstBufferSequence, typename WriteHandler&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence CompletionCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">WriteHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a5fb5cd33c071fc2aa92ef4f879cf1737_cgraph.svg" width="424" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a5a1e5b963aeb45f6fc692c4e1a07ed04" name="a5a1e5b963aeb45f6fc692c4e1a07ed04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a1e5b963aeb45f6fc692c4e1a07ed04">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[35/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream, typename ConstBufferSequence, typename CompletionCondition, typename WriteHandler&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">WriteHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write a certain amount of data to a stream. This function is used to asynchronously write a certain number of bytes of data to a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_write_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other write operations (such as async_write, the stream's async_write_some function, or any other composed operations that perform writes) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest async_write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's async_write_some function.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>, <span class="comment">// Result of operation.</span></div>
<div class="line"> </div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes written from the</span></div>
<div class="line">                                          <span class="comment">// buffers. If an error occurred,</span></div>
<div class="line">                                          <span class="comment">// this will be less than the sum</span></div>
<div class="line">                                          <span class="comment">// of the buffer sizes.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<p>Start an asynchronous operation to write a certain amount of data at the specified offset. This function is used to asynchronously write a certain number of bytes of data to a random access device at a specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_write_some_at function, and is known as a <em>composed operation</em>. The program must ensure that the device performs no <em>overlapping</em> write operations (such as async_write_at, the device's async_write_some_at function, or any other composed operations that perform writes) until this operation completes. Operations are overlapping if the regions defined by their offsets, and the numbers of bytes to write, intersect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the AsyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest async_write_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's async_write_some_at function.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line">asio::async_write_at(d, 42,</div>
<div class="line">   <a class="code hl_function" href="#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, size),</div>
<div class="line">   <a class="code hl_function" href="#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(32),</div>
<div class="line">   handler); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<p>Start an asynchronous operation to write a certain amount of data at the specified offset. This function is used to asynchronously write a certain number of bytes of data to a random access device at a specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_write_some_at function, and is known as a <em>composed operation</em>. The program must ensure that the device performs no <em>overlapping</em> write operations (such as async_write_at, the device's async_write_some_at function, or any other composed operations that perform writes) until this operation completes. Operations are overlapping if the regions defined by their offsets, and the numbers of bytes to write, intersect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the AsyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest async_write_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's async_write_some_at function.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="comment">// Result of operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div>
<div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post(). </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a5a1e5b963aeb45f6fc692c4e1a07ed04_cgraph.svg" width="424" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a0f4d323747c9d0cb131fe8a4e820719b" name="a0f4d323747c9d0cb131fe8a4e820719b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f4d323747c9d0cb131fe8a4e820719b">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[36/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream, typename Allocator, typename WriteHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence CompletionCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> CompletionCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">WriteHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write all of the supplied data to a stream. This function is used to asynchronously write a certain number of bytes of data to a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_write_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other write operations (such as async_write, the stream's async_write_some function, or any other composed operations that perform writes) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>, <span class="comment">// Result of operation.</span></div>
<div class="line"> </div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes written from the</span></div>
<div class="line">                                          <span class="comment">// buffers. If an error occurred,</span></div>
<div class="line">                                          <span class="comment">// this will be less than the sum</span></div>
<div class="line">                                          <span class="comment">// of the buffer sizes.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80196643d36e182e957d443d4635427c" name="a80196643d36e182e957d443d4635427c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80196643d36e182e957d443d4635427c">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[37/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream, typename DynamicBuffer_v1, typename CompletionCondition, typename WriteHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence CompletionCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">WriteHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write a certain amount of data to a stream. This function is used to asynchronously write a certain number of bytes of data to a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_write_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other write operations (such as async_write, the stream's async_write_some function, or any other composed operations that perform writes) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest async_write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's async_write_some function.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>, <span class="comment">// Result of operation.</span></div>
<div class="line"> </div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes written from the</span></div>
<div class="line">                                          <span class="comment">// buffers. If an error occurred,</span></div>
<div class="line">                                          <span class="comment">// this will be less than the sum</span></div>
<div class="line">                                          <span class="comment">// of the buffer sizes.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1c38825940ed7ac93c5491e8afc69e9" name="af1c38825940ed7ac93c5491e8afc69e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c38825940ed7ac93c5491e8afc69e9">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[38/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream, typename DynamicBuffer_v1, typename WriteHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence CompletionCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">WriteHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write all of the supplied data to a stream. This function is used to asynchronously write a certain number of bytes of data to a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_write_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other write operations (such as async_write, the stream's async_write_some function, or any other composed operations that perform writes) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>, <span class="comment">// Result of operation.</span></div>
<div class="line"> </div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes written from the</span></div>
<div class="line">                                          <span class="comment">// buffers. If an error occurred,</span></div>
<div class="line">                                          <span class="comment">// this will be less than the sum</span></div>
<div class="line">                                          <span class="comment">// of the buffer sizes.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ae1706a25367978314f34e4fe5a3854" name="a9ae1706a25367978314f34e4fe5a3854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae1706a25367978314f34e4fe5a3854">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[39/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream, typename ConstBufferSequence, typename CompletionCondition, typename WriteHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> * asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">WriteHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write a certain amount of data to a stream. This function is used to asynchronously write a certain number of bytes of data to a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_write_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other write operations (such as async_write, the stream's async_write_some function, or any other composed operations that perform writes) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest async_write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's async_write_some function.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>, <span class="comment">// Result of operation.</span></div>
<div class="line"> </div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes written from the</span></div>
<div class="line">                                          <span class="comment">// buffers. If an error occurred,</span></div>
<div class="line">                                          <span class="comment">// this will be less than the sum</span></div>
<div class="line">                                          <span class="comment">// of the buffer sizes.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line">asio::async_write(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>,</div>
<div class="line">   <a class="code hl_function" href="#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, size),</div>
<div class="line">   <a class="code hl_function" href="#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(32),</div>
<div class="line">   handler); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector. </dd></dl>

</div>
</div>
<a id="aae155d327b1f08e08ca04fad48cf39b9" name="aae155d327b1f08e08ca04fad48cf39b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae155d327b1f08e08ca04fad48cf39b9">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[40/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConstBufferSequence, typename WriteHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">WriteHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_aae155d327b1f08e08ca04fad48cf39b9_cgraph.svg" width="424" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a83cc551c7151133f0292ec21e4d08647" name="a83cc551c7151133f0292ec21e4d08647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83cc551c7151133f0292ec21e4d08647">&#9670;&#160;</a></span>ASIO_INITFN_RESULT_TYPE() <span class="overload">[41/41]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename WriteHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">WriteHandler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a83cc551c7151133f0292ec21e4d08647_cgraph.svg" width="424" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a8d01fccd641197c92ea3430755174bc7" name="a8d01fccd641197c92ea3430755174bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d01fccd641197c92ea3430755174bc7">&#9670;&#160;</a></span>ASIO_MOVE_ARG() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asio::ASIO_MOVE_ARG </td>
          <td>(</td>
          <td class="paramtype">DynamicBuffer_v1</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a8d01fccd641197c92ea3430755174bc7_cgraph.svg" width="338" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ad430339c3225c5e715a0dc9fb8a1fec8" name="ad430339c3225c5e715a0dc9fb8a1fec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad430339c3225c5e715a0dc9fb8a1fec8">&#9670;&#160;</a></span>ASIO_MOVE_ARG() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Executor <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> Executor Iterator asio::ASIO_MOVE_ARG </td>
          <td>(</td>
          <td class="paramtype">IteratorConnectHandler</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_ad430339c3225c5e715a0dc9fb8a1fec8_cgraph.svg" width="352" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aa83ebf40e1378cd1060cd903baaf294f" name="aa83ebf40e1378cd1060cd903baaf294f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa83ebf40e1378cd1060cd903baaf294f">&#9670;&#160;</a></span>ASIO_MOVE_ARG() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Executor <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence asio::ASIO_MOVE_ARG </td>
          <td>(</td>
          <td class="paramtype">RangeConnectHandler</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec3a9e489c8dd295db16f2d8f58fa528" name="aec3a9e489c8dd295db16f2d8f58fa528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3a9e489c8dd295db16f2d8f58fa528">&#9670;&#160;</a></span>ASIO_MOVE_ARG() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence CompletionCondition asio::ASIO_MOVE_ARG </td>
          <td>(</td>
          <td class="paramtype">ReadHandler</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7400ce0053da9b64c94220331137bc1d" name="a7400ce0053da9b64c94220331137bc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7400ce0053da9b64c94220331137bc1d">&#9670;&#160;</a></span>ASIO_MOVE_ARG() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence CompletionCondition asio::ASIO_MOVE_ARG </td>
          <td>(</td>
          <td class="paramtype">WriteHandler</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5278b4c4bcd1303ce616b2f0fff4c395" name="a5278b4c4bcd1303ce616b2f0fff4c395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5278b4c4bcd1303ce616b2f0fff4c395">&#9670;&#160;</a></span>async_compose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken, typename Signature, typename Implementation&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">asio::async_compose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(Implementation)</td>          <td class="paramname"><span class="paramname"><em>implementation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config_8hpp.html#abe8a635435f7cc0358f9b4134b6b424e">ASIO_NONDEDUCED_MOVE_ARG</a>(CompletionToken)</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a5278b4c4bcd1303ce616b2f0fff4c395_cgraph.svg" width="335" height="102"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a5278b4c4bcd1303ce616b2f0fff4c395_icgraph.svg" width="156" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ab07c4636cfad1cd03404f9372cda419a" name="ab07c4636cfad1cd03404f9372cda419a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07c4636cfad1cd03404f9372cda419a">&#9670;&#160;</a></span>async_initiate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken, typename Signature, typename Initiation&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structasio_1_1detail_1_1async__result__has__initiate__memfn.html">detail::async_result_has_initiate_memfn</a>&lt; CompletionToken, Signature &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a>, <a class="el" href="#aeafc22dcf4397b1b5f52ced939a55203">ASIO_INITFN_RESULT_TYPE</a>(CompletionToken, Signature)&gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> asio::async_initiate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(Initiation)</td>          <td class="paramname"><span class="paramname"><em>initiation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config_8hpp.html#abe8a635435f7cc0358f9b4134b6b424e">ASIO_NONDEDUCED_MOVE_ARG</a>(CompletionToken)</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_ab07c4636cfad1cd03404f9372cda419a_cgraph.svg" width="338" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aed2f96583612003958535ed0e116650c" name="aed2f96583612003958535ed0e116650c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2f96583612003958535ed0e116650c">&#9670;&#160;</a></span>async_initiate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken, typename Signature, typename Initiation&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1detail_1_1async__result__has__initiate__memfn.html">detail::async_result_has_initiate_memfn</a>&lt; CompletionToken, Signature &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a>, <a class="el" href="#aeafc22dcf4397b1b5f52ced939a55203">ASIO_INITFN_RESULT_TYPE</a>(CompletionToken, Signature)&gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> asio::async_initiate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(Initiation)</td>          <td class="paramname"><span class="paramname"><em>initiation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config_8hpp.html#abe8a635435f7cc0358f9b4134b6b424e">ASIO_NONDEDUCED_MOVE_ARG</a>(CompletionToken)</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_aed2f96583612003958535ed0e116650c_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a739600dc1b0a8e68342342f7a5ecfe2c" name="a739600dc1b0a8e68342342f7a5ecfe2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739600dc1b0a8e68342342f7a5ecfe2c">&#9670;&#160;</a></span>async_initiate&lt; ReadHandler, void(asio::error_code, std::size_t)&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> CompletionCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typenamedecay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *return <a class="el" href="#aed2f96583612003958535ed0e116650c">asio::async_initiate</a>&lt; ReadHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasio_1_1detail_1_1initiate__async__read__dynbuf__v1.html">detail::initiate_async_read_dynbuf_v1</a>()</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">handler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config_8hpp.html#a746be5b8f1f4110bc1e7a836afa08ee4">ASIO_MOVE_CAST</a>(DynamicBuffer_v1)(<a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config_8hpp.html#a746be5b8f1f4110bc1e7a836afa08ee4">ASIO_MOVE_CAST</a>(CompletionCondition)(<a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a739600dc1b0a8e68342342f7a5ecfe2c_cgraph.svg" width="356" height="67"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a875e856ec74ea026d0c5915f1c43f3f8" name="a875e856ec74ea026d0c5915f1c43f3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a875e856ec74ea026d0c5915f1c43f3f8">&#9670;&#160;</a></span>async_initiate&lt; ReadHandler, void(asio::error_code, std::size_t)&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DynamicBuffer_v2 <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> DynamicBuffer_v2 CompletionCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *return <a class="el" href="#aed2f96583612003958535ed0e116650c">asio::async_initiate</a>&lt; ReadHandler, <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a>(<a class="el" href="classasio_1_1error__code.html">asio::error_code</a>, std::size_t)&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasio_1_1detail_1_1initiate__async__read__dynbuf__v2.html">detail::initiate_async_read_dynbuf_v2</a>()</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">handler</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config_8hpp.html#a746be5b8f1f4110bc1e7a836afa08ee4">ASIO_MOVE_CAST</a>(DynamicBuffer_v2)(<a class="el" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="config_8hpp.html#a746be5b8f1f4110bc1e7a836afa08ee4">ASIO_MOVE_CAST</a>(CompletionCondition)(<a class="el" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>)</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a875e856ec74ea026d0c5915f1c43f3f8_cgraph.svg" width="356" height="67"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a6eb37798be50fabce361ea541f359084" name="a6eb37798be50fabce361ea541f359084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb37798be50fabce361ea541f359084">&#9670;&#160;</a></span>bind_executor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor, typename <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1executor__binder.html">executor_binder</a>&lt; typename decay&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a>, Executor &gt; asio::bind_executor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Executor &amp;</td>          <td class="paramname"><span class="paramname"><em>ex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(<a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>)</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associate an object of type <code>T</code> with an executor of type <code>Executor</code>. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a6eb37798be50fabce361ea541f359084_icgraph.svg" width="280" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="af0bf8af34d9c5e59fd066a8502d3087b" name="af0bf8af34d9c5e59fd066a8502d3087b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0bf8af34d9c5e59fd066a8502d3087b">&#9670;&#160;</a></span>bind_executor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext, typename <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1executor__binder.html">executor_binder</a>&lt; typename decay&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a>, typename ExecutionContext::executor_type &gt; asio::bind_executor </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(<a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>)</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associate an object of type <code>T</code> with an execution context's executor. </p>

</div>
</div>
<a id="ab33ce05280e1d634d9c3a06e473ab7e3" name="ab33ce05280e1d634d9c3a06e473ab7e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33ce05280e1d634d9c3a06e473ab7e3">&#9670;&#160;</a></span>buffer() <span class="overload">[1/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1array.html">boost::array</a>&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> PodType, <a class="el" href="interface_8cc.html#a0240ac851181b84ac374872dc5434ee4">N</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1const__buffer.html">const_buffer</a>(</div>
<div class="line">   <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.data(),</div>
<div class="line">   <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.size() * <span class="keyword">sizeof</span>(PodType)); </div>
<div class="ttc" id="aclassasio_1_1const__buffer_html"><div class="ttname"><a href="classasio_1_1const__buffer.html">asio::const_buffer</a></div><div class="ttdoc">Holds a buffer that cannot be modified.</div><div class="ttdef"><b>Definition</b> buffer.hpp:225</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ac8610fbc63212d464bafb1543716ba5c" name="ac8610fbc63212d464bafb1543716ba5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8610fbc63212d464bafb1543716ba5c">&#9670;&#160;</a></span>buffer() <span class="overload">[2/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1array.html">boost::array</a>&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> PodType, <a class="el" href="interface_8cc.html#a0240ac851181b84ac374872dc5434ee4">N</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1const__buffer.html">const_buffer</a>(</div>
<div class="line">   <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.data(),</div>
<div class="line">   <a class="code hl_define" href="os_8h.html#abb702d8b501669a23aa0ab3b281b9384">min</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.size() * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
<div class="ttc" id="aos_8h_html_abb702d8b501669a23aa0ab3b281b9384"><div class="ttname"><a href="os_8h.html#abb702d8b501669a23aa0ab3b281b9384">min</a></div><div class="ttdeci">#define min(x, y)</div><div class="ttdef"><b>Definition</b> os.h:74</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad9d36bcb3c3178a352c89b8752a0b6f7" name="ad9d36bcb3c3178a352c89b8752a0b6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d36bcb3c3178a352c89b8752a0b6f7">&#9670;&#160;</a></span>buffer() <span class="overload">[3/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, <a class="el" href="interface_8cc.html#a0240ac851181b84ac374872dc5434ee4">N</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>(</div>
<div class="line">   <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.data(),</div>
<div class="line">   <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.size() * <span class="keyword">sizeof</span>(PodType)); </div>
<div class="ttc" id="aclassasio_1_1mutable__buffer_html"><div class="ttname"><a href="classasio_1_1mutable__buffer.html">asio::mutable_buffer</a></div><div class="ttdoc">Holds a buffer that can be modified.</div><div class="ttdef"><b>Definition</b> buffer.hpp:91</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="afa50ee8a50ea8e3de2a4e24a3f479712" name="afa50ee8a50ea8e3de2a4e24a3f479712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa50ee8a50ea8e3de2a4e24a3f479712">&#9670;&#160;</a></span>buffer() <span class="overload">[4/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, <a class="el" href="interface_8cc.html#a0240ac851181b84ac374872dc5434ee4">N</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>(</div>
<div class="line">   <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.data(),</div>
<div class="line">   <a class="code hl_define" href="os_8h.html#abb702d8b501669a23aa0ab3b281b9384">min</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.size() * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa62463079331806495a6822204fbceec" name="aa62463079331806495a6822204fbceec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62463079331806495a6822204fbceec">&#9670;&#160;</a></span>buffer() <span class="overload">[5/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, <a class="el" href="interface_8cc.html#a0240ac851181b84ac374872dc5434ee4">N</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1const__buffer.html">const_buffer</a>(</div>
<div class="line">   <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.data(),</div>
<div class="line">   <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.size() * <span class="keyword">sizeof</span>(PodType)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a66ca9f4c43d4aebdd2beba9488f99243" name="a66ca9f4c43d4aebdd2beba9488f99243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ca9f4c43d4aebdd2beba9488f99243">&#9670;&#160;</a></span>buffer() <span class="overload">[6/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classboost_1_1array.html">boost::array</a>&lt; PodType, <a class="el" href="interface_8cc.html#a0240ac851181b84ac374872dc5434ee4">N</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1const__buffer.html">const_buffer</a>(</div>
<div class="line">   <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.data(),</div>
<div class="line">   <a class="code hl_define" href="os_8h.html#abb702d8b501669a23aa0ab3b281b9384">min</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.size() * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a49fedcbcde972dfb6078ff550a59e49c" name="a49fedcbcde972dfb6078ff550a59e49c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49fedcbcde972dfb6078ff550a59e49c">&#9670;&#160;</a></span>buffer() <span class="overload">[7/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer from an existing buffer. </p>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">const_buffer(b)</span>. </dd></dl>

</div>
</div>
<a id="af6d68320baa8d46472e6182c8980a881" name="af6d68320baa8d46472e6182c8980a881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d68320baa8d46472e6182c8980a881">&#9670;&#160;</a></span>buffer() <span class="overload">[8/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer from an existing buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1const__buffer.html">const_buffer</a>(</div>
<div class="line">   <a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>.data(),</div>
<div class="line">   <a class="code hl_define" href="os_8h.html#abb702d8b501669a23aa0ab3b281b9384">min</a>(<a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>.size(), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aab2e5a8bd2a00b088a5644c64ef73e2a" name="aab2e5a8bd2a00b088a5644c64ef73e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2e5a8bd2a00b088a5644c64ef73e2a">&#9670;&#160;</a></span>buffer() <span class="overload">[9/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer from an existing buffer. </p>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">mutable_buffer(b)</span>. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_aab2e5a8bd2a00b088a5644c64ef73e2a_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a09f2e959219011f793a85389e272d608" name="a09f2e959219011f793a85389e272d608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f2e959219011f793a85389e272d608">&#9670;&#160;</a></span>buffer() <span class="overload">[10/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer from an existing buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>(</div>
<div class="line">   <a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>.data(),</div>
<div class="line">   <a class="code hl_define" href="os_8h.html#abb702d8b501669a23aa0ab3b281b9384">min</a>(<a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>.size(), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3f4a8399dc1d37dc59fbfb1a022a9f41" name="a3f4a8399dc1d37dc59fbfb1a022a9f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4a8399dc1d37dc59fbfb1a022a9f41">&#9670;&#160;</a></span>buffer() <span class="overload">[11/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> PodType(&amp;)</td>          <td class="paramname"><span class="paramname"><em>data</em></span>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1const__buffer.html">const_buffer</a>(</div>
<div class="line">   <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>),</div>
<div class="line">   <a class="code hl_define" href="interface_8cc.html#a0240ac851181b84ac374872dc5434ee4">N</a> * <span class="keyword">sizeof</span>(PodType)); </div>
<div class="ttc" id="ainterface_8cc_html_a0240ac851181b84ac374872dc5434ee4"><div class="ttname"><a href="interface_8cc.html#a0240ac851181b84ac374872dc5434ee4">N</a></div><div class="ttdeci">#define N</div><div class="ttdef"><b>Definition</b> interface.cc:58</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="afb8ba631a53bb59557e5d0518d450d09" name="afb8ba631a53bb59557e5d0518d450d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb8ba631a53bb59557e5d0518d450d09">&#9670;&#160;</a></span>buffer() <span class="overload">[12/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> PodType(&amp;)</td>          <td class="paramname"><span class="paramname"><em>data</em></span>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1const__buffer.html">const_buffer</a>(</div>
<div class="line">   <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>),</div>
<div class="line">   <a class="code hl_define" href="os_8h.html#abb702d8b501669a23aa0ab3b281b9384">min</a>(<a class="code hl_define" href="interface_8cc.html#a0240ac851181b84ac374872dc5434ee4">N</a> * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a87b1758913fefb7f8ddf03bbb22ead2a" name="a87b1758913fefb7f8ddf03bbb22ead2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b1758913fefb7f8ddf03bbb22ead2a">&#9670;&#160;</a></span>buffer() <span class="overload">[13/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem, typename Traits, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given string. </p>
<dl class="section return"><dt>Returns</dt><dd><span class="tt"><a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a>(data.data(), data.size() * sizeof(Elem))</span>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any non-const operation called on the given string object. </dd></dl>

</div>
</div>
<a id="ad1e98367b9e0233f03d1b918043c3093" name="ad1e98367b9e0233f03d1b918043c3093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e98367b9e0233f03d1b918043c3093">&#9670;&#160;</a></span>buffer() <span class="overload">[14/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem, typename Traits, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given string. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1const__buffer.html">const_buffer</a>(</div>
<div class="line">   <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.data(),</div>
<div class="line">   <a class="code hl_define" href="os_8h.html#abb702d8b501669a23aa0ab3b281b9384">min</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.size() * <span class="keyword">sizeof</span>(Elem), max_size_in_bytes)); </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any non-const operation called on the given string object. </dd></dl>

</div>
</div>
<a id="a5b3392160817dd6911a156cac82e8bdb" name="a5b3392160817dd6911a156cac82e8bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b3392160817dd6911a156cac82e8bdb">&#9670;&#160;</a></span>buffer() <span class="overload">[15/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::vector&lt; PodType, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD vector. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1const__buffer.html">const_buffer</a>(</div>
<div class="line">   <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.size() ? &amp;<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>[0] : 0,</div>
<div class="line">   <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.size() * <span class="keyword">sizeof</span>(PodType)); </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any vector operation that would also invalidate iterators. </dd></dl>

</div>
</div>
<a id="acc892c137c8804fbbaa23d09a0fb5195" name="acc892c137c8804fbbaa23d09a0fb5195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc892c137c8804fbbaa23d09a0fb5195">&#9670;&#160;</a></span>buffer() <span class="overload">[16/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::vector&lt; PodType, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD vector. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1const__buffer.html">const_buffer</a>(</div>
<div class="line">   <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.size() ? &amp;<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>[0] : 0,</div>
<div class="line">   <a class="code hl_define" href="os_8h.html#abb702d8b501669a23aa0ab3b281b9384">min</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.size() * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any vector operation that would also invalidate iterators. </dd></dl>

</div>
</div>
<a id="ad4316c04382a05008f8cf5a43b731e1c" name="ad4316c04382a05008f8cf5a43b731e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4316c04382a05008f8cf5a43b731e1c">&#9670;&#160;</a></span>buffer() <span class="overload">[17/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buffer_8hpp.html#a7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a> *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given memory range. </p>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">const_buffer(data, size_in_bytes)</span>. </dd></dl>

</div>
</div>
<a id="ad5e3fe0e83a1753131eee9363e36c4f1" name="ad5e3fe0e83a1753131eee9363e36c4f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e3fe0e83a1753131eee9363e36c4f1">&#9670;&#160;</a></span>buffer() <span class="overload">[18/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">PodType(&amp;)</td>          <td class="paramname"><span class="paramname"><em>data</em></span>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>(</div>
<div class="line">   <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>),</div>
<div class="line">   <a class="code hl_define" href="interface_8cc.html#a0240ac851181b84ac374872dc5434ee4">N</a> * <span class="keyword">sizeof</span>(PodType)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a6718b1a29f43038bd66424e814f85dfa" name="a6718b1a29f43038bd66424e814f85dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6718b1a29f43038bd66424e814f85dfa">&#9670;&#160;</a></span>buffer() <span class="overload">[19/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">PodType(&amp;)</td>          <td class="paramname"><span class="paramname"><em>data</em></span>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>(</div>
<div class="line">   <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>),</div>
<div class="line">   <a class="code hl_define" href="os_8h.html#abb702d8b501669a23aa0ab3b281b9384">min</a>(<a class="code hl_define" href="interface_8cc.html#a0240ac851181b84ac374872dc5434ee4">N</a> * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad668759a45f9234b9f0680d4e264d908" name="ad668759a45f9234b9f0680d4e264d908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad668759a45f9234b9f0680d4e264d908">&#9670;&#160;</a></span>buffer() <span class="overload">[20/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem, typename Traits, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given string. </p>
<dl class="section return"><dt>Returns</dt><dd><span class="tt"><a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a>(data.size() ? &amp;<a class="el" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>[0] : 0,
data.size() * sizeof(Elem))</span>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any non-const operation called on the given string object. </dd></dl>

</div>
</div>
<a id="a1652342c5fa036d0cf87d437b5807370" name="a1652342c5fa036d0cf87d437b5807370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1652342c5fa036d0cf87d437b5807370">&#9670;&#160;</a></span>buffer() <span class="overload">[21/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem, typename Traits, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given string. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>(</div>
<div class="line">   <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.size() ? &amp;<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>[0] : 0,</div>
<div class="line">   <a class="code hl_define" href="os_8h.html#abb702d8b501669a23aa0ab3b281b9384">min</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.size() * <span class="keyword">sizeof</span>(Elem), max_size_in_bytes)); </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any non-const operation called on the given string object. </dd></dl>

</div>
</div>
<a id="a3bcd62537bad84dcf220ebb6d7c98fce" name="a3bcd62537bad84dcf220ebb6d7c98fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bcd62537bad84dcf220ebb6d7c98fce">&#9670;&#160;</a></span>buffer() <span class="overload">[22/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; PodType, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD vector. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>(</div>
<div class="line">   <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.size() ? &amp;<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>[0] : 0,</div>
<div class="line">   <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.size() * <span class="keyword">sizeof</span>(PodType)); </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any vector operation that would also invalidate iterators. </dd></dl>

</div>
</div>
<a id="ab259071c0eb07d60166a241ae6897fa5" name="ab259071c0eb07d60166a241ae6897fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab259071c0eb07d60166a241ae6897fa5">&#9670;&#160;</a></span>buffer() <span class="overload">[23/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; PodType, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD vector. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>(</div>
<div class="line">   <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.size() ? &amp;<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>[0] : 0,</div>
<div class="line">   <a class="code hl_define" href="os_8h.html#abb702d8b501669a23aa0ab3b281b9384">min</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.size() * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any vector operation that would also invalidate iterators. </dd></dl>

</div>
</div>
<a id="a47e3d0ebd0117a592b5dfe84cb1d8ffa" name="a47e3d0ebd0117a592b5dfe84cb1d8ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e3d0ebd0117a592b5dfe84cb1d8ffa">&#9670;&#160;</a></span>buffer() <span class="overload">[24/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buffer_8hpp.html#ab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a> *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size_in_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given memory range. </p>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">mutable_buffer(data, size_in_bytes)</span>. </dd></dl>

</div>
</div>
<a id="adcf1d874ce546b0f5ef250e25952094f" name="adcf1d874ce546b0f5ef250e25952094f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf1d874ce546b0f5ef250e25952094f">&#9670;&#160;</a></span>buffer_cast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointerToPodType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointerToPodType asio::buffer_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast a non-modifiable buffer to a specified pointer to POD type. </p>

</div>
</div>
<a id="ad4f92bea5381ff9a3074af1157b267dd" name="ad4f92bea5381ff9a3074af1157b267dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f92bea5381ff9a3074af1157b267dd">&#9670;&#160;</a></span>buffer_cast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointerToPodType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointerToPodType asio::buffer_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast a non-modifiable buffer to a specified pointer to POD type. </p>

</div>
</div>
<a id="a160d0c4badd630c133c213c66b095fc1" name="a160d0c4badd630c133c213c66b095fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a160d0c4badd630c133c213c66b095fc1">&#9670;&#160;</a></span>buffer_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MutableBufferSequence, typename ConstBufferSequence&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::buffer_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies bytes from a source buffer sequence to a target buffer sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>A modifiable buffer sequence representing the memory regions to which the bytes will be copied.</td></tr>
    <tr><td class="paramname">source</td><td>A non-modifiable buffer sequence representing the memory regions from which the bytes will be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The number of bytes copied is the lesser of:</dd></dl>
<ul>
<li><code>buffer_size(target)</code> </li>
</ul>
<ul>
<li><code>buffer_size(source)</code> </li>
</ul>
<p>This function is implemented in terms of <code>memcpy</code>, and consequently it cannot be used to copy between overlapping memory regions. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a160d0c4badd630c133c213c66b095fc1_cgraph.svg" width="100%" height="493"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a160d0c4badd630c133c213c66b095fc1_icgraph.svg" width="382" height="342"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a39d2fd7acd66546ce9e539753618bb75" name="a39d2fd7acd66546ce9e539753618bb75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d2fd7acd66546ce9e539753618bb75">&#9670;&#160;</a></span>buffer_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MutableBufferSequence, typename ConstBufferSequence&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::buffer_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_bytes_to_copy</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies a limited number of bytes from a source buffer sequence to a target buffer sequence. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>A modifiable buffer sequence representing the memory regions to which the bytes will be copied.</td></tr>
    <tr><td class="paramname">source</td><td>A non-modifiable buffer sequence representing the memory regions from which the bytes will be copied.</td></tr>
    <tr><td class="paramname">max_bytes_to_copy</td><td>The maximum number of bytes to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The number of bytes copied is the lesser of:</dd></dl>
<ul>
<li><code>buffer_size(target)</code> </li>
</ul>
<ul>
<li><code>buffer_size(source)</code> </li>
</ul>
<ul>
<li><code>max_bytes_to_copy</code> </li>
</ul>
<p>This function is implemented in terms of <code>memcpy</code>, and consequently it cannot be used to copy between overlapping memory regions. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a39d2fd7acd66546ce9e539753618bb75_cgraph.svg" width="100%" height="493"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a4cb86c7fe7314eb7f0cb8391ac94d4cd" name="a4cb86c7fe7314eb7f0cb8391ac94d4cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb86c7fe7314eb7f0cb8391ac94d4cd">&#9670;&#160;</a></span>buffer_sequence_begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">C::iterator asio::buffer_sequence_begin </td>
          <td>(</td>
          <td class="paramtype">C &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; !is_convertible&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> C *, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!is_convertible&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> C *, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adaf169b3f69489851a2ec786d389d297" name="adaf169b3f69489851a2ec786d389d297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf169b3f69489851a2ec786d389d297">&#9670;&#160;</a></span>buffer_sequence_begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">C::const_iterator asio::buffer_sequence_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> C &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; !is_convertible&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> C *, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!is_convertible&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> C *, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63f3e98466965a1c184ae33b448d0948" name="a63f3e98466965a1c184ae33b448d0948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f3e98466965a1c184ae33b448d0948">&#9670;&#160;</a></span>buffer_sequence_begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConstBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * asio::buffer_sequence_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBuffer &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; is_convertible&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBuffer *, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the first element in a buffer sequence. </p>

</div>
</div>
<a id="a531e6aceb9629aa4c2b760b0d6b83562" name="a531e6aceb9629aa4c2b760b0d6b83562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531e6aceb9629aa4c2b760b0d6b83562">&#9670;&#160;</a></span>buffer_sequence_begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MutableBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * asio::buffer_sequence_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBuffer &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; is_convertible&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBuffer *, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the first element in a buffer sequence. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a531e6aceb9629aa4c2b760b0d6b83562_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a48c0cfb5e2c1894048db8cc679f99996" name="a48c0cfb5e2c1894048db8cc679f99996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c0cfb5e2c1894048db8cc679f99996">&#9670;&#160;</a></span>buffer_sequence_end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">C::iterator asio::buffer_sequence_end </td>
          <td>(</td>
          <td class="paramtype">C &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; !is_convertible&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> C *, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!is_convertible&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> C *, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adc4b5c460b980a645c3c63fdd9a0b947" name="adc4b5c460b980a645c3c63fdd9a0b947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4b5c460b980a645c3c63fdd9a0b947">&#9670;&#160;</a></span>buffer_sequence_end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">C::const_iterator asio::buffer_sequence_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> C &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; !is_convertible&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> C *, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!is_convertible&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> C *, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abb326f21bb60b07149a56f7e247956bb" name="abb326f21bb60b07149a56f7e247956bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb326f21bb60b07149a56f7e247956bb">&#9670;&#160;</a></span>buffer_sequence_end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConstBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * asio::buffer_sequence_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBuffer &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; is_convertible&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBuffer *, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> * &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to one past the end element in a buffer sequence. </p>

</div>
</div>
<a id="a41da7709ea67abc77cedf607650c68c7" name="a41da7709ea67abc77cedf607650c68c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41da7709ea67abc77cedf607650c68c7">&#9670;&#160;</a></span>buffer_sequence_end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MutableBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * asio::buffer_sequence_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBuffer &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; is_convertible&lt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBuffer *, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> * &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to one past the end element in a buffer sequence. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a41da7709ea67abc77cedf607650c68c7_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="ac72f80e47f237b42d777bd7eb2653798" name="ac72f80e47f237b42d777bd7eb2653798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72f80e47f237b42d777bd7eb2653798">&#9670;&#160;</a></span>buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferSequence&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::buffer_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> BufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number of bytes in a buffer sequence. </p>
<p>The <code>buffer_size</code> function determines the total size of all buffers in the buffer sequence, as if computed as follows:</p>
<div class="fragment"><div class="line"> <span class="keywordtype">size_t</span> total_size = 0;</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> = <a class="code hl_function" href="#a531e6aceb9629aa4c2b760b0d6b83562">asio::buffer_sequence_begin</a>(<a class="code hl_variable" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>);</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_typedef" href="#ab90565a6d8a05fc349e42527443ca30f">end</a> = <a class="code hl_function" href="#a41da7709ea67abc77cedf607650c68c7">asio::buffer_sequence_end</a>(<a class="code hl_variable" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>);</div>
<div class="line"><span class="keywordflow">for</span> (; <a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> != <a class="code hl_typedef" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>; ++<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_class" href="classasio_1_1const__buffer.html">const_buffer</a> <a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>(*<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>);</div>
<div class="line">  total_size += <a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>.size();</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">return</span> total_size; </div>
<div class="ttc" id="anamespaceasio_html_a41da7709ea67abc77cedf607650c68c7"><div class="ttname"><a href="#a41da7709ea67abc77cedf607650c68c7">asio::buffer_sequence_end</a></div><div class="ttdeci">const mutable_buffer * buffer_sequence_end(const MutableBuffer &amp;b, typename enable_if&lt; is_convertible&lt; const MutableBuffer *, const mutable_buffer * &gt;::value &gt;::type *=0) ASIO_NOEXCEPT</div><div class="ttdoc">Get an iterator to one past the end element in a buffer sequence.</div><div class="ttdef"><b>Definition</b> buffer.hpp:463</div></div>
<div class="ttc" id="anamespaceasio_html_a531e6aceb9629aa4c2b760b0d6b83562"><div class="ttname"><a href="#a531e6aceb9629aa4c2b760b0d6b83562">asio::buffer_sequence_begin</a></div><div class="ttdeci">const mutable_buffer * buffer_sequence_begin(const MutableBuffer &amp;b, typename enable_if&lt; is_convertible&lt; const MutableBuffer *, const mutable_buffer * &gt;::value &gt;::type *=0) ASIO_NOEXCEPT</div><div class="ttdoc">Get an iterator to the first element in a buffer sequence.</div><div class="ttdef"><b>Definition</b> buffer.hpp:386</div></div>
</div><!-- fragment --><p>The <code>BufferSequence</code> template parameter may meet either of the <code>ConstBufferSequence</code> or <code>MutableBufferSequence</code> type requirements. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_ac72f80e47f237b42d777bd7eb2653798_cgraph.svg" width="518" height="159"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_ac72f80e47f237b42d777bd7eb2653798_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a42e267c80155b2747d041d2932357762" name="a42e267c80155b2747d041d2932357762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e267c80155b2747d041d2932357762">&#9670;&#160;</a></span>buffers_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferSequence&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1buffers__iterator.html">buffers_iterator</a>&lt; BufferSequence &gt; asio::buffers_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> BufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an iterator representing the beginning of the buffers' data. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a42e267c80155b2747d041d2932357762_cgraph.svg" width="547" height="167"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a1c586f56452e13b3798ae1925bd35595" name="a1c586f56452e13b3798ae1925bd35595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c586f56452e13b3798ae1925bd35595">&#9670;&#160;</a></span>buffers_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferSequence&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1buffers__iterator.html">buffers_iterator</a>&lt; BufferSequence &gt; asio::buffers_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> BufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an iterator representing the end of the buffers' data. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a1c586f56452e13b3798ae1925bd35595_cgraph.svg" width="564" height="216"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aec3d375db898c9bf6f30e7903d8affec" name="aec3d375db898c9bf6f30e7903d8affec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3d375db898c9bf6f30e7903d8affec">&#9670;&#160;</a></span>connect() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Executor, typename EndpointSequence&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::endpoint asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>endpoints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the successfully connected endpoint. Otherwise, a default-constructed endpoint.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line">tcp::socket <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>(my_context);</div>
<div class="line"><a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a> ec;</div>
<div class="line"><a class="code hl_function" href="#a451e58dc85e01aced92a59bbf5ca4d47">asio::connect</a>(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, r.resolve(q), ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">} </div>
<div class="ttc" id="anamespaceasio_html_a451e58dc85e01aced92a59bbf5ca4d47"><div class="ttname"><a href="#a451e58dc85e01aced92a59bbf5ca4d47">asio::connect</a></div><div class="ttdeci">Protocol::endpoint connect(basic_socket&lt; Protocol, Executor &gt; &amp;s, const EndpointSequence &amp;endpoints, typename enable_if&lt; is_endpoint_sequence&lt; EndpointSequence &gt;::value &gt;::type *=0)</div><div class="ttdoc">Establishes a socket connection by trying each endpoint in a sequence.</div><div class="ttdef"><b>Definition</b> connect.hpp:105</div></div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_aec3d375db898c9bf6f30e7903d8affec_cgraph.svg" width="631" height="126"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a7baa8d70606b0c0cf064b6596035d048" name="a7baa8d70606b0c0cf064b6596035d048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7baa8d70606b0c0cf064b6596035d048">&#9670;&#160;</a></span>connect() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Executor, typename EndpointSequence, typename ConnectCondition&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::endpoint asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>endpoints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition</td>          <td class="paramname"><span class="paramname"><em>connect_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code hl_variable" href="#a9accb3ddb108d48e0e70093ec8d40885">connect_condition</a>(</div>
<div class="line">   <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the successfully connected endpoint. Otherwise, a default-constructed endpoint.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following connect condition function object can be used to output information about the individual connection attempts: <div class="fragment"><div class="line"> <span class="keyword">struct </span>my_connect_condition</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">bool</span> operator()(</div>
<div class="line">      <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div>
<div class="line">      const::tcp::endpoint&amp; next)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (ec) std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.<a class="code hl_function" href="classasio_1_1error__code.html#a7029a8f8f51f7e03da42bd50c2b3c85b">message</a>() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">}; </div>
</div><!-- fragment --> It would be used with the <a class="el" href="#a451e58dc85e01aced92a59bbf5ca4d47" title="Establishes a socket connection by trying each endpoint in a sequence.">asio::connect</a> function as follows: <div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line">tcp::socket <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>(my_context);</div>
<div class="line"><a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a> ec;</div>
<div class="line">tcp::endpoint e = <a class="code hl_function" href="#a451e58dc85e01aced92a59bbf5ca4d47">asio::connect</a>(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>,</div>
<div class="line">    r.resolve(q), my_connect_condition(), ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Connected to: &quot;</span> &lt;&lt; e &lt;&lt; std::endl;</div>
<div class="line">} </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a7baa8d70606b0c0cf064b6596035d048_cgraph.svg" width="631" height="126"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a2a5c08454b4139eefd1b24d6141dc11d" name="a2a5c08454b4139eefd1b24d6141dc11d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5c08454b4139eefd1b24d6141dc11d">&#9670;&#160;</a></span>connect() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Executor, typename EndpointSequence, typename ConnectCondition&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::endpoint asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>endpoints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition</td>          <td class="paramname"><span class="paramname"><em>connect_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code hl_variable" href="#a9accb3ddb108d48e0e70093ec8d40885">connect_condition</a>(</div>
<div class="line">   <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The successfully connected endpoint.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure. If the sequence is empty, the associated <code><a class="el" href="classasio_1_1error__code.html" title="Class to represent an error code value.">error_code</a></code> is <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>The following connect condition function object can be used to output information about the individual connection attempts: <div class="fragment"><div class="line"> <span class="keyword">struct </span>my_connect_condition</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">bool</span> operator()(</div>
<div class="line">      <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div>
<div class="line">      const::tcp::endpoint&amp; next)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (ec) std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.<a class="code hl_function" href="classasio_1_1error__code.html#a7029a8f8f51f7e03da42bd50c2b3c85b">message</a>() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">}; </div>
</div><!-- fragment --> It would be used with the <a class="el" href="#a451e58dc85e01aced92a59bbf5ca4d47" title="Establishes a socket connection by trying each endpoint in a sequence.">asio::connect</a> function as follows: <div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line">tcp::socket <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>(my_context);</div>
<div class="line">tcp::endpoint e = <a class="code hl_function" href="#a451e58dc85e01aced92a59bbf5ca4d47">asio::connect</a>(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>,</div>
<div class="line">    r.resolve(q), my_connect_condition());</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Connected to: &quot;</span> &lt;&lt; e &lt;&lt; std::endl; </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a2a5c08454b4139eefd1b24d6141dc11d_cgraph.svg" width="611" height="94"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a451e58dc85e01aced92a59bbf5ca4d47" name="a451e58dc85e01aced92a59bbf5ca4d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451e58dc85e01aced92a59bbf5ca4d47">&#9670;&#160;</a></span>connect() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Executor, typename EndpointSequence&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::endpoint asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>endpoints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The successfully connected endpoint.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure. If the sequence is empty, the associated <code><a class="el" href="classasio_1_1error__code.html" title="Class to represent an error code value.">error_code</a></code> is <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line">tcp::socket <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>(my_context);</div>
<div class="line"><a class="code hl_function" href="#a451e58dc85e01aced92a59bbf5ca4d47">asio::connect</a>(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, r.resolve(q)); </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a451e58dc85e01aced92a59bbf5ca4d47_cgraph.svg" width="466" height="68"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a451e58dc85e01aced92a59bbf5ca4d47_icgraph.svg" width="254" height="480"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a74238337e726fc0b10f0350ffa4aba96" name="a74238337e726fc0b10f0350ffa4aba96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74238337e726fc0b10f0350ffa4aba96">&#9670;&#160;</a></span>connect() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Executor, typename Iterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>(Deprecated: Use range overload.) Establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload assumes that a default constructed object of type <code>Iterator</code> represents the end of the sequence. This is a valid assumption for iterator types such as <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a0c3dbc8d36448e3cf70439e8388396d9">asio::ip::tcp::resolver::iterator</a></code>. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a74238337e726fc0b10f0350ffa4aba96_cgraph.svg" width="611" height="68"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="abe0f090f44a2471433a2d236b21cea1c" name="abe0f090f44a2471433a2d236b21cea1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe0f090f44a2471433a2d236b21cea1c">&#9670;&#160;</a></span>connect() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Executor, typename Iterator, typename ConnectCondition&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition</td>          <td class="paramname"><span class="paramname"><em>connect_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>(Deprecated: Use range overload.) Establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code hl_variable" href="#a9accb3ddb108d48e0e70093ec8d40885">connect_condition</a>(</div>
<div class="line">   <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload assumes that a default constructed object of type <code>Iterator</code> represents the end of the sequence. This is a valid assumption for iterator types such as <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a0c3dbc8d36448e3cf70439e8388396d9">asio::ip::tcp::resolver::iterator</a></code>. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_abe0f090f44a2471433a2d236b21cea1c_cgraph.svg" width="611" height="68"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aca03102489231106ce9649d52885ad2a" name="aca03102489231106ce9649d52885ad2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca03102489231106ce9649d52885ad2a">&#9670;&#160;</a></span>connect() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Executor, typename Iterator, typename ConnectCondition&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition</td>          <td class="paramname"><span class="paramname"><em>connect_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(Deprecated: Use range overload.) Establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code hl_variable" href="#a9accb3ddb108d48e0e70093ec8d40885">connect_condition</a>(</div>
<div class="line">   <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure. If the sequence is empty, the associated <code><a class="el" href="classasio_1_1error__code.html" title="Class to represent an error code value.">error_code</a></code> is <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload assumes that a default constructed object of type <code>Iterator</code> represents the end of the sequence. This is a valid assumption for iterator types such as <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a0c3dbc8d36448e3cf70439e8388396d9">asio::ip::tcp::resolver::iterator</a></code>. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_aca03102489231106ce9649d52885ad2a_cgraph.svg" width="611" height="94"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aa8c58255744686dfcd930523d98bc0c2" name="aa8c58255744686dfcd930523d98bc0c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c58255744686dfcd930523d98bc0c2">&#9670;&#160;</a></span>connect() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Executor, typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator denoting the successfully connected endpoint.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure. If the sequence is empty, the associated <code><a class="el" href="classasio_1_1error__code.html" title="Class to represent an error code value.">error_code</a></code> is <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line">tcp::resolver::results_type e = r.resolve(q);</div>
<div class="line">tcp::socket <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>(my_context);</div>
<div class="line"><a class="code hl_function" href="#a451e58dc85e01aced92a59bbf5ca4d47">asio::connect</a>(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, e.begin(), e.end()); </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_aa8c58255744686dfcd930523d98bc0c2_cgraph.svg" width="611" height="94"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a5be799cfeb2dc75e371ffba20d2e62db" name="a5be799cfeb2dc75e371ffba20d2e62db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be799cfeb2dc75e371ffba20d2e62db">&#9670;&#160;</a></span>connect() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Executor, typename Iterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line">tcp::resolver::results_type e = r.resolve(q);</div>
<div class="line">tcp::socket <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>(my_context);</div>
<div class="line"><a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a> ec;</div>
<div class="line"><a class="code hl_function" href="#a451e58dc85e01aced92a59bbf5ca4d47">asio::connect</a>(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, e.begin(), e.end(), ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">} </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a5be799cfeb2dc75e371ffba20d2e62db_cgraph.svg" width="611" height="68"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ad2f94719f8fa630e293df94e5819e4ba" name="ad2f94719f8fa630e293df94e5819e4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f94719f8fa630e293df94e5819e4ba">&#9670;&#160;</a></span>connect() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Executor, typename Iterator, typename ConnectCondition&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition</td>          <td class="paramname"><span class="paramname"><em>connect_condition</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code hl_variable" href="#a9accb3ddb108d48e0e70093ec8d40885">connect_condition</a>(</div>
<div class="line">   <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator denoting the successfully connected endpoint.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure. If the sequence is empty, the associated <code><a class="el" href="classasio_1_1error__code.html" title="Class to represent an error code value.">error_code</a></code> is <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>The following connect condition function object can be used to output information about the individual connection attempts: <div class="fragment"><div class="line"> <span class="keyword">struct </span>my_connect_condition</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">bool</span> operator()(</div>
<div class="line">      <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div>
<div class="line">      const::tcp::endpoint&amp; next)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (ec) std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.<a class="code hl_function" href="classasio_1_1error__code.html#a7029a8f8f51f7e03da42bd50c2b3c85b">message</a>() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">}; </div>
</div><!-- fragment --> It would be used with the <a class="el" href="#a451e58dc85e01aced92a59bbf5ca4d47" title="Establishes a socket connection by trying each endpoint in a sequence.">asio::connect</a> function as follows: <div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line">tcp::resolver::results_type e = r.resolve(q);</div>
<div class="line">tcp::socket <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>(my_context);</div>
<div class="line">tcp::resolver::results_type::iterator <a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> = <a class="code hl_function" href="#a451e58dc85e01aced92a59bbf5ca4d47">asio::connect</a>(</div>
<div class="line">    <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, e.begin(), e.end(), my_connect_condition());</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Connected to: &quot;</span> &lt;&lt; <a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>-&gt;endpoint() &lt;&lt; std::endl; </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_ad2f94719f8fa630e293df94e5819e4ba_cgraph.svg" width="611" height="94"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aec7be5e72ae43d07fced121d88f7b1e2" name="aec7be5e72ae43d07fced121d88f7b1e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7be5e72ae43d07fced121d88f7b1e2">&#9670;&#160;</a></span>connect() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Executor, typename Iterator, typename ConnectCondition&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition</td>          <td class="paramname"><span class="paramname"><em>connect_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code hl_variable" href="#a9accb3ddb108d48e0e70093ec8d40885">connect_condition</a>(</div>
<div class="line">   <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div>
<div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> Protocol::endpoint&amp; next); </div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following connect condition function object can be used to output information about the individual connection attempts: <div class="fragment"><div class="line"> <span class="keyword">struct </span>my_connect_condition</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">bool</span> operator()(</div>
<div class="line">      <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div>
<div class="line">      const::tcp::endpoint&amp; next)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (ec) std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.<a class="code hl_function" href="classasio_1_1error__code.html#a7029a8f8f51f7e03da42bd50c2b3c85b">message</a>() &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">}; </div>
</div><!-- fragment --> It would be used with the <a class="el" href="#a451e58dc85e01aced92a59bbf5ca4d47" title="Establishes a socket connection by trying each endpoint in a sequence.">asio::connect</a> function as follows: <div class="fragment"><div class="line"> tcp::resolver r(my_context);</div>
<div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div>
<div class="line">tcp::resolver::results_type e = r.resolve(q);</div>
<div class="line">tcp::socket <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>(my_context);</div>
<div class="line"><a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a> ec;</div>
<div class="line">tcp::resolver::results_type::iterator <a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> = <a class="code hl_function" href="#a451e58dc85e01aced92a59bbf5ca4d47">asio::connect</a>(</div>
<div class="line">    <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, e.begin(), e.end(), my_connect_condition());</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Connected to: &quot;</span> &lt;&lt; <a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>-&gt;endpoint() &lt;&lt; std::endl;</div>
<div class="line">} </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_aec7be5e72ae43d07fced121d88f7b1e2_cgraph.svg" width="290" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a795806648aa9dee1c9d2c820e0e7839e" name="a795806648aa9dee1c9d2c820e0e7839e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795806648aa9dee1c9d2c820e0e7839e">&#9670;&#160;</a></span>connect() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Executor, typename Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(Deprecated: Use range overload.) Establishes a socket connection by trying each endpoint in a sequence. This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure. If the sequence is empty, the associated <code><a class="el" href="classasio_1_1error__code.html" title="Class to represent an error code value.">error_code</a></code> is <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found.">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload assumes that a default constructed object of type <code>Iterator</code> represents the end of the sequence. This is a valid assumption for iterator types such as <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#a0c3dbc8d36448e3cf70439e8388396d9">asio::ip::tcp::resolver::iterator</a></code>. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a795806648aa9dee1c9d2c820e0e7839e_cgraph.svg" width="611" height="94"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a082ceaa5ce3217fda0bcc008a211a272" name="a082ceaa5ce3217fda0bcc008a211a272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082ceaa5ce3217fda0bcc008a211a272">&#9670;&#160;</a></span>dynamic_buffer() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem, typename Traits, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1dynamic__string__buffer.html">dynamic_string_buffer</a>&lt; Elem, Traits, Allocator &gt; asio::dynamic_buffer </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new dynamic buffer that represents the given string. </p>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">dynamic_string_buffer&lt;Elem, Traits, Allocator&gt;(data)</span>. </dd></dl>

</div>
</div>
<a id="a72f4c6e4f3c663830431f48bd91188d4" name="a72f4c6e4f3c663830431f48bd91188d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f4c6e4f3c663830431f48bd91188d4">&#9670;&#160;</a></span>dynamic_buffer() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem, typename Traits, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1dynamic__string__buffer.html">dynamic_string_buffer</a>&lt; Elem, Traits, Allocator &gt; asio::dynamic_buffer </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new dynamic buffer that represents the given string. </p>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">dynamic_string_buffer&lt;Elem, Traits, Allocator&gt;(data,
max_size)</span>. </dd></dl>

</div>
</div>
<a id="aaa9fce6304552101942da09828a3b167" name="aaa9fce6304552101942da09828a3b167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa9fce6304552101942da09828a3b167">&#9670;&#160;</a></span>dynamic_buffer() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1dynamic__vector__buffer.html">dynamic_vector_buffer</a>&lt; Elem, Allocator &gt; asio::dynamic_buffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Elem, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new dynamic buffer that represents the given vector. </p>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">dynamic_vector_buffer&lt;Elem, Allocator&gt;(data)</span>. </dd></dl>

</div>
</div>
<a id="a08d3f6046e87b03363fdd0cb85ec100b" name="a08d3f6046e87b03363fdd0cb85ec100b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d3f6046e87b03363fdd0cb85ec100b">&#9670;&#160;</a></span>dynamic_buffer() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1dynamic__vector__buffer.html">dynamic_vector_buffer</a>&lt; Elem, Allocator &gt; asio::dynamic_buffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Elem, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new dynamic buffer that represents the given vector. </p>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">dynamic_vector_buffer&lt;Elem, Allocator&gt;(data, max_size)</span>. </dd></dl>

</div>
</div>
<a id="ae518b5450d78d530faa74e7e28aa2dac" name="ae518b5450d78d530faa74e7e28aa2dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae518b5450d78d530faa74e7e28aa2dac">&#9670;&#160;</a></span>get_associated_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasio_1_1associated__allocator.html">associated_allocator</a>&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> asio::get_associated_allocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated allocator. </p>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">associated_allocator&lt;T&gt;::get(t)</span> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_ae518b5450d78d530faa74e7e28aa2dac_cgraph.svg" width="392" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_ae518b5450d78d530faa74e7e28aa2dac_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a579553334e8f23a3e929842807a7ab0f" name="a579553334e8f23a3e929842807a7ab0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579553334e8f23a3e929842807a7ab0f">&#9670;&#160;</a></span>get_associated_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasio_1_1associated__allocator.html">associated_allocator</a>&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>, Allocator &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> asio::get_associated_allocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Allocator &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated allocator. </p>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">associated_allocator&lt;T, Allocator&gt;::get(t, a)</span> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a579553334e8f23a3e929842807a7ab0f_cgraph.svg" width="392" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aa843447a2d3c06acc107d484b4c6b0ca" name="aa843447a2d3c06acc107d484b4c6b0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa843447a2d3c06acc107d484b4c6b0ca">&#9670;&#160;</a></span>get_associated_executor() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> asio::get_associated_executor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated executor. </p>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">associated_executor&lt;T&gt;::get(t)</span> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_aa843447a2d3c06acc107d484b4c6b0ca_cgraph.svg" width="392" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_aa843447a2d3c06acc107d484b4c6b0ca_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="aa751038b47ae548eb967d30954b4ffb6" name="aa751038b47ae548eb967d30954b4ffb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa751038b47ae548eb967d30954b4ffb6">&#9670;&#160;</a></span>get_associated_executor() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>, typename Executor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>, Executor &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> asio::get_associated_executor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Executor &amp;</td>          <td class="paramname"><span class="paramname"><em>ex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated executor. </p>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">associated_executor&lt;T, Executor&gt;::get(t, ex)</span> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_aa751038b47ae548eb967d30954b4ffb6_cgraph.svg" width="392" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a8c5a1378977472c2b698186821b7759c" name="a8c5a1378977472c2b698186821b7759c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5a1378977472c2b698186821b7759c">&#9670;&#160;</a></span>get_associated_executor() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>, typename ExecutionContext&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>, typenameExecutionContext::executor_type &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> asio::get_associated_executor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExecutionContext &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated executor. </p>
<dl class="section return"><dt>Returns</dt><dd><span class="tt"><a class="el" href="structasio_1_1associated__executor.html" title="Traits type used to obtain the executor associated with an object.">associated_executor</a>&lt;<a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>, typename
ExecutionContext::executor_type&gt;::get(t, ctx.get_executor())</span> </dd></dl>

</div>
</div>
<a id="acd7c8e7883fd13e8f1c357d788817ec6" name="acd7c8e7883fd13e8f1c357d788817ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7c8e7883fd13e8f1c357d788817ec6">&#9670;&#160;</a></span>has_service()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool asio::has_service </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is used to determine whether the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> contains a service object corresponding to the given service type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> object that owns the service.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean indicating whether the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> contains the service. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_acd7c8e7883fd13e8f1c357d788817ec6_icgraph.svg" width="336" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="acaae9584b5011eb2d929f4ee9d5e91d3" name="acaae9584b5011eb2d929f4ee9d5e91d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaae9584b5011eb2d929f4ee9d5e91d3">&#9670;&#160;</a></span>make_service()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Service &amp; asio::make_service </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae690ffe5492a8ebfd0f70ff37a3887bb" name="ae690ffe5492a8ebfd0f70ff37a3887bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae690ffe5492a8ebfd0f70ff37a3887bb">&#9670;&#160;</a></span>make_strand() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1strand.html">strand</a>&lt; Executor &gt; asio::make_strand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Executor &amp;</td>          <td class="paramname"><span class="paramname"><em>ex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classasio_1_1strand.html">strand</a> object for an executor. </p>

</div>
</div>
<a id="a141d6d4a8ef1d17de12863e54fddc87a" name="a141d6d4a8ef1d17de12863e54fddc87a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141d6d4a8ef1d17de12863e54fddc87a">&#9670;&#160;</a></span>make_strand() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1strand.html">strand</a>&lt; typename ExecutionContext::executor_type &gt; asio::make_strand </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classasio_1_1strand.html">strand</a> object for an execution context. </p>

</div>
</div>
<a id="aaf777e5b849da59fc6cc5ecf01167171" name="aaf777e5b849da59fc6cc5ecf01167171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf777e5b849da59fc6cc5ecf01167171">&#9670;&#160;</a></span>make_work_guard() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; Executor &gt; asio::make_work_guard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Executor &amp;</td>          <td class="paramname"><span class="paramname"><em>ex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_aaf777e5b849da59fc6cc5ecf01167171_icgraph.svg" width="560" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a87285e2871b719f7218ed313878f707b" name="a87285e2871b719f7218ed313878f707b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87285e2871b719f7218ed313878f707b">&#9670;&#160;</a></span>make_work_guard() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>, typename Executor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; typename <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>, Executor &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt; asio::make_work_guard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Executor &amp;</td>          <td class="paramname"><span class="paramname"><em>ex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a87285e2871b719f7218ed313878f707b_cgraph.svg" width="411" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a607caf8c766a5c57958ab9f033d34d0b" name="a607caf8c766a5c57958ab9f033d34d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607caf8c766a5c57958ab9f033d34d0b">&#9670;&#160;</a></span>make_work_guard() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>, typename ExecutionContext&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; typename <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>, typename ExecutionContext::executor_type &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt; asio::make_work_guard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExecutionContext &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!is_convertible&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a607caf8c766a5c57958ab9f033d34d0b_cgraph.svg" width="411" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a6f19b548e6446b7bc7a3506ba14f5bff" name="a6f19b548e6446b7bc7a3506ba14f5bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f19b548e6446b7bc7a3506ba14f5bff">&#9670;&#160;</a></span>make_work_guard() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; typename <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt; asio::make_work_guard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!is_convertible&lt; <a class="el" href="Reverb_8cc.html#a06718aad87a63a7d4dbd6825b136f57e">T</a> &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a6f19b548e6446b7bc7a3506ba14f5bff_cgraph.svg" width="411" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aff6c8de3eb46ade8c78befe0fa08d14e" name="aff6c8de3eb46ade8c78befe0fa08d14e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6c8de3eb46ade8c78befe0fa08d14e">&#9670;&#160;</a></span>make_work_guard() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; typename ExecutionContext::executor_type &gt; asio::make_work_guard </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object. </p>

</div>
</div>
<a id="a14f798e0ac350e7b7359337982aa7b36" name="a14f798e0ac350e7b7359337982aa7b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f798e0ac350e7b7359337982aa7b36">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem, typename Traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; Elem, Traits &gt; &amp; asio::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; Elem, Traits &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1error__code.html">error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output an error code. </p>

</div>
</div>
<a id="a762fc24a5be2db44f5b4095af618b8b9" name="a762fc24a5be2db44f5b4095af618b8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762fc24a5be2db44f5b4095af618b8b9">&#9670;&#160;</a></span>read() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename DynamicBuffer_v1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1)</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#ac2d04c42f9c62cfdfad22c1e47371afe">asio::read</a>(</div>
<div class="line">   <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
<div class="ttc" id="anamespaceasio_html_ac2d04c42f9c62cfdfad22c1e47371afe"><div class="ttname"><a href="#ac2d04c42f9c62cfdfad22c1e47371afe">asio::read</a></div><div class="ttdeci">std::size_t read(SyncReadStream &amp;s, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, asio::error_code &amp;ec, typename enable_if&lt; is_mutable_buffer_sequence&lt; MutableBufferSequence &gt;::value &gt;::type *)</div><div class="ttdoc">Attempt to read a certain amount of data from a stream before returning.</div><div class="ttdef"><b>Definition</b> read.hpp:65</div></div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a762fc24a5be2db44f5b4095af618b8b9_cgraph.svg" width="643" height="126"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aaa22b8532143e0b27c0af29d69cc1d15" name="aaa22b8532143e0b27c0af29d69cc1d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa22b8532143e0b27c0af29d69cc1d15">&#9670;&#160;</a></span>read() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename DynamicBuffer_v1, typename CompletionCondition&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1)</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read_some function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_aaa22b8532143e0b27c0af29d69cc1d15_cgraph.svg" width="286" height="67"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ae2bc01a3cfbb23d492c75dc6414d24f1" name="ae2bc01a3cfbb23d492c75dc6414d24f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2bc01a3cfbb23d492c75dc6414d24f1">&#9670;&#160;</a></span>read() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename DynamicBuffer_v1, typename CompletionCondition&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1)</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read_some function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_ae2bc01a3cfbb23d492c75dc6414d24f1_cgraph.svg" width="648" height="183"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a8fee811dd4da39d29632f7eff041b6fc" name="a8fee811dd4da39d29632f7eff041b6fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fee811dd4da39d29632f7eff041b6fc">&#9670;&#160;</a></span>read() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename DynamicBuffer_v1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1)</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#ac2d04c42f9c62cfdfad22c1e47371afe">asio::read</a>(</div>
<div class="line">   <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a8fee811dd4da39d29632f7eff041b6fc_cgraph.svg" width="648" height="228"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aaeda9d140628ff399cbe4a076cb15cee" name="aaeda9d140628ff399cbe4a076cb15cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeda9d140628ff399cbe4a076cb15cee">&#9670;&#160;</a></span>read() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#ac2d04c42f9c62cfdfad22c1e47371afe">asio::read</a>(</div>
<div class="line">   <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_aaeda9d140628ff399cbe4a076cb15cee_cgraph.svg" width="604" height="124"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="abc0bc3183df1291c7b2a35ec30d5428c" name="abc0bc3183df1291c7b2a35ec30d5428c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc0bc3183df1291c7b2a35ec30d5428c">&#9670;&#160;</a></span>read() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#ac2d04c42f9c62cfdfad22c1e47371afe">asio::read</a>(</div>
<div class="line">   <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_abc0bc3183df1291c7b2a35ec30d5428c_cgraph.svg" width="604" height="124"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aeadfb55ae835155abb8b6dc11a063b54" name="aeadfb55ae835155abb8b6dc11a063b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeadfb55ae835155abb8b6dc11a063b54">&#9670;&#160;</a></span>read() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename Allocator, typename CompletionCondition&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read_some function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_aeadfb55ae835155abb8b6dc11a063b54_cgraph.svg" width="604" height="124"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a6038b695e95ef357b104f35a28edfe3d" name="a6038b695e95ef357b104f35a28edfe3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6038b695e95ef357b104f35a28edfe3d">&#9670;&#160;</a></span>read() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename Allocator, typename CompletionCondition&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read_some function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a6038b695e95ef357b104f35a28edfe3d_cgraph.svg" width="604" height="124"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="afff9ff31b97492c326e599398599366b" name="afff9ff31b97492c326e599398599366b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff9ff31b97492c326e599398599366b">&#9670;&#160;</a></span>read() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename MutableBufferSequence&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#ac2d04c42f9c62cfdfad22c1e47371afe">asio::read</a>(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_function" href="#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, size), ec); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#ac2d04c42f9c62cfdfad22c1e47371afe">asio::read</a>(</div>
<div class="line">   <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_afff9ff31b97492c326e599398599366b_cgraph.svg" width="643" height="126"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ac2d04c42f9c62cfdfad22c1e47371afe" name="ac2d04c42f9c62cfdfad22c1e47371afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d04c42f9c62cfdfad22c1e47371afe">&#9670;&#160;</a></span>read() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename MutableBufferSequence, typename CompletionCondition&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read_some function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_ac2d04c42f9c62cfdfad22c1e47371afe_cgraph.svg" width="480" height="124"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_ac2d04c42f9c62cfdfad22c1e47371afe_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="ae08771e9fbf8a4e92e8b4d2cf801a428" name="ae08771e9fbf8a4e92e8b4d2cf801a428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae08771e9fbf8a4e92e8b4d2cf801a428">&#9670;&#160;</a></span>read() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename MutableBufferSequence, typename CompletionCondition&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read_some function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#ac2d04c42f9c62cfdfad22c1e47371afe">asio::read</a>(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_function" href="#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, size),</div>
<div class="line">   <a class="code hl_function" href="#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(32)); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_ae08771e9fbf8a4e92e8b4d2cf801a428_cgraph.svg" width="648" height="183"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a6139ae5217bdda60c94939c37f6971b6" name="a6139ae5217bdda60c94939c37f6971b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6139ae5217bdda60c94939c37f6971b6">&#9670;&#160;</a></span>read() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename MutableBufferSequence&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#ac2d04c42f9c62cfdfad22c1e47371afe">asio::read</a>(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_function" href="#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, size)); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#ac2d04c42f9c62cfdfad22c1e47371afe">asio::read</a>(</div>
<div class="line">   <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a6139ae5217bdda60c94939c37f6971b6_cgraph.svg" width="648" height="228"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a2cb13f54d15172a2e93b73c1ea9fb1b5" name="a2cb13f54d15172a2e93b73c1ea9fb1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb13f54d15172a2e93b73c1ea9fb1b5">&#9670;&#160;</a></span>read() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename DynamicBuffer_v2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#ac2d04c42f9c62cfdfad22c1e47371afe">asio::read</a>(</div>
<div class="line">   <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a2cb13f54d15172a2e93b73c1ea9fb1b5_cgraph.svg" width="643" height="126"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="acb17bc14c1e92bc3209991b706b6495d" name="acb17bc14c1e92bc3209991b706b6495d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb17bc14c1e92bc3209991b706b6495d">&#9670;&#160;</a></span>read() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename DynamicBuffer_v2, typename CompletionCondition&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read_some function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_acb17bc14c1e92bc3209991b706b6495d_cgraph.svg" width="286" height="67"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a1a384fd2010fdaf4d6047b4426d3199f" name="a1a384fd2010fdaf4d6047b4426d3199f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a384fd2010fdaf4d6047b4426d3199f">&#9670;&#160;</a></span>read() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename DynamicBuffer_v2, typename CompletionCondition&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest read_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read_some function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a1a384fd2010fdaf4d6047b4426d3199f_cgraph.svg" width="648" height="183"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a5588d6732ebb692217a10f639db11f0e" name="a5588d6732ebb692217a10f639db11f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5588d6732ebb692217a10f639db11f0e">&#9670;&#160;</a></span>read() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename DynamicBuffer_v2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read a certain amount of data from a stream before returning. </p>
<p>This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#ac2d04c42f9c62cfdfad22c1e47371afe">asio::read</a>(</div>
<div class="line">   <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a5588d6732ebb692217a10f639db11f0e_cgraph.svg" width="648" height="228"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a301406c670bc22190df6e8628cbf0037" name="a301406c670bc22190df6e8628cbf0037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301406c670bc22190df6e8628cbf0037">&#9670;&#160;</a></span>read_at() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessReadDevice, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessReadDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to read a certain amount of data at the specified offset before returning. This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's read_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a88604242259da9fb0bacf3c4f0cc0002">asio::read_at</a>(</div>
<div class="line">   d, 42, <a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
<div class="ttc" id="anamespaceasio_html_a88604242259da9fb0bacf3c4f0cc0002"><div class="ttname"><a href="#a88604242259da9fb0bacf3c4f0cc0002">asio::read_at</a></div><div class="ttdeci">std::size_t read_at(SyncRandomAccessReadDevice &amp;d, uint64_t offset, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, asio::error_code &amp;ec)</div><div class="ttdef"><b>Definition</b> read_at.hpp:69</div></div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a301406c670bc22190df6e8628cbf0037_cgraph.svg" width="667" height="228"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a4511bad893697fc58d379d6e00aa84ff" name="a4511bad893697fc58d379d6e00aa84ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4511bad893697fc58d379d6e00aa84ff">&#9670;&#160;</a></span>read_at() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessReadDevice, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessReadDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to read a certain amount of data at the specified offset before returning. This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's read_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a88604242259da9fb0bacf3c4f0cc0002">asio::read_at</a>(</div>
<div class="line">   d, 42, <a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a4511bad893697fc58d379d6e00aa84ff_cgraph.svg" width="662" height="126"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a0126c00568f324b47c24b494c97ece14" name="a0126c00568f324b47c24b494c97ece14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0126c00568f324b47c24b494c97ece14">&#9670;&#160;</a></span>read_at() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessReadDevice, typename Allocator, typename CompletionCondition&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessReadDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to read a certain amount of data at the specified offset before returning. This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's read_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest read_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's read_some_at function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a0126c00568f324b47c24b494c97ece14_cgraph.svg" width="667" height="183"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a926222f6d0bb8a716a17161a1eb725aa" name="a926222f6d0bb8a716a17161a1eb725aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926222f6d0bb8a716a17161a1eb725aa">&#9670;&#160;</a></span>read_at() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessReadDevice, typename Allocator, typename CompletionCondition&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessReadDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempt to read a certain amount of data at the specified offset before returning. This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's read_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object into which the data will be read.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest read_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's read_some_at function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a926222f6d0bb8a716a17161a1eb725aa_cgraph.svg" width="304" height="67"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a4ef7a26ff401494d673ad462a3f3f5c0" name="a4ef7a26ff401494d673ad462a3f3f5c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef7a26ff401494d673ad462a3f3f5c0">&#9670;&#160;</a></span>read_at() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessReadDevice, typename MutableBufferSequence&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessReadDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to read a certain amount of data at the specified offset before returning. This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's read_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a88604242259da9fb0bacf3c4f0cc0002">asio::read_at</a>(d, 42, <a class="code hl_function" href="#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, size)); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a88604242259da9fb0bacf3c4f0cc0002">asio::read_at</a>(</div>
<div class="line">   d, 42, <a class="code hl_variable" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a4ef7a26ff401494d673ad462a3f3f5c0_cgraph.svg" width="667" height="228"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a6587e766e26325457154a5dac2a0b785" name="a6587e766e26325457154a5dac2a0b785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6587e766e26325457154a5dac2a0b785">&#9670;&#160;</a></span>read_at() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessReadDevice, typename MutableBufferSequence&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessReadDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to read a certain amount of data at the specified offset before returning. This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's read_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a88604242259da9fb0bacf3c4f0cc0002">asio::read_at</a>(d, 42,</div>
<div class="line">   <a class="code hl_function" href="#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, size), ec); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a88604242259da9fb0bacf3c4f0cc0002">asio::read_at</a>(</div>
<div class="line">   d, 42, <a class="code hl_variable" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a6587e766e26325457154a5dac2a0b785_cgraph.svg" width="662" height="126"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aa16ebd52ad98e521ea4b75676d4db9fd" name="aa16ebd52ad98e521ea4b75676d4db9fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16ebd52ad98e521ea4b75676d4db9fd">&#9670;&#160;</a></span>read_at() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessReadDevice, typename MutableBufferSequence, typename CompletionCondition&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessReadDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to read a certain amount of data at the specified offset before returning. This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's read_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest read_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's read_some_at function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a88604242259da9fb0bacf3c4f0cc0002">asio::read_at</a>(d, 42, <a class="code hl_function" href="#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, size),</div>
<div class="line">   <a class="code hl_function" href="#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(32)); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_aa16ebd52ad98e521ea4b75676d4db9fd_cgraph.svg" width="667" height="183"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a88604242259da9fb0bacf3c4f0cc0002" name="a88604242259da9fb0bacf3c4f0cc0002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88604242259da9fb0bacf3c4f0cc0002">&#9670;&#160;</a></span>read_at() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessReadDevice, typename MutableBufferSequence, typename CompletionCondition&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessReadDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> MutableBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempt to read a certain amount of data at the specified offset before returning. This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's read_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be read.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest read_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's read_some_at function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a88604242259da9fb0bacf3c4f0cc0002_cgraph.svg" width="498" height="124"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a88604242259da9fb0bacf3c4f0cc0002_icgraph.svg" width="248" height="283"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a03a433d903eae4dd097bc2c55efbf1ee" name="a03a433d903eae4dd097bc2c55efbf1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a433d903eae4dd097bc2c55efbf1ee">&#9670;&#160;</a></span>read_until() <span class="overload">[1/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a></td>          <td class="paramname"><span class="paramname"><em>delim</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data into a streambuf until it contains a specified delimiter. </p>
<p>This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the streambuf's get area up to and including the delimiter.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read data into a streambuf until a newline is encountered: <div class="fragment"><div class="line"> <a class="code hl_typedef" href="#a6a7ba348943527312eeace3492bf32ee">asio::streambuf</a> <a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>;</div>
<div class="line"><a class="code hl_function" href="#a49ff1260194288ac9bcdc6ea0b73807e">asio::read_until</a>(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, <span class="stringliteral">&quot;\r\n&quot;</span>);</div>
<div class="line">std::istream is(&amp;<a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>);</div>
<div class="line">std::string line;</div>
<div class="line">std::getline(is, line); </div>
<div class="ttc" id="anamespaceasio_html_a49ff1260194288ac9bcdc6ea0b73807e"><div class="ttname"><a href="#a49ff1260194288ac9bcdc6ea0b73807e">asio::read_until</a></div><div class="ttdeci">std::size_t read_until(SyncReadStream &amp;s, ASIO_MOVE_ARG(DynamicBuffer_v1) buffers, char delim, typename enable_if&lt; is_dynamic_buffer_v1&lt; typename decay&lt; DynamicBuffer_v1 &gt;::type &gt;::value &amp;&amp;!is_dynamic_buffer_v2&lt; typename decay&lt; DynamicBuffer_v1 &gt;::type &gt;::value &gt;::type *)</div><div class="ttdef"><b>Definition</b> read_until.hpp:77</div></div>
</div><!-- fragment --> After the <code>read_until</code> operation completes successfully, the buffer <code>b</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>std::getline</code> then extracts the data up to and including the newline (which is discarded), so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span> } </div>
</div><!-- fragment --> The remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>read_until</code> operation. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a03a433d903eae4dd097bc2c55efbf1ee_cgraph.svg" width="631" height="68"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a78faf8cf08d47515162de95b18b0a860" name="a78faf8cf08d47515162de95b18b0a860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78faf8cf08d47515162de95b18b0a860">&#9670;&#160;</a></span>read_until() <span class="overload">[2/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a></td>          <td class="paramname"><span class="paramname"><em>delim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data into a streambuf until it contains a specified delimiter. </p>
<p>This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the streambuf's get area up to and including the delimiter. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a78faf8cf08d47515162de95b18b0a860_cgraph.svg" width="631" height="68"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a1aae2baa82596a6a9ad320e80b016006" name="a1aae2baa82596a6a9ad320e80b016006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aae2baa82596a6a9ad320e80b016006">&#9670;&#160;</a></span>read_until() <span class="overload">[3/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>delim</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data into a streambuf until it contains a specified delimiter. </p>
<p>This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the streambuf's get area up to and including the delimiter.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read data into a streambuf until a newline is encountered: <div class="fragment"><div class="line"> <a class="code hl_typedef" href="#a6a7ba348943527312eeace3492bf32ee">asio::streambuf</a> <a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>;</div>
<div class="line"><a class="code hl_function" href="#a49ff1260194288ac9bcdc6ea0b73807e">asio::read_until</a>(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, <span class="charliteral">&#39;\n&#39;</span>);</div>
<div class="line">std::istream is(&amp;<a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>);</div>
<div class="line">std::string line;</div>
<div class="line">std::getline(is, line); </div>
</div><!-- fragment --> After the <code>read_until</code> operation completes successfully, the buffer <code>b</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>std::getline</code> then extracts the data up to and including the newline (which is discarded), so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span> } </div>
</div><!-- fragment --> The remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>read_until</code> operation. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a1aae2baa82596a6a9ad320e80b016006_cgraph.svg" width="631" height="68"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ab9d265cc5b757caf9c9a602da2d6a3e5" name="ab9d265cc5b757caf9c9a602da2d6a3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d265cc5b757caf9c9a602da2d6a3e5">&#9670;&#160;</a></span>read_until() <span class="overload">[4/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>delim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data into a streambuf until it contains a specified delimiter. </p>
<p>This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the streambuf's get area up to and including the delimiter. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_ab9d265cc5b757caf9c9a602da2d6a3e5_cgraph.svg" width="631" height="68"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aacb23419d8878f33e469e3f743c738d6" name="aacb23419d8878f33e469e3f743c738d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb23419d8878f33e469e3f743c738d6">&#9670;&#160;</a></span>read_until() <span class="overload">[5/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename Allocator, typename MatchCondition&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition</td>          <td class="paramname"><span class="paramname"><em>match_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data into a streambuf until a function object indicates a match. </p>
<p>This function is used to read data into the specified streambuf until a user-defined match condition function object, when applied to the data contained in the streambuf, indicates a successful match. The call will block until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the match condition function object already indicates a match, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; <a class="code hl_variable" href="#a0b30afc4cf6e545180cda990770c535e">match_condition</a>(iterator <a class="code hl_typedef" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>, iterator <a class="code hl_typedef" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1buffers__iterator.html">buffers_iterator&lt;basic_streambuf&lt;Allocator&gt;::const_buffers_type</a>&gt;</div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the streambuf's get area that have been fully consumed by the match function. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond that which matched the function object. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_aacb23419d8878f33e469e3f743c738d6_cgraph.svg" width="631" height="68"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a5aa4b441eca98c82a144cb9a3c625db4" name="a5aa4b441eca98c82a144cb9a3c625db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa4b441eca98c82a144cb9a3c625db4">&#9670;&#160;</a></span>read_until() <span class="overload">[6/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename Allocator, typename MatchCondition&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition</td>          <td class="paramname"><span class="paramname"><em>match_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data into a streambuf until a function object indicates a match. </p>
<p>This function is used to read data into the specified streambuf until a user-defined match condition function object, when applied to the data contained in the streambuf, indicates a successful match. The call will block until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the match condition function object already indicates a match, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; <a class="code hl_variable" href="#a0b30afc4cf6e545180cda990770c535e">match_condition</a>(iterator <a class="code hl_typedef" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>, iterator <a class="code hl_typedef" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1buffers__iterator.html">buffers_iterator&lt;basic_streambuf&lt;Allocator&gt;::const_buffers_type</a>&gt;</div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the streambuf's get area that have been fully consumed by the match function.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond that which matched the function object. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>To read data into a streambuf until whitespace is encountered: <div class="fragment"><div class="line"> <span class="keyword">typedef</span> <a class="code hl_class" href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a>&lt;</div>
<div class="line">    <a class="code hl_typedef" href="classasio_1_1basic__streambuf.html#a9e2ffddcb9e89d68048254ea787c2258">asio::streambuf::const_buffers_type</a>&gt; iterator;</div>
<div class="line"> </div>
<div class="line">std::pair&lt;iterator, bool&gt;</div>
<div class="line">match_whitespace(iterator <a class="code hl_typedef" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>, iterator <a class="code hl_typedef" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>)</div>
<div class="line">{</div>
<div class="line">  iterator <a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> = <a class="code hl_typedef" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>;</div>
<div class="line">  <span class="keywordflow">while</span> (<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> != <a class="code hl_typedef" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>)</div>
<div class="line">    <span class="keywordflow">if</span> (std::isspace(*<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>++))</div>
<div class="line">      <span class="keywordflow">return</span> std::make_pair(<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, <span class="keyword">true</span>);</div>
<div class="line">  <span class="keywordflow">return</span> std::make_pair(<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">asio::streambuf <a class="code hl_variable" href="jpegint_8h.html#af320905358fa78701e4cc60b6135601f">b</a>;</div>
<div class="line"><a class="code hl_function" href="#a49ff1260194288ac9bcdc6ea0b73807e">asio::read_until</a>(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="jpegint_8h.html#af320905358fa78701e4cc60b6135601f">b</a>, match_whitespace);</div>
</div><!-- fragment --></dd></dl>
<p>To read data into a streambuf until a matching character is found: </p><div class="fragment"><div class="line"> <span class="keyword">class </span>match_char</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> match_char(<span class="keywordtype">char</span> <a class="code hl_variable" href="Spc__Cpu_8h.html#a4e1e0e72dd773439e333c84dd762a9c3">c</a>) : c_(<a class="code hl_variable" href="Spc__Cpu_8h.html#a4e1e0e72dd773439e333c84dd762a9c3">c</a>) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line">  std::pair&lt;Iterator, bool&gt; operator()(</div>
<div class="line">      Iterator begin, Iterator end)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    Iterator <a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> = begin;</div>
<div class="line">    <span class="keywordflow">while</span> (<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> != end)</div>
<div class="line">      <span class="keywordflow">if</span> (c_ == *<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>++)</div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, <span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordflow">return</span> std::make_pair(<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, <span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">char</span> c_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>asio {</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code hl_struct" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt;match_char&gt;</div>
<div class="line">    : <span class="keyword">public</span> boost::true_type {};</div>
<div class="line">} <span class="comment">// namespace asio</span></div>
<div class="line">...</div>
<div class="line">asio::streambuf <a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>;</div>
<div class="line"><a class="code hl_function" href="#a49ff1260194288ac9bcdc6ea0b73807e">asio::read_until</a>(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>, match_char(<span class="charliteral">&#39;a&#39;</span>));</div>
</div><!-- fragment --> <div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a5aa4b441eca98c82a144cb9a3c625db4_cgraph.svg" width="631" height="68"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a86b246368f232bcadec5ba61eb146ef3" name="a86b246368f232bcadec5ba61eb146ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b246368f232bcadec5ba61eb146ef3">&#9670;&#160;</a></span>read_until() <span class="overload">[7/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename DynamicBuffer_v1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1)</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a></td>          <td class="paramname"><span class="paramname"><em>delim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a86b246368f232bcadec5ba61eb146ef3_cgraph.svg" width="290" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ada416a8709a21c605687f43882a006ec" name="ada416a8709a21c605687f43882a006ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada416a8709a21c605687f43882a006ec">&#9670;&#160;</a></span>read_until() <span class="overload">[8/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename DynamicBuffer_v1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1)</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a></td>          <td class="paramname"><span class="paramname"><em>delim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read data into a <code>std::string</code> until a CR-LF sequence is encountered: <div class="fragment"><div class="line"> std::string <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>;</div>
<div class="line">std::string n = <a class="code hl_function" href="#a49ff1260194288ac9bcdc6ea0b73807e">asio::read_until</a>(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>,</div>
<div class="line">    <a class="code hl_function" href="#a082ceaa5ce3217fda0bcc008a211a272">asio::dynamic_buffer</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>), <span class="stringliteral">&quot;\r\n&quot;</span>);</div>
<div class="line">std::string line = <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.substr(0, n);</div>
<div class="line"><a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.erase(0, n); </div>
<div class="ttc" id="anamespaceasio_html_a082ceaa5ce3217fda0bcc008a211a272"><div class="ttname"><a href="#a082ceaa5ce3217fda0bcc008a211a272">asio::dynamic_buffer</a></div><div class="ttdeci">dynamic_string_buffer&lt; Elem, Traits, Allocator &gt; dynamic_buffer(std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data) ASIO_NOEXCEPT</div><div class="ttdoc">Create a new dynamic buffer that represents the given string.</div><div class="ttdef"><b>Definition</b> buffer.hpp:2097</div></div>
</div><!-- fragment --> After the <code>read_until</code> operation completes successfully, the string <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>read_until</code> operation. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_ada416a8709a21c605687f43882a006ec_cgraph.svg" width="631" height="94"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="abd583f2d812419d975bbc69d37f1f739" name="abd583f2d812419d975bbc69d37f1f739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd583f2d812419d975bbc69d37f1f739">&#9670;&#160;</a></span>read_until() <span class="overload">[9/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename DynamicBuffer_v1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1)</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>delim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine. </dd></dl>

</div>
</div>
<a id="a49ff1260194288ac9bcdc6ea0b73807e" name="a49ff1260194288ac9bcdc6ea0b73807e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ff1260194288ac9bcdc6ea0b73807e">&#9670;&#160;</a></span>read_until() <span class="overload">[10/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename DynamicBuffer_v1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1)</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>delim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read data into a <code>std::string</code> until a newline is encountered: <div class="fragment"><div class="line"> std::string <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>;</div>
<div class="line">std::string n = <a class="code hl_function" href="#a49ff1260194288ac9bcdc6ea0b73807e">asio::read_until</a>(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>,</div>
<div class="line">    <a class="code hl_function" href="#a082ceaa5ce3217fda0bcc008a211a272">asio::dynamic_buffer</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>), <span class="charliteral">&#39;\n&#39;</span>);</div>
<div class="line">std::string line = <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.substr(0, n);</div>
<div class="line"><a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.erase(0, n); </div>
</div><!-- fragment --> After the <code>read_until</code> operation completes successfully, the string <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>read_until</code> operation. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a49ff1260194288ac9bcdc6ea0b73807e_cgraph.svg" width="476" height="68"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a49ff1260194288ac9bcdc6ea0b73807e_icgraph.svg" width="274" height="530"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a5d6f8bd4b1ac0fdf5937ab513f38eebf" name="a5d6f8bd4b1ac0fdf5937ab513f38eebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d6f8bd4b1ac0fdf5937ab513f38eebf">&#9670;&#160;</a></span>read_until() <span class="overload">[11/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename DynamicBuffer_v1, typename MatchCondition&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1)</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition</td>          <td class="paramname"><span class="paramname"><em>match_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;<a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until a function object indicates a match. This function is used to read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. The call will block until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the match condition function object already indicates a match, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>A dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; <a class="code hl_variable" href="#a0b30afc4cf6e545180cda990770c535e">match_condition</a>(iterator <a class="code hl_typedef" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>, iterator <a class="code hl_typedef" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1buffers__iterator.html">buffers_iterator&lt;DynamicBuffer_v1::const_buffers_type&gt;</a></div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area that have been fully consumed by the match function. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects. </dd></dl>

</div>
</div>
<a id="a129234c517df519e5ffec9fabc5bc1a8" name="a129234c517df519e5ffec9fabc5bc1a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129234c517df519e5ffec9fabc5bc1a8">&#9670;&#160;</a></span>read_until() <span class="overload">[12/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename DynamicBuffer_v1, typename MatchCondition&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1)</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition</td>          <td class="paramname"><span class="paramname"><em>match_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;<a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until a function object indicates a match. This function is used to read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. The call will block until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the match condition function object already indicates a match, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>A dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; <a class="code hl_variable" href="#a0b30afc4cf6e545180cda990770c535e">match_condition</a>(iterator <a class="code hl_typedef" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>, iterator <a class="code hl_typedef" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1buffers__iterator.html">buffers_iterator&lt;typename DynamicBuffer_v1::const_buffers_type&gt;</a></div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic_buffer's get area that have been fully consumed by the match function.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>To read data into a dynamic buffer sequence until whitespace is encountered: <div class="fragment"><div class="line"> <span class="keyword">typedef</span> <a class="code hl_class" href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a>&lt;</div>
<div class="line">    <a class="code hl_class" href="classasio_1_1const__buffers__1.html">asio::const_buffers_1</a>&gt; iterator;</div>
<div class="line"> </div>
<div class="line">std::pair&lt;iterator, bool&gt;</div>
<div class="line">match_whitespace(iterator <a class="code hl_typedef" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>, iterator <a class="code hl_typedef" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>)</div>
<div class="line">{</div>
<div class="line">  iterator <a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> = <a class="code hl_typedef" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>;</div>
<div class="line">  <span class="keywordflow">while</span> (<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> != <a class="code hl_typedef" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>)</div>
<div class="line">    <span class="keywordflow">if</span> (std::isspace(*<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>++))</div>
<div class="line">      <span class="keywordflow">return</span> std::make_pair(<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, <span class="keyword">true</span>);</div>
<div class="line">  <span class="keywordflow">return</span> std::make_pair(<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">std::string <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>;</div>
<div class="line"><a class="code hl_function" href="#a49ff1260194288ac9bcdc6ea0b73807e">asio::read_until</a>(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, match_whitespace);</div>
</div><!-- fragment --></dd></dl>
<p>To read data into a <code>std::string</code> until a matching character is found: </p><div class="fragment"><div class="line"> <span class="keyword">class </span>match_char</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> match_char(<span class="keywordtype">char</span> <a class="code hl_variable" href="Spc__Cpu_8h.html#a4e1e0e72dd773439e333c84dd762a9c3">c</a>) : c_(<a class="code hl_variable" href="Spc__Cpu_8h.html#a4e1e0e72dd773439e333c84dd762a9c3">c</a>) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line">  std::pair&lt;Iterator, bool&gt; operator()(</div>
<div class="line">      Iterator begin, Iterator end)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    Iterator <a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> = begin;</div>
<div class="line">    <span class="keywordflow">while</span> (<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> != end)</div>
<div class="line">      <span class="keywordflow">if</span> (c_ == *<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>++)</div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, <span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordflow">return</span> std::make_pair(<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, <span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">char</span> c_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>asio {</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code hl_struct" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt;match_char&gt;</div>
<div class="line">    : <span class="keyword">public</span> boost::true_type {};</div>
<div class="line">} <span class="comment">// namespace asio</span></div>
<div class="line">...</div>
<div class="line">std::string <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>;</div>
<div class="line"><a class="code hl_function" href="#a49ff1260194288ac9bcdc6ea0b73807e">asio::read_until</a>(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, match_char(<span class="charliteral">&#39;a&#39;</span>));</div>
</div><!-- fragment --> <div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a129234c517df519e5ffec9fabc5bc1a8_cgraph.svg" width="631" height="94"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aec29c48526eb7ca6c1b440c8f98726e9" name="aec29c48526eb7ca6c1b440c8f98726e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec29c48526eb7ca6c1b440c8f98726e9">&#9670;&#160;</a></span>read_until() <span class="overload">[13/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename DynamicBuffer_v2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a></td>          <td class="paramname"><span class="paramname"><em>delim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_aec29c48526eb7ca6c1b440c8f98726e9_cgraph.svg" width="290" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a4fe46a96bdd946fffc1c226444a180f5" name="a4fe46a96bdd946fffc1c226444a180f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe46a96bdd946fffc1c226444a180f5">&#9670;&#160;</a></span>read_until() <span class="overload">[14/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename DynamicBuffer_v2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a></td>          <td class="paramname"><span class="paramname"><em>delim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read data into a <code>std::string</code> until a CR-LF sequence is encountered: <div class="fragment"><div class="line"> std::string <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>;</div>
<div class="line">std::string n = <a class="code hl_function" href="#a49ff1260194288ac9bcdc6ea0b73807e">asio::read_until</a>(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>,</div>
<div class="line">    <a class="code hl_function" href="#a082ceaa5ce3217fda0bcc008a211a272">asio::dynamic_buffer</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>), <span class="stringliteral">&quot;\r\n&quot;</span>);</div>
<div class="line">std::string line = <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.substr(0, n);</div>
<div class="line"><a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.erase(0, n); </div>
</div><!-- fragment --> After the <code>read_until</code> operation completes successfully, the string <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>read_until</code> operation. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a4fe46a96bdd946fffc1c226444a180f5_cgraph.svg" width="631" height="94"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a71bd6351279c888f194fe8d226c60d2a" name="a71bd6351279c888f194fe8d226c60d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71bd6351279c888f194fe8d226c60d2a">&#9670;&#160;</a></span>read_until() <span class="overload">[15/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename DynamicBuffer_v2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>delim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine. </dd></dl>

</div>
</div>
<a id="a6570b94e42614f0ba103a44c07928587" name="a6570b94e42614f0ba103a44c07928587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6570b94e42614f0ba103a44c07928587">&#9670;&#160;</a></span>read_until() <span class="overload">[16/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename DynamicBuffer_v2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>delim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read data into a <code>std::string</code> until a newline is encountered: <div class="fragment"><div class="line"> std::string <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>;</div>
<div class="line">std::string n = <a class="code hl_function" href="#a49ff1260194288ac9bcdc6ea0b73807e">asio::read_until</a>(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>,</div>
<div class="line">    <a class="code hl_function" href="#a082ceaa5ce3217fda0bcc008a211a272">asio::dynamic_buffer</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>), <span class="charliteral">&#39;\n&#39;</span>);</div>
<div class="line">std::string line = <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.substr(0, n);</div>
<div class="line"><a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>.erase(0, n); </div>
</div><!-- fragment --> After the <code>read_until</code> operation completes successfully, the string <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div>
</div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div>
</div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>read_until</code> operation. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a6570b94e42614f0ba103a44c07928587_cgraph.svg" width="631" height="94"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aa5ddaf76b60c08ea7a53c0d0592c81be" name="aa5ddaf76b60c08ea7a53c0d0592c81be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ddaf76b60c08ea7a53c0d0592c81be">&#9670;&#160;</a></span>read_until() <span class="overload">[17/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename DynamicBuffer_v2, typename MatchCondition&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition</td>          <td class="paramname"><span class="paramname"><em>match_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until a function object indicates a match. This function is used to read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. The call will block until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the match condition function object already indicates a match, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>A dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; <a class="code hl_variable" href="#a0b30afc4cf6e545180cda990770c535e">match_condition</a>(iterator <a class="code hl_typedef" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>, iterator <a class="code hl_typedef" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1buffers__iterator.html">buffers_iterator&lt;DynamicBuffer_v2::const_buffers_type&gt;</a></div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area that have been fully consumed by the match function. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects. </dd></dl>

</div>
</div>
<a id="a207f1897ca08a4be247c507cf61910b4" name="a207f1897ca08a4be247c507cf61910b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a207f1897ca08a4be247c507cf61910b4">&#9670;&#160;</a></span>read_until() <span class="overload">[18/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename DynamicBuffer_v2, typename MatchCondition&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition</td>          <td class="paramname"><span class="paramname"><em>match_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read data into a dynamic buffer sequence until a function object indicates a match. This function is used to read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. The call will block until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the match condition function object already indicates a match, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>A dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; <a class="code hl_variable" href="#a0b30afc4cf6e545180cda990770c535e">match_condition</a>(iterator <a class="code hl_typedef" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>, iterator <a class="code hl_typedef" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>);</div>
</div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line"><a class="code hl_class" href="classasio_1_1buffers__iterator.html">buffers_iterator&lt;typename DynamicBuffer_v2::const_buffers_type&gt;</a></div>
</div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic_buffer's get area that have been fully consumed by the match function.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>To read data into a dynamic buffer sequence until whitespace is encountered: <div class="fragment"><div class="line"> <span class="keyword">typedef</span> <a class="code hl_class" href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a>&lt;</div>
<div class="line">    <a class="code hl_class" href="classasio_1_1const__buffers__1.html">asio::const_buffers_1</a>&gt; iterator;</div>
<div class="line"> </div>
<div class="line">std::pair&lt;iterator, bool&gt;</div>
<div class="line">match_whitespace(iterator <a class="code hl_typedef" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>, iterator <a class="code hl_typedef" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>)</div>
<div class="line">{</div>
<div class="line">  iterator <a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> = <a class="code hl_typedef" href="#a29630b390f0e1aa1a8121ec3962ea9eb">begin</a>;</div>
<div class="line">  <span class="keywordflow">while</span> (<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> != <a class="code hl_typedef" href="#ab90565a6d8a05fc349e42527443ca30f">end</a>)</div>
<div class="line">    <span class="keywordflow">if</span> (std::isspace(*<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>++))</div>
<div class="line">      <span class="keywordflow">return</span> std::make_pair(<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, <span class="keyword">true</span>);</div>
<div class="line">  <span class="keywordflow">return</span> std::make_pair(<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, <span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">std::string <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>;</div>
<div class="line"><a class="code hl_function" href="#a49ff1260194288ac9bcdc6ea0b73807e">asio::read_until</a>(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, match_whitespace);</div>
</div><!-- fragment --></dd></dl>
<p>To read data into a <code>std::string</code> until a matching character is found: </p><div class="fragment"><div class="line"> <span class="keyword">class </span>match_char</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> match_char(<span class="keywordtype">char</span> <a class="code hl_variable" href="Spc__Cpu_8h.html#a4e1e0e72dd773439e333c84dd762a9c3">c</a>) : c_(<a class="code hl_variable" href="Spc__Cpu_8h.html#a4e1e0e72dd773439e333c84dd762a9c3">c</a>) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div>
<div class="line">  std::pair&lt;Iterator, bool&gt; operator()(</div>
<div class="line">      Iterator begin, Iterator end)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    Iterator <a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> = begin;</div>
<div class="line">    <span class="keywordflow">while</span> (<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> != end)</div>
<div class="line">      <span class="keywordflow">if</span> (c_ == *<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>++)</div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, <span class="keyword">true</span>);</div>
<div class="line">    <span class="keywordflow">return</span> std::make_pair(<a class="code hl_variable" href="src_23rdparty_2jack2_2tests_2test_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>, <span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">char</span> c_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>asio {</div>
<div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code hl_struct" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt;match_char&gt;</div>
<div class="line">    : <span class="keyword">public</span> boost::true_type {};</div>
<div class="line">} <span class="comment">// namespace asio</span></div>
<div class="line">...</div>
<div class="line">std::string <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>;</div>
<div class="line"><a class="code hl_function" href="#a49ff1260194288ac9bcdc6ea0b73807e">asio::read_until</a>(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, match_char(<span class="charliteral">&#39;a&#39;</span>));</div>
</div><!-- fragment --> <div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a207f1897ca08a4be247c507cf61910b4_cgraph.svg" width="631" height="94"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aaf2dc4bc523764497147013d1c3ef4eb" name="aaf2dc4bc523764497147013d1c3ef4eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2dc4bc523764497147013d1c3ef4eb">&#9670;&#160;</a></span>redirect_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1redirect__error__t.html">redirect_error_t</a>&lt; typename decay&lt; CompletionToken &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt; asio::redirect_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(CompletionToken)</td>          <td class="paramname"><span class="paramname"><em>completion_token</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a completion token to capture <a class="el" href="classasio_1_1error__code.html" title="Class to represent an error code value.">error_code</a> values to a variable. </p>

</div>
</div>
<a id="af6cc8ba57dc5d66607b764c8d28d7ea6" name="af6cc8ba57dc5d66607b764c8d28d7ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6cc8ba57dc5d66607b764c8d28d7ea6">&#9670;&#160;</a></span>spawn() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a> asio::spawn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(Function)</td>          <td class="paramname"><span class="paramname"><em>function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> boost::coroutines::attributes &amp;</td>          <td class="paramname"><span class="paramname"><em>attributes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">boost::coroutines::attributes()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start a new stackful coroutine, calling the specified handler when it completes. This function is used to launch a new coroutine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>The coroutine function. The function must have the signature: <div class="fragment"><div class="line"><span class="keywordtype">void</span> function(<a class="code hl_class" href="classasio_1_1basic__yield__context.html">basic_yield_context&lt;Handler&gt;</a> <a class="code hl_define" href="yield_8hpp.html#abaa9287233697b1cd0175180304c7e1d">yield</a>); </div>
<div class="ttc" id="aclassasio_1_1basic__yield__context_html"><div class="ttname"><a href="classasio_1_1basic__yield__context.html">asio::basic_yield_context</a></div><div class="ttdoc">Context object the represents the currently executing coroutine.</div><div class="ttdef"><b>Definition</b> spawn.hpp:53</div></div>
<div class="ttc" id="ayield_8hpp_html_abaa9287233697b1cd0175180304c7e1d"><div class="ttname"><a href="yield_8hpp.html#abaa9287233697b1cd0175180304c7e1d">yield</a></div><div class="ttdeci">#define yield</div><div class="ttdef"><b>Definition</b> yield.hpp:18</div></div>
</div><!-- fragment --></td></tr>
    <tr><td class="paramname">attributes</td><td>Boost.Coroutine attributes used to customise the coroutine. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_af6cc8ba57dc5d66607b764c8d28d7ea6_cgraph.svg" width="530" height="68"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_af6cc8ba57dc5d66607b764c8d28d7ea6_icgraph.svg" width="238" height="184"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a070eba0e9e578cd6f164156b0b6e38fc" name="a070eba0e9e578cd6f164156b0b6e38fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070eba0e9e578cd6f164156b0b6e38fc">&#9670;&#160;</a></span>spawn() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Handler, typename Function&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a> asio::spawn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(Handler)</td>          <td class="paramname"><span class="paramname"><em>handler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(Function)</td>          <td class="paramname"><span class="paramname"><em>function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> boost::coroutines::attributes &amp;</td>          <td class="paramname"><span class="paramname"><em>attributes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">boost::coroutines::attributes()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; typename decay&lt; Handler &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!is_convertible&lt; Handler &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start a new stackful coroutine, calling the specified handler when it completes. This function is used to launch a new coroutine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>A handler to be called when the coroutine exits. More importantly, the handler provides an execution context (via the the handler invocation hook) for the coroutine. The handler must have the signature: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(); </div>
</div><!-- fragment --></td></tr>
    <tr><td class="paramname">function</td><td>The coroutine function. The function must have the signature: <div class="fragment"><div class="line"><span class="keywordtype">void</span> function(<a class="code hl_class" href="classasio_1_1basic__yield__context.html">basic_yield_context&lt;Handler&gt;</a> <a class="code hl_define" href="yield_8hpp.html#abaa9287233697b1cd0175180304c7e1d">yield</a>); </div>
</div><!-- fragment --></td></tr>
    <tr><td class="paramname">attributes</td><td>Boost.Coroutine attributes used to customise the coroutine. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a070eba0e9e578cd6f164156b0b6e38fc_cgraph.svg" width="100%" height="437"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a96a673b1867f7983c6701bb0dc658c36" name="a96a673b1867f7983c6701bb0dc658c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a673b1867f7983c6701bb0dc658c36">&#9670;&#160;</a></span>spawn() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Handler, typename Function&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a> asio::spawn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; Handler &gt;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(Function)</td>          <td class="paramname"><span class="paramname"><em>function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> boost::coroutines::attributes &amp;</td>          <td class="paramname"><span class="paramname"><em>attributes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">boost::coroutines::attributes()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a new stackful coroutine, inheriting the execution context of another. </p>
<p>This function is used to launch a new coroutine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Identifies the current coroutine as a parent of the new coroutine. This specifies that the new coroutine should inherit the execution context of the parent. For example, if the parent coroutine is executing in a particular strand, then the new coroutine will execute in the same strand.</td></tr>
    <tr><td class="paramname">function</td><td>The coroutine function. The function must have the signature: <div class="fragment"><div class="line"><span class="keywordtype">void</span> function(<a class="code hl_class" href="classasio_1_1basic__yield__context.html">basic_yield_context&lt;Handler&gt;</a> <a class="code hl_define" href="yield_8hpp.html#abaa9287233697b1cd0175180304c7e1d">yield</a>); </div>
</div><!-- fragment --></td></tr>
    <tr><td class="paramname">attributes</td><td>Boost.Coroutine attributes used to customise the coroutine. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a96a673b1867f7983c6701bb0dc658c36_cgraph.svg" width="100%" height="437"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a61e4ad40fada7bc4c374309b8b6bc5b5" name="a61e4ad40fada7bc4c374309b8b6bc5b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e4ad40fada7bc4c374309b8b6bc5b5">&#9670;&#160;</a></span>spawn() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a> asio::spawn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1io__context_1_1strand.html">asio::io_context::strand</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(Function)</td>          <td class="paramname"><span class="paramname"><em>function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> boost::coroutines::attributes &amp;</td>          <td class="paramname"><span class="paramname"><em>attributes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">boost::coroutines::attributes()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start a new stackful coroutine that executes in the context of a strand. </p>
<p>This function is used to launch a new coroutine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Identifies a strand. By starting multiple coroutines on the same strand, the implementation ensures that none of those coroutines can execute simultaneously.</td></tr>
    <tr><td class="paramname">function</td><td>The coroutine function. The function must have the signature: <div class="fragment"><div class="line"><span class="keywordtype">void</span> function(<a class="code hl_typedef" href="#a9924bebddd5beaed619069edb81f09d7">yield_context</a> <a class="code hl_define" href="yield_8hpp.html#abaa9287233697b1cd0175180304c7e1d">yield</a>); </div>
<div class="ttc" id="anamespaceasio_html_a9924bebddd5beaed619069edb81f09d7"><div class="ttname"><a href="#a9924bebddd5beaed619069edb81f09d7">asio::yield_context</a></div><div class="ttdeci">basic_yield_context&lt; executor_binder&lt; void(*)(), executor &gt; &gt; yield_context</div><div class="ttdef"><b>Definition</b> spawn.hpp:154</div></div>
</div><!-- fragment --></td></tr>
    <tr><td class="paramname">attributes</td><td>Boost.Coroutine attributes used to customise the coroutine. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a61e4ad40fada7bc4c374309b8b6bc5b5_cgraph.svg" width="100%" height="437"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="adec63d482b774deed5e8ecb37a90ee34" name="adec63d482b774deed5e8ecb37a90ee34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec63d482b774deed5e8ecb37a90ee34">&#9670;&#160;</a></span>spawn() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function, typename Executor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a> asio::spawn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Executor &amp;</td>          <td class="paramname"><span class="paramname"><em>ex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(Function)</td>          <td class="paramname"><span class="paramname"><em>function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> boost::coroutines::attributes &amp;</td>          <td class="paramname"><span class="paramname"><em>attributes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">boost::coroutines::attributes()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start a new stackful coroutine that executes on a given executor. </p>
<p>This function is used to launch a new coroutine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>Identifies the executor that will run the coroutine. The new coroutine is implicitly given its own strand within this executor.</td></tr>
    <tr><td class="paramname">function</td><td>The coroutine function. The function must have the signature: <div class="fragment"><div class="line"><span class="keywordtype">void</span> function(<a class="code hl_typedef" href="#a9924bebddd5beaed619069edb81f09d7">yield_context</a> <a class="code hl_define" href="yield_8hpp.html#abaa9287233697b1cd0175180304c7e1d">yield</a>); </div>
</div><!-- fragment --></td></tr>
    <tr><td class="paramname">attributes</td><td>Boost.Coroutine attributes used to customise the coroutine. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_adec63d482b774deed5e8ecb37a90ee34_cgraph.svg" width="667" height="68"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a716b2b7e00ba379e54648ffe56dab229" name="a716b2b7e00ba379e54648ffe56dab229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716b2b7e00ba379e54648ffe56dab229">&#9670;&#160;</a></span>spawn() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function, typename Executor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a> asio::spawn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1strand.html">strand</a>&lt; Executor &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(Function)</td>          <td class="paramname"><span class="paramname"><em>function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> boost::coroutines::attributes &amp;</td>          <td class="paramname"><span class="paramname"><em>attributes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">boost::coroutines::attributes()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start a new stackful coroutine that executes on a given strand. </p>
<p>This function is used to launch a new coroutine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>Identifies the strand that will run the coroutine.</td></tr>
    <tr><td class="paramname">function</td><td>The coroutine function. The function must have the signature: <div class="fragment"><div class="line"><span class="keywordtype">void</span> function(<a class="code hl_typedef" href="#a9924bebddd5beaed619069edb81f09d7">yield_context</a> <a class="code hl_define" href="yield_8hpp.html#abaa9287233697b1cd0175180304c7e1d">yield</a>); </div>
</div><!-- fragment --></td></tr>
    <tr><td class="paramname">attributes</td><td>Boost.Coroutine attributes used to customise the coroutine. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a716b2b7e00ba379e54648ffe56dab229_cgraph.svg" width="100%" height="437"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a864b8c8c72e7cbfce7bc84a378d2a3f3" name="a864b8c8c72e7cbfce7bc84a378d2a3f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864b8c8c72e7cbfce7bc84a378d2a3f3">&#9670;&#160;</a></span>spawn() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function, typename ExecutionContext&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unzipfx-carla-control_2unzip_8h.html#aa8c59027f9ab2769342f248709d68d17">void</a> asio::spawn </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(Function)</td>          <td class="paramname"><span class="paramname"><em>function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> boost::coroutines::attributes &amp;</td>          <td class="paramname"><span class="paramname"><em>attributes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">boost::coroutines::attributes()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp; &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start a new stackful coroutine that executes on a given execution context. </p>
<p>This function is used to launch a new coroutine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Identifies the execution context that will run the coroutine. The new coroutine is implicitly given its own strand within this execution context.</td></tr>
    <tr><td class="paramname">function</td><td>The coroutine function. The function must have the signature: <div class="fragment"><div class="line"><span class="keywordtype">void</span> function(<a class="code hl_typedef" href="#a9924bebddd5beaed619069edb81f09d7">yield_context</a> <a class="code hl_define" href="yield_8hpp.html#abaa9287233697b1cd0175180304c7e1d">yield</a>); </div>
</div><!-- fragment --></td></tr>
    <tr><td class="paramname">attributes</td><td>Boost.Coroutine attributes used to customise the coroutine. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a864b8c8c72e7cbfce7bc84a378d2a3f3_cgraph.svg" width="667" height="68"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ac4859eacaf587bf46901d9597e139f6c" name="ac4859eacaf587bf46901d9597e139f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4859eacaf587bf46901d9597e139f6c">&#9670;&#160;</a></span>system_category()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#ab54d01ea04afeb9a8b39cfac467656b7">ASIO_DECL</a> <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> <a class="el" href="classasio_1_1error__category.html">error_category</a> &amp; asio::system_category </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the error category used for the system errors produced by asio. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_ac4859eacaf587bf46901d9597e139f6c_icgraph.svg" width="619" height="280"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a4a82e92df79aa8401a8bc2117d4cf900" name="a4a82e92df79aa8401a8bc2117d4cf900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a82e92df79aa8401a8bc2117d4cf900">&#9670;&#160;</a></span>transfer_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1detail_1_1transfer__all__t.html">detail::transfer_all_t</a> asio::transfer_all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a completion condition function object that indicates that a read or write operation should continue until all of the data has been transferred, or until an error occurs. This function is used to create an object, of unspecified type, that meets CompletionCondition requirements.</p>
<dl class="section user"><dt>Example</dt><dd>Reading until a buffer is full: <div class="fragment"><div class="line"><a class="code hl_class" href="classboost_1_1array.html">boost::array&lt;char, 128&gt;</a> buf;</div>
<div class="line"><a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a> ec;</div>
<div class="line">std::size_t n = <a class="code hl_function" href="#ac2d04c42f9c62cfdfad22c1e47371afe">asio::read</a>(</div>
<div class="line">    sock, <a class="code hl_function" href="#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(buf),</div>
<div class="line">    <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">  <span class="comment">// n == 128</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassboost_1_1array_html"><div class="ttname"><a href="classboost_1_1array.html">boost::array</a></div><div class="ttdef"><b>Definition</b> array_fwd.hpp:23</div></div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a4a82e92df79aa8401a8bc2117d4cf900_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a2b10af704afcd6c7ed7f0d3b740033ef" name="a2b10af704afcd6c7ed7f0d3b740033ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b10af704afcd6c7ed7f0d3b740033ef">&#9670;&#160;</a></span>transfer_at_least()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1detail_1_1transfer__at__least__t.html">detail::transfer_at_least_t</a> asio::transfer_at_least </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>minimum</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a completion condition function object that indicates that a read or write operation should continue until a minimum number of bytes has been transferred, or until an error occurs. This function is used to create an object, of unspecified type, that meets CompletionCondition requirements.</p>
<dl class="section user"><dt>Example</dt><dd>Reading until a buffer is full or contains at least 64 bytes: <div class="fragment"><div class="line"><a class="code hl_class" href="classboost_1_1array.html">boost::array&lt;char, 128&gt;</a> buf;</div>
<div class="line"><a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a> ec;</div>
<div class="line">std::size_t n = <a class="code hl_function" href="#ac2d04c42f9c62cfdfad22c1e47371afe">asio::read</a>(</div>
<div class="line">    sock, <a class="code hl_function" href="#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(buf),</div>
<div class="line">    <a class="code hl_function" href="#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(64), ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">  <span class="comment">// n &gt;= 64 &amp;&amp; n &lt;= 128</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="adb2ada9400d78a5df0e5f65dd2b9967e" name="adb2ada9400d78a5df0e5f65dd2b9967e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2ada9400d78a5df0e5f65dd2b9967e">&#9670;&#160;</a></span>transfer_exactly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1detail_1_1transfer__exactly__t.html">detail::transfer_exactly_t</a> asio::transfer_exactly </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a completion condition function object that indicates that a read or write operation should continue until an exact number of bytes has been transferred, or until an error occurs. This function is used to create an object, of unspecified type, that meets CompletionCondition requirements.</p>
<dl class="section user"><dt>Example</dt><dd>Reading until a buffer is full or contains exactly 64 bytes: <div class="fragment"><div class="line"><a class="code hl_class" href="classboost_1_1array.html">boost::array&lt;char, 128&gt;</a> buf;</div>
<div class="line"><a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a> ec;</div>
<div class="line">std::size_t n = <a class="code hl_function" href="#ac2d04c42f9c62cfdfad22c1e47371afe">asio::read</a>(</div>
<div class="line">    sock, <a class="code hl_function" href="#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(buf),</div>
<div class="line">    <a class="code hl_function" href="#adb2ada9400d78a5df0e5f65dd2b9967e">asio::transfer_exactly</a>(64), ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">  <span class="comment">// n == 64</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespaceasio_html_adb2ada9400d78a5df0e5f65dd2b9967e"><div class="ttname"><a href="#adb2ada9400d78a5df0e5f65dd2b9967e">asio::transfer_exactly</a></div><div class="ttdeci">detail::transfer_exactly_t transfer_exactly(std::size_t size)</div><div class="ttdef"><b>Definition</b> completion_condition.hpp:206</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a43c69d055116813ff29daebb22bde7e6" name="a43c69d055116813ff29daebb22bde7e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c69d055116813ff29daebb22bde7e6">&#9670;&#160;</a></span>use_service() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Service &amp; asio::use_service </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is used to locate a service object that corresponds to the given service type. If there is no existing implementation of the service, then the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> will create a new instance of the service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution.">execution_context</a> object that owns the service.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The service interface implementing the specified service type. Ownership of the service interface is not transferred to the caller. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a43c69d055116813ff29daebb22bde7e6_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a9947a7e740f8bad04a2307b31fa03919" name="a9947a7e740f8bad04a2307b31fa03919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9947a7e740f8bad04a2307b31fa03919">&#9670;&#160;</a></span>use_service() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Service &amp; asio::use_service </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1io__context.html">io_context</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ioc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is used to locate a service object that corresponds to the given service type. If there is no existing implementation of the service, then the <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality.">io_context</a> will create a new instance of the service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ioc</td><td>The <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality.">io_context</a> object that owns the service.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The service interface implementing the specified service type. Ownership of the service interface is not transferred to the caller.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is preserved for backwards compatibility with services that inherit from <a class="el" href="classasio_1_1io__context_1_1service.html" title="Base class for all io_context services.">io_context::service</a>. </dd></dl>

</div>
</div>
<a id="a764e1235aa162478633294d9b20ef3e3" name="a764e1235aa162478633294d9b20ef3e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764e1235aa162478633294d9b20ef3e3">&#9670;&#160;</a></span>use_service&lt; detail::io_context_impl &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceasio_1_1detail.html#a18464be2f80491d42628366e26c34ff7">detail::io_context_impl</a> &amp; <a class="el" href="#a43c69d055116813ff29daebb22bde7e6">asio::use_service</a>&lt; <a class="el" href="namespaceasio_1_1detail.html#a18464be2f80491d42628366e26c34ff7">detail::io_context_impl</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1io__context.html">io_context</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ioc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a038641314390c2f3f4164457eecdf0ee" name="a038641314390c2f3f4164457eecdf0ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038641314390c2f3f4164457eecdf0ee">&#9670;&#160;</a></span>write() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream, typename DynamicBuffer_v1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1)</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a0836b66664a36ebc7ca74f0441fc4188">asio::write</a>(</div>
<div class="line">   <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
<div class="ttc" id="anamespaceasio_html_a0836b66664a36ebc7ca74f0441fc4188"><div class="ttname"><a href="#a0836b66664a36ebc7ca74f0441fc4188">asio::write</a></div><div class="ttdeci">std::size_t write(SyncWriteStream &amp;s, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, asio::error_code &amp;ec, typename enable_if&lt; is_const_buffer_sequence&lt; ConstBufferSequence &gt;::value &gt;::type *)</div><div class="ttdoc">Write a certain amount of data to a stream before returning.</div><div class="ttdef"><b>Definition</b> write.hpp:63</div></div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a038641314390c2f3f4164457eecdf0ee_cgraph.svg" width="647" height="134"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="abf7e8df8ce570b07f32acd0a3cc0c4e3" name="abf7e8df8ce570b07f32acd0a3cc0c4e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7e8df8ce570b07f32acd0a3cc0c4e3">&#9670;&#160;</a></span>write() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream, typename DynamicBuffer_v1, typename CompletionCondition&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1)</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a certain amount of data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write_some function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_abf7e8df8ce570b07f32acd0a3cc0c4e3_cgraph.svg" width="611" height="124"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ad0706de491271959e2b811fc011b2c53" name="ad0706de491271959e2b811fc011b2c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0706de491271959e2b811fc011b2c53">&#9670;&#160;</a></span>write() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream, typename DynamicBuffer_v1, typename CompletionCondition&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1)</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a certain amount of data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write_some function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_ad0706de491271959e2b811fc011b2c53_cgraph.svg" width="651" height="190"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a3a85a48308f812d037cd64c368e69329" name="a3a85a48308f812d037cd64c368e69329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a85a48308f812d037cd64c368e69329">&#9670;&#160;</a></span>write() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream, typename DynamicBuffer_v1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aebf19830093dfbea6cb74e6fae02a6c8">ASIO_MOVE_ARG</a>(DynamicBuffer_v1)</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v1.html">is_dynamic_buffer_v1</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &amp;&amp;!<a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; typename decay&lt; DynamicBuffer_v1 &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a0836b66664a36ebc7ca74f0441fc4188">asio::write</a>(</div>
<div class="line">   <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a3a85a48308f812d037cd64c368e69329_cgraph.svg" width="651" height="210"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a85807d13da87adf48b62979f65f41152" name="a85807d13da87adf48b62979f65f41152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85807d13da87adf48b62979f65f41152">&#9670;&#160;</a></span>write() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a0836b66664a36ebc7ca74f0441fc4188">asio::write</a>(</div>
<div class="line">   <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a85807d13da87adf48b62979f65f41152_cgraph.svg" width="611" height="124"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="af72f7eddd7d4629ea2e2b7f5b7f355bc" name="af72f7eddd7d4629ea2e2b7f5b7f355bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af72f7eddd7d4629ea2e2b7f5b7f355bc">&#9670;&#160;</a></span>write() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a0836b66664a36ebc7ca74f0441fc4188">asio::write</a>(</div>
<div class="line">   <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_af72f7eddd7d4629ea2e2b7f5b7f355bc_cgraph.svg" width="611" height="124"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aa80988391fb309ee53cc557d0065550a" name="aa80988391fb309ee53cc557d0065550a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80988391fb309ee53cc557d0065550a">&#9670;&#160;</a></span>write() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream, typename Allocator, typename CompletionCondition&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a certain amount of data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write_some function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_aa80988391fb309ee53cc557d0065550a_cgraph.svg" width="611" height="124"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a393e12e427f89cb932c6a2bd800236fb" name="a393e12e427f89cb932c6a2bd800236fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393e12e427f89cb932c6a2bd800236fb">&#9670;&#160;</a></span>write() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream, typename Allocator, typename CompletionCondition&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a certain amount of data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write_some function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a393e12e427f89cb932c6a2bd800236fb_cgraph.svg" width="611" height="124"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a76bea26a365e2db58363090c667ae763" name="a76bea26a365e2db58363090c667ae763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76bea26a365e2db58363090c667ae763">&#9670;&#160;</a></span>write() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream, typename ConstBufferSequence&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the stream.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a0836b66664a36ebc7ca74f0441fc4188">asio::write</a>(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_function" href="#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, size), ec); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a0836b66664a36ebc7ca74f0441fc4188">asio::write</a>(</div>
<div class="line">   <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a76bea26a365e2db58363090c667ae763_cgraph.svg" width="647" height="134"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a0836b66664a36ebc7ca74f0441fc4188" name="a0836b66664a36ebc7ca74f0441fc4188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0836b66664a36ebc7ca74f0441fc4188">&#9670;&#160;</a></span>write() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream, typename ConstBufferSequence, typename CompletionCondition&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a certain amount of data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the stream.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write_some function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a0836b66664a36ebc7ca74f0441fc4188_cgraph.svg" width="483" height="124"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a0836b66664a36ebc7ca74f0441fc4188_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a8386d6d624c52cc30eb22aa0021c66eb" name="a8386d6d624c52cc30eb22aa0021c66eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8386d6d624c52cc30eb22aa0021c66eb">&#9670;&#160;</a></span>write() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream, typename ConstBufferSequence, typename CompletionCondition&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a certain amount of data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the stream.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write_some function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a0836b66664a36ebc7ca74f0441fc4188">asio::write</a>(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_function" href="#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, size),</div>
<div class="line">   <a class="code hl_function" href="#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(32)); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a8386d6d624c52cc30eb22aa0021c66eb_cgraph.svg" width="651" height="190"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a700a5a376b28c391c478707a8dec6b83" name="a700a5a376b28c391c478707a8dec6b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700a5a376b28c391c478707a8dec6b83">&#9670;&#160;</a></span>write() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream, typename ConstBufferSequence&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a0836b66664a36ebc7ca74f0441fc4188">asio::write</a>(<a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_function" href="#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, size)); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a0836b66664a36ebc7ca74f0441fc4188">asio::write</a>(</div>
<div class="line">   <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a700a5a376b28c391c478707a8dec6b83_cgraph.svg" width="651" height="210"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aa78968a00365a30471fc734c91890491" name="aa78968a00365a30471fc734c91890491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78968a00365a30471fc734c91890491">&#9670;&#160;</a></span>write() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream, typename DynamicBuffer_v2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a0836b66664a36ebc7ca74f0441fc4188">asio::write</a>(</div>
<div class="line">   <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_aa78968a00365a30471fc734c91890491_cgraph.svg" width="647" height="134"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ad5cee1a0dd40e2cc9a61c6386123edd5" name="ad5cee1a0dd40e2cc9a61c6386123edd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5cee1a0dd40e2cc9a61c6386123edd5">&#9670;&#160;</a></span>write() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream, typename DynamicBuffer_v2, typename CompletionCondition&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a certain amount of data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write_some function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_ad5cee1a0dd40e2cc9a61c6386123edd5_cgraph.svg" width="611" height="124"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a25da8d99e8028b80391f7c683f1cd4b6" name="a25da8d99e8028b80391f7c683f1cd4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25da8d99e8028b80391f7c683f1cd4b6">&#9670;&#160;</a></span>write() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream, typename DynamicBuffer_v2, typename CompletionCondition&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a certain amount of data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest write_some operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write_some function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a25da8d99e8028b80391f7c683f1cd4b6_cgraph.svg" width="651" height="190"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a2e11be64adb48357a70afd0970b8b89f" name="a2e11be64adb48357a70afd0970b8b89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e11be64adb48357a70afd0970b8b89f">&#9670;&#160;</a></span>write() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncWriteStream, typename DynamicBuffer_v2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write </td>
          <td>(</td>
          <td class="paramtype">SyncWriteStream &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer_v2</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data to a stream before returning. </p>
<p>This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied dynamic buffer sequence has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's write_some function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to which the data is to be written. The type must support the SyncWriteStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a0836b66664a36ebc7ca74f0441fc4188">asio::write</a>(</div>
<div class="line">   <a class="code hl_variable" href="#a551ec1a519b15e013e05cb1fe1c4b362">s</a>, <a class="code hl_variable" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a2e11be64adb48357a70afd0970b8b89f_cgraph.svg" width="651" height="210"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a1db1f75a907c17918092b41f2f242104" name="a1db1f75a907c17918092b41f2f242104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db1f75a907c17918092b41f2f242104">&#9670;&#160;</a></span>write_at() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessWriteDevice, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessWriteDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data at the specified offset before returning. </p>
<p>This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's write_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a51133c1e260b8abeeed55646e765fdd6">asio::write_at</a>(</div>
<div class="line">   d, 42, <a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
<div class="ttc" id="anamespaceasio_html_a51133c1e260b8abeeed55646e765fdd6"><div class="ttname"><a href="#a51133c1e260b8abeeed55646e765fdd6">asio::write_at</a></div><div class="ttdeci">std::size_t write_at(SyncRandomAccessWriteDevice &amp;d, uint64_t offset, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, asio::error_code &amp;ec)</div><div class="ttdoc">Write a certain amount of data at a specified offset before returning.</div><div class="ttdef"><b>Definition</b> write_at.hpp:67</div></div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a1db1f75a907c17918092b41f2f242104_cgraph.svg" width="100%" height="457"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="aa6f42435acf937c35ee4c81af44ee6ce" name="aa6f42435acf937c35ee4c81af44ee6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f42435acf937c35ee4c81af44ee6ce">&#9670;&#160;</a></span>write_at() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessWriteDevice, typename Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessWriteDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data at the specified offset before returning. </p>
<p>This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's write_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a51133c1e260b8abeeed55646e765fdd6">asio::write_at</a>(</div>
<div class="line">   d, 42, <a class="code hl_variable" href="#a945a5c18fa77a9e2eba420f8f44b2a4f">b</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_aa6f42435acf937c35ee4c81af44ee6ce_cgraph.svg" width="664" height="134"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a2e23f5418309ba130d75f6757b7b8e15" name="a2e23f5418309ba130d75f6757b7b8e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e23f5418309ba130d75f6757b7b8e15">&#9670;&#160;</a></span>write_at() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessWriteDevice, typename Allocator, typename CompletionCondition&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessWriteDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a certain amount of data at a specified offset before returning. </p>
<p>This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's write_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest write_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's write_some_at function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a2e23f5418309ba130d75f6757b7b8e15_cgraph.svg" width="100%" height="442"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a431966af634f0701ceac7f54fc1b0371" name="a431966af634f0701ceac7f54fc1b0371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431966af634f0701ceac7f54fc1b0371">&#9670;&#160;</a></span>write_at() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessWriteDevice, typename Allocator, typename CompletionCondition&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessWriteDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a certain amount of data at a specified offset before returning. </p>
<p>This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's write_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">b</td><td>The <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf.">basic_streambuf</a> object from which data will be written.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest write_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's write_some_at function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a431966af634f0701ceac7f54fc1b0371_cgraph.svg" width="647" height="124"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="add67a05a29d183782491d14aceec7d41" name="add67a05a29d183782491d14aceec7d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add67a05a29d183782491d14aceec7d41">&#9670;&#160;</a></span>write_at() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessWriteDevice, typename ConstBufferSequence&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessWriteDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data at the specified offset before returning. </p>
<p>This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's write_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a51133c1e260b8abeeed55646e765fdd6">asio::write_at</a>(d, 42, <a class="code hl_function" href="#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, size)); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a51133c1e260b8abeeed55646e765fdd6">asio::write_at</a>(</div>
<div class="line">   d, <a class="code hl_variable" href="#a8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, <a class="code hl_variable" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>()); </div>
<div class="ttc" id="anamespaceasio_html_a8dcdb41a4adfd6fe5322b5dd666d9f29"><div class="ttname"><a href="#a8dcdb41a4adfd6fe5322b5dd666d9f29">asio::offset</a></div><div class="ttdeci">uint64_t offset</div><div class="ttdef"><b>Definition</b> read_at.hpp:394</div></div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_add67a05a29d183782491d14aceec7d41_cgraph.svg" width="100%" height="457"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a8c1abcb5870505ea2a0c524a59638da0" name="a8c1abcb5870505ea2a0c524a59638da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1abcb5870505ea2a0c524a59638da0">&#9670;&#160;</a></span>write_at() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessWriteDevice, typename ConstBufferSequence&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessWriteDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write all of the supplied data at the specified offset before returning. </p>
<p>This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's write_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the device.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a51133c1e260b8abeeed55646e765fdd6">asio::write_at</a>(d, 42,</div>
<div class="line">   <a class="code hl_function" href="#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, size), ec); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code hl_function" href="#a51133c1e260b8abeeed55646e765fdd6">asio::write_at</a>(</div>
<div class="line">   d, <a class="code hl_variable" href="#a8dcdb41a4adfd6fe5322b5dd666d9f29">offset</a>, <a class="code hl_variable" href="#a54dede45c3175148a77fe6635222c47d">buffers</a>,</div>
<div class="line">   <a class="code hl_function" href="#a4a82e92df79aa8401a8bc2117d4cf900">asio::transfer_all</a>(), ec); </div>
</div><!-- fragment --> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a8c1abcb5870505ea2a0c524a59638da0_cgraph.svg" width="664" height="134"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a3e6b2f5dd13f4273695fbf0cdec0314a" name="a3e6b2f5dd13f4273695fbf0cdec0314a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e6b2f5dd13f4273695fbf0cdec0314a">&#9670;&#160;</a></span>write_at() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessWriteDevice, typename ConstBufferSequence, typename CompletionCondition&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessWriteDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a certain amount of data at a specified offset before returning. </p>
<p>This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's write_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the device.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest write_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's write_some_at function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes transferred.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code hl_function" href="#a51133c1e260b8abeeed55646e765fdd6">asio::write_at</a>(d, 42, <a class="code hl_function" href="#aab2e5a8bd2a00b088a5644c64ef73e2a">asio::buffer</a>(<a class="code hl_variable" href="jpeglib_8h.html#aa379dc8ae39e55ae0c431a61a7d2f2bc">data</a>, size),</div>
<div class="line">   <a class="code hl_function" href="#a2b10af704afcd6c7ed7f0d3b740033ef">asio::transfer_at_least</a>(32)); </div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a3e6b2f5dd13f4273695fbf0cdec0314a_cgraph.svg" width="100%" height="442"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a51133c1e260b8abeeed55646e765fdd6" name="a51133c1e260b8abeeed55646e765fdd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51133c1e260b8abeeed55646e765fdd6">&#9670;&#160;</a></span>write_at() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncRandomAccessWriteDevice, typename ConstBufferSequence, typename CompletionCondition&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::write_at </td>
          <td>(</td>
          <td class="paramtype">SyncRandomAccessWriteDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition</td>          <td class="paramname"><span class="paramname"><em>completion_condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a certain amount of data at a specified offset before returning. </p>
<p>This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's write_some_at function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the device.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t <a class="code hl_variable" href="#ae2e215d5013596cc2b385bb6c13fa518">completion_condition</a>(</div>
<div class="line">  <span class="comment">// Result of latest write_some_at operation.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code hl_namespace" href="namespaceasio_1_1error.html">error</a>,</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div>
<div class="line">  std::size_t bytes_transferred</div>
<div class="line">); </div>
</div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's write_some_at function.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written. If an error occurs, returns the total number of bytes successfully transferred prior to the error. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a51133c1e260b8abeeed55646e765fdd6_cgraph.svg" width="502" height="124"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="namespaceasio_a51133c1e260b8abeeed55646e765fdd6_icgraph.svg" width="254" height="332"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="aebf19830093dfbea6cb74e6fae02a6c8" name="aebf19830093dfbea6cb74e6fae02a6c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf19830093dfbea6cb74e6fae02a6c8">&#9670;&#160;</a></span>ASIO_MOVE_ARG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a> <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; CompletionCondition asio::ASIO_MOVE_ARG </td>
          <td>(</td>
          <td class="paramtype">CompletionToken</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a945a5c18fa77a9e2eba420f8f44b2a4f" name="a945a5c18fa77a9e2eba420f8f44b2a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945a5c18fa77a9e2eba420f8f44b2a4f">&#9670;&#160;</a></span>b</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a> <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp; asio::b</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54dede45c3175148a77fe6635222c47d" name="a54dede45c3175148a77fe6635222c47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54dede45c3175148a77fe6635222c47d">&#9670;&#160;</a></span>buffers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a> <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> ConstBufferSequence &amp; asio::buffers</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2e215d5013596cc2b385bb6c13fa518" name="ae2e215d5013596cc2b385bb6c13fa518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e215d5013596cc2b385bb6c13fa518">&#9670;&#160;</a></span>completion_condition</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a> <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; CompletionCondition asio::completion_condition</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9accb3ddb108d48e0e70093ec8d40885" name="a9accb3ddb108d48e0e70093ec8d40885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9accb3ddb108d48e0e70093ec8d40885">&#9670;&#160;</a></span>connect_condition</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Executor <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence ConnectCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> Executor Iterator ConnectCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> Executor Iterator Iterator ConnectCondition asio::connect_condition</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96c8c8ad73c13e29b2214f76069cc05d" name="a96c8c8ad73c13e29b2214f76069cc05d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c8c8ad73c13e29b2214f76069cc05d">&#9670;&#160;</a></span>delim</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; MatchCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> DynamicBuffer_v2 char <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> DynamicBuffer_v2 <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> asio::delim</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aba818fe3267fb794f98329cd5a75aee1" name="aba818fe3267fb794f98329cd5a75aee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba818fe3267fb794f98329cd5a75aee1">&#9670;&#160;</a></span>endpoints</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Executor <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence &amp; asio::endpoints</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3dca3b78c7a354543013ff458ca8284b" name="a3dca3b78c7a354543013ff458ca8284b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dca3b78c7a354543013ff458ca8284b">&#9670;&#160;</a></span>f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">F CompletionToken <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> F &amp;&amp; asio::f</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b30afc4cf6e545180cda990770c535e" name="a0b30afc4cf6e545180cda990770c535e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b30afc4cf6e545180cda990770c535e">&#9670;&#160;</a></span>match_condition</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; MatchCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> DynamicBuffer_v2 char <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> DynamicBuffer_v2 <a class="el" href="string__view_8hpp.html#a9b8190487ac30d27075fc7812145e2a6">ASIO_STRING_VIEW_PARAM</a> <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__dynamic__buffer__v2.html">is_dynamic_buffer_v2</a>&lt; DynamicBuffer_v2 &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> DynamicBuffer_v2 MatchCondition asio::match_condition</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8dcdb41a4adfd6fe5322b5dd666d9f29" name="a8dcdb41a4adfd6fe5322b5dd666d9f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dcdb41a4adfd6fe5322b5dd666d9f29">&#9670;&#160;</a></span>offset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="windows_2JackTypes__os_8h.html#afd2e2aa4f6e18915d5d6a4e3cf46ab20">uint64_t</a> asio::offset</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a551ec1a519b15e013e05cb1fe1c4b362" name="a551ec1a519b15e013e05cb1fe1c4b362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551ec1a519b15e013e05cb1fe1c4b362">&#9670;&#160;</a></span>s</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Executor <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> EndpointSequence ConnectCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> Executor Iterator ConnectCondition <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> Executor &amp; asio::s</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ef043a2bc0f0ec501dc3c51b31e2de8" name="a6ef043a2bc0f0ec501dc3c51b31e2de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef043a2bc0f0ec501dc3c51b31e2de8">&#9670;&#160;</a></span>token</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">F CompletionToken <a class="el" href="structasio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;<a class="el" href="group__deprecated.html#ga2bd249124cbf4a9814d7c035850d5e87">::value</a> &gt;<a class="el" href="structasio_1_1associated__allocator.html">::type</a> F CompletionToken &amp;&amp; asio::token</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceasio.html">asio</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
